CODE STRUCTURE ANALYSIS
Directory: ../groggy/src
Generated: rust_structure.txt
============================================================

============================================================
FILE: lib.rs
============================================================

âš™ï¸  FUNCTION: _core() (line 12)
   ğŸ·ï¸  #pymodule
   ğŸ“ Calls: Ok, add, m.add

============================================================
FILE: graph/core.rs
============================================================

ğŸ—ï¸  STRUCT: FastGraph (line 14)
   ğŸ·ï¸  #pyclass

ğŸ”§ IMPL: FastGraph (line 33)
   ğŸ·ï¸  #pymethods
   â””â”€â”€ âš™ï¸  new() (line 35)
       ğŸ·ï¸  #new
       ğŸ“ Calls: â”Œâ”€ ColumnarStore::new, GraphType::new_directed
              â”‚  GraphType::new_undirected, HashMap::new, new
              â”‚  new_directed, new_undirected
              â””â”€
   â””â”€â”€ âš™ï¸  add_node() (line 53)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, Ok, Some, add_node, clone
              â”‚  contains_key, data, graph.add_node, index, insert
              â”‚  new, node_id.clone, node_id_to_index.contains_key
              â”‚  node_id_to_index.insert, node_index.index
              â”‚  node_index_to_id.insert, python_dict_to_json_map
              â”‚  set_node_attribute
              â””â”€
       ğŸ’¬ Add a single node with optional attributes
   â””â”€â”€ âš™ï¸  add_edge() (line 85)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, Ok, Some, add_edge, clone, data
              â”‚  edge_index.index, get, graph.add_edge, index, insert
              â”‚  new, node_id_to_index.get, ok_or_else
              â”‚  python_dict_to_json_map, set_edge_attribute
              â”‚  source.clone, target.clone
              â””â”€
       ğŸ’¬ Add a single edge with optional attributes
   â””â”€â”€ âš™ï¸  node_count() (line 132)
       ğŸ“ Calls: graph.node_count, node_count
       ğŸ’¬ Get node count
   â””â”€â”€ âš™ï¸  edge_count() (line 137)
       ğŸ“ Calls: edge_count, graph.edge_count
       ğŸ’¬ Get edge count
   â””â”€â”€ âš™ï¸  get_node_ids() (line 142)
       ğŸ“ Calls: cloned, collect, keys, node_id_to_index.keys
       ğŸ’¬ Get all node IDs
   â””â”€â”€ âš™ï¸  has_node() (line 147)
       ğŸ“ Calls: contains_key, node_id_to_index.contains_key
       ğŸ’¬ Check if node exists
   â””â”€â”€ âš™ï¸  has_edge() (line 152)
       ğŸ“ Calls: â”Œâ”€ Some, find_edge, get, graph.find_edge, is_some
              â”‚  node_id_to_index.get
              â””â”€
       ğŸ’¬ Check if edge exists
   â””â”€â”€ âš™ï¸  get_neighbors() (line 164)
       ğŸ“ Calls: â”Œâ”€ Ok, cloned, collect, filter_map, get
              â”‚  graph.neighbors, into_iter, neighbors
              â”‚  neighbors_directed, node_id_to_index.get
              â”‚  node_index_to_id.get, ok_or_else
              â””â”€
       ğŸ’¬ Get neighbors of a node (for directed graphs, returns only outgoing neighbors)
   â””â”€â”€ âš™ï¸  get_outgoing_neighbors() (line 187)
       ğŸ“ Calls: â”Œâ”€ Ok, cloned, collect, filter_map, get, into_iter
              â”‚  neighbors_directed, node_id_to_index.get
              â”‚  node_index_to_id.get, ok_or_else
              â””â”€
       ğŸ’¬ Get outgoing neighbors of a node (for directed graphs)
   â””â”€â”€ âš™ï¸  get_incoming_neighbors() (line 204)
       ğŸ“ Calls: â”Œâ”€ Ok, cloned, collect, filter_map, get, into_iter
              â”‚  neighbors_directed, node_id_to_index.get
              â”‚  node_index_to_id.get, ok_or_else
              â””â”€
       ğŸ’¬ Get incoming neighbors of a node (for directed graphs)
   â””â”€â”€ âš™ï¸  get_all_neighbors() (line 221)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, Ok, Some, clone, collect, get
              â”‚  id.clone, insert, into_iter, neighbor_ids.insert
              â”‚  neighbor_ids.into_iter, neighbors_directed, new
              â”‚  node_id_to_index.get, node_index_to_id.get
              â”‚  ok_or_else
              â””â”€
       ğŸ’¬ Get all neighbors of a node (both incoming and outgoing)
   â””â”€â”€ âš™ï¸  get_node_attributes() (line 252)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Ok, Python::with_gil, Some
              â”‚  columnar_store.get_node_attributes, get
              â”‚  get_node_attributes, graph.node_weight, index, insert
              â”‚  json_value_to_python, new, node_id_to_index.get
              â”‚  node_idx.index, node_weight, ok_or_else
              â”‚  py_attributes.insert, with_gil
              â””â”€
       ğŸ’¬ Get node attributes - retrieve from columnar store
   â””â”€â”€ âš™ï¸  get_edge_attributes() (line 283)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Ok, Python::with_gil, Some
              â”‚  columnar_store.get_edge_attributes, edge_idx.index
              â”‚  edge_weight, find_edge, get, get_edge_attributes
              â”‚  graph.edge_weight, graph.find_edge, index, insert
              â”‚  json_value_to_python, new, node_id_to_index.get
              â”‚  py_attributes.insert, with_gil
              â””â”€
       ğŸ’¬ Get edge attributes - retrieve from columnar store
   â””â”€â”€ âš™ï¸  is_directed() (line 323)
       ğŸ’¬ Check if the graph is directed
   â””â”€â”€ âš™ï¸  get_edge_ids() (line 328)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::new, edge_endpoints, edge_ids.push
              â”‚  edge_indices, get, graph.edge_endpoints
              â”‚  graph.edge_indices, new, node_index_to_id.get, push
              â””â”€
       ğŸ’¬ Get edge IDs
   â””â”€â”€ âš™ï¸  set_node_attribute() (line 344)
       ğŸ“ Calls: â”Œâ”€ Ok, get, index, node_id_to_index.get, node_idx.index
              â”‚  ok_or_else, python_value_to_json, set_node_attribute
              â””â”€
       ğŸ’¬ Set a single node attribute
   â””â”€â”€ âš™ï¸  set_edge_attribute() (line 365)
       ğŸ“ Calls: â”Œâ”€ Ok, edge_idx.index, find_edge, get, index
              â”‚  node_id_to_index.get, ok_or_else
              â”‚  python_value_to_json, set_edge_attribute
              â””â”€
       ğŸ’¬ Set a single edge attribute
   â””â”€â”€ âš™ï¸  set_edge_attributes() (line 406)
       ğŸ“ Calls: â”Œâ”€ Ok, edge_idx.index, find_edge, get, index
              â”‚  node_id_to_index.get, ok_or_else
              â”‚  python_dict_to_json_map, set_edge_attribute
              â””â”€
       ğŸ’¬ Set multiple edge attributes at once
   â””â”€â”€ âš™ï¸  set_nodes_attributes_batch() (line 448)
       ğŸ“ Calls: â”Œâ”€ Ok, Python::with_gil
              â”‚  columnar_store.set_node_attribute, get, index
              â”‚  node_id_to_index.get, node_idx.index, ok_or_else
              â”‚  python_pyobject_to_json, set_node_attribute, with_gil
              â””â”€
       ğŸ’¬ Set batch node attributes - efficiently set attributes for multiple nodes
   â””â”€â”€ âš™ï¸  set_edges_attributes_batch() (line 477)
       ğŸ“ Calls: â”Œâ”€ Ok, Python::with_gil
              â”‚  columnar_store.set_edge_attribute, edge_idx.index
              â”‚  find_edge, get, index, node_id_to_index.get
              â”‚  ok_or_else, python_pyobject_to_json
              â”‚  set_edge_attribute, with_gil
              â””â”€
       ğŸ’¬ Set batch edge attributes - efficiently set attributes for multiple edges
   â””â”€â”€ âš™ï¸  remove_node() (line 522)
       ğŸ“ Calls: â”Œâ”€ Some, cloned, collect, columnar_store.remove_edge
              â”‚  columnar_store.remove_node_legacy, edge_endpoints
              â”‚  edge_idx.index, edge_index_to_endpoints.remove
              â”‚  edge_indices, filter, get, graph.edge_endpoints
              â”‚  graph.remove_edge, graph.remove_node, index
              â”‚  into_iter, node_id_to_index.get
              â”‚  node_id_to_index.remove, node_idx.index
              â”‚  node_index_to_id.remove, remove, remove_edge
              â”‚  remove_node, remove_node_legacy, store
              â””â”€
       ğŸ’¬ Remove a node and all its edges
   â””â”€â”€ âš™ï¸  remove_edge() (line 564)
       ğŸ“ Calls: â”Œâ”€ Some, columnar_store.remove_edge, edge_idx.index
              â”‚  edge_index_to_endpoints.remove, find_edge, get
              â”‚  graph.find_edge, graph.remove_edge, index
              â”‚  node_id_to_index.get, remove, remove_edge, store
              â””â”€
       ğŸ’¬ Remove an edge
   â””â”€â”€ âš™ï¸  remove_nodes() (line 589)
       ğŸ“ Calls: remove_node, self.remove_node
       ğŸ’¬ Remove multiple nodes - delegates to single node removal
   â””â”€â”€ âš™ï¸  remove_edges() (line 600)
       ğŸ“ Calls: remove_edge, self.remove_edge
       ğŸ’¬ Remove multiple edges - delegates to single edge removal
   â””â”€â”€ âš™ï¸  add_nodes() (line 611)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, Ok, Some, Vec::with_capacity, add_node
              â”‚  attrs.is_empty, bulk_set_multiple_node_attributes
              â”‚  clone, columnar_data.is_empty, columnar_data.push
              â”‚  columnar_store.bulk_set_multiple_node_attributes
              â”‚  contains_key, graph.add_node, index, insert, is_empty
              â”‚  len, new, node_id.clone
              â”‚  node_id_to_index.contains_key
              â”‚  node_id_to_index.insert, node_index.index
              â”‚  node_index_to_id.insert, nodes_data.is_empty
              â”‚  nodes_data.len, push, python_dict_to_json_map
              â”‚  with_capacity
              â””â”€
       ğŸ’¬ Add multiple nodes in batch - optimized implementation
   â””â”€â”€ âš™ï¸  add_edges() (line 657)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, Ok, Some, Vec::with_capacity, add_edge
              â”‚  attrs.is_empty, bulk_set_multiple_edge_attributes
              â”‚  clone, columnar_data.is_empty, columnar_data.push
              â”‚  columnar_store.bulk_set_multiple_edge_attributes
              â”‚  edge_index.index, edge_index_to_endpoints.insert
              â”‚  edges_data.is_empty, edges_data.len, get
              â”‚  graph.add_edge, index, insert, is_empty, len, new
              â”‚  node_id_to_index.get, push, python_dict_to_json_map
              â”‚  source.clone, target.clone, with_capacity
              â””â”€
       ğŸ’¬ Add multiple edges in batch - optimized implementation
   â””â”€â”€ âš™ï¸  filter_nodes_by_attributes() (line 708)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, NodeIndex::new, Ok, Python::with_gil
              â”‚  Some, Vec::new, clone, filter_nodes_by_attributes
              â”‚  filters.is_empty, get, get_node_ids, insert, is_empty
              â”‚  json_filters.insert, new, node_id.clone, push
              â”‚  python_pyobject_to_json, result.push
              â”‚  self.get_node_ids, with_gil
              â””â”€
       ğŸ’¬ Filter nodes by attribute dictionary - Python interface to columnar filtering
   â””â”€â”€ âš™ï¸  filter_edges_by_attributes() (line 747)
       ğŸ“ Calls: â”Œâ”€ EdgeIndex::new, HashMap::new, IDs, Ok
              â”‚  Python::with_gil, Some, Vec::new, edge_endpoints
              â”‚  filter_edges_by_attributes, filters.is_empty, get
              â”‚  get_edge_ids, insert, is_empty, json_filters.insert
              â”‚  new, node_index_to_id.get, push
              â”‚  python_pyobject_to_json, result.push
              â”‚  self.get_edge_ids, with_gil
              â””â”€
       ğŸ’¬ Filter edges by attribute dictionary - Python interface to columnar filtering
   â””â”€â”€ âš™ï¸  filter_nodes_by_numeric_comparison() (line 791)
       ğŸ“ Calls: â”Œâ”€ NodeIndex::new, Ok, Some, Vec::new, clone
              â”‚  filter_nodes_by_numeric_comparison, get, new
              â”‚  node_id.clone, push, result.push
              â””â”€
       ğŸ’¬ Filter nodes by numeric comparison - Python interface to columnar filtering
   â””â”€â”€ âš™ï¸  filter_nodes_by_string_comparison() (line 816)
       ğŸ“ Calls: â”Œâ”€ NodeIndex::new, Ok, Some, Vec::new, clone
              â”‚  filter_nodes_by_string_comparison, get, new
              â”‚  node_id.clone, push, result.push
              â””â”€
       ğŸ’¬ Filter nodes by string comparison - Python interface to columnar filtering
   â””â”€â”€ âš™ï¸  filter_edges_by_numeric_comparison() (line 841)
       ğŸ“ Calls: â”Œâ”€ EdgeIndex::new, Ok, Some, Vec::new, edge_endpoints
              â”‚  filter_edges_by_numeric_comparison, get, new
              â”‚  node_index_to_id.get, push, result.push
              â””â”€
       ğŸ’¬ Filter edges by numeric comparison - Python interface to columnar filtering
   â””â”€â”€ âš™ï¸  filter_edges_by_string_comparison() (line 871)
       ğŸ“ Calls: â”Œâ”€ EdgeIndex::new, Ok, Some, Vec::new, edge_endpoints
              â”‚  filter_edges_by_string_comparison, get, new
              â”‚  node_index_to_id.get, push, result.push
              â””â”€
       ğŸ’¬ Filter edges by string comparison - Python interface to columnar filtering
   â””â”€â”€ âš™ï¸  filter_nodes_by_attributes_sparse() (line 901)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, NodeIndex::new, ONLY, Ok
              â”‚  Python::with_gil, Some, Vec::new, clone
              â”‚  filter_nodes_sparse, filters.is_empty, get
              â”‚  get_node_ids, insert, is_empty, json_filters.insert
              â”‚  new, node_id.clone, push, python_pyobject_to_json
              â”‚  result.push, self.get_node_ids, with_gil
              â””â”€
       ğŸ’¬ Filter nodes with sparse algorithm - Python interface to optimized sparse filtering
   â””â”€â”€ âš™ï¸  filter_nodes_multi_criteria() (line 940)
       ğŸ“ Calls: â”Œâ”€ Bool, NodeIndex::new, Number, Number::from
              â”‚  Number::from_f64, Ok, Some, String, Value::Bool
              â”‚  Value::Number, Value::String, Vec::new, clone
              â”‚  collect, columnar_store.filter_nodes_multi_criteria
              â”‚  filter_nodes_multi_criteria, filtering, from
              â”‚  from_f64, get, into_iter, map, new, node_id.clone
              â”‚  push, result.push, unwrap_or
              â””â”€
       ğŸ’¬ Optimized multi-criteria node filtering - all intersection logic in Rust
   â””â”€â”€ âš™ï¸  filter_edges_multi_criteria() (line 988)
       ğŸ“ Calls: â”Œâ”€ Bool, EdgeIndex::new, Number, Number::from
              â”‚  Number::from_f64, Ok, Some, String, Value::Bool
              â”‚  Value::Number, Value::String, Vec::new, collect
              â”‚  columnar_store.filter_edges_multi_criteria
              â”‚  edge_endpoints, filter_edges_multi_criteria
              â”‚  filtering, from, from_f64, get, into_iter, map, new
              â”‚  node_index_to_id.get, push, result.push, unwrap_or
              â””â”€
       ğŸ’¬ Optimized multi-criteria edge filtering - all intersection logic in Rust
   â””â”€â”€ âš™ï¸  get_nodes_attribute() (line 1042)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, NodeIndex::new, Ok, Python::with_gil
              â”‚  Some, Vec::new, bulk_indices.iter, bulk_indices.len
              â”‚  clone, collect, columnar_store.get_attribute_bulk
              â”‚  columnar_store.get_node_attribute, enumerate
              â”‚  filter_map, get, get_attribute_bulk
              â”‚  get_node_attribute, idx.index, index, insert, iter
              â”‚  json_value_to_python, json_values.iter
              â”‚  json_values.len, json_values.push, len, map, new
              â”‚  node_id.clone, node_id_to_index.get, node_ids.iter
              â”‚  node_ids.len, node_idx.index, node_index_to_id.get
              â”‚  push, reserve, result.insert, result.reserve
              â”‚  valid_node_ids.push, with_gil
              â””â”€
       ğŸ’¬ Get a specific attribute for multiple nodes efficiently Auto-optimizes based on dataset size and density
   â””â”€â”€ âš™ï¸  get_nodes_attributes() (line 1100)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, HashMap::with_capacity, NodeIndex::new
              â”‚  Ok, Python::with_gil, Some, attributes.len
              â”‚  bulk_results.len, clone, collect
              â”‚  columnar_store.get_multiple_attributes_bulk
              â”‚  columnar_store.get_node_attributes, filter_map, get
              â”‚  get_multiple_attributes_bulk, get_node_attributes
              â”‚  idx.index, index, insert, is_empty, iter
              â”‚  json_attributes.is_empty, json_attributes.len
              â”‚  json_value_to_python, len, map, new, node_id.clone
              â”‚  node_id_to_index.get, node_ids.iter, node_ids.len
              â”‚  node_idx.index, node_index_to_id.get
              â”‚  py_attributes.insert, reserve, result.insert
              â”‚  result.reserve, with_capacity, with_gil
              â””â”€
       ğŸ’¬ Get all attributes for multiple nodes efficiently Auto-optimizes based on request pattern and data density
   â””â”€â”€ âš™ï¸  get_all_nodes_attribute() (line 1161)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, HashMap::with_capacity, NodeIndex::new
              â”‚  Ok, Python::with_gil, Some, clone
              â”‚  columnar_store.get_node_attribute
              â”‚  columnar_store.get_single_attribute_vectorized
              â”‚  enumerate, get, get_node_attribute
              â”‚  get_single_attribute_vectorized, graph.node_count
              â”‚  index, indices.iter, indices.len, insert, iter
              â”‚  json_value_to_python, len, new, node_count
              â”‚  node_id.clone, node_idx.index, node_index_to_id.get
              â”‚  result.insert, with_capacity, with_gil
              â””â”€
       ğŸ’¬ Get a specific attribute for all nodes efficiently (useful for statistics) Auto-optimizes based on data density and sparsity
   â””â”€â”€ âš™ï¸  get_edges_attribute() (line 1203)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Ok, Python::with_gil, Some, Vec::new
              â”‚  bulk_indices.iter, clone
              â”‚  columnar_store.get_attribute_bulk
              â”‚  columnar_store.get_edge_attribute, edge_endpoints.len
              â”‚  edge_idx.index, edge_indices.push, enumerate
              â”‚  find_edge, get, get_attribute_bulk
              â”‚  get_edge_attribute, graph.find_edge, index, insert
              â”‚  iter, json_value_to_python, len, new
              â”‚  node_id_to_index.get, push, result.insert
              â”‚  source.clone, target.clone, valid_endpoints.push
              â”‚  with_gil
              â””â”€
       ğŸ’¬ Get a specific attribute for multiple edges efficiently Auto-optimizes based on request size and data patterns
   â””â”€â”€ âš™ï¸  get_dataframe_data() (line 1261)
       ğŸ“ Calls: â”Œâ”€ HashMap::with_capacity, NodeIndex::new, None, Ok
              â”‚  Python::with_gil, Some, as_deref, attr_name.clone
              â”‚  attr_names.as_deref, clone, collect
              â”‚  columnar_store.export_node_attribute_table, enumerate
              â”‚  export_node_attribute_table, filter_map, get
              â”‚  id.clone, ids.iter, idx.index, index, insert, into_py
              â”‚  iter, json_value_to_python, len, map, new
              â”‚  node_id_to_index.get, node_index_to_id.get
              â”‚  node_indices.as_deref, py.None, results.insert
              â”‚  target_attrs.iter, target_attrs.len
              â”‚  target_nodes.iter, to_string
              â”‚  utils::json_value_to_python, with_capacity, with_gil
              â””â”€
       ğŸ’¬ Ultra-fast DataFrame-style attribute retrieval - bypasses Python conversion overhead Returns data in format optimized for pandas/polars DataFrame creation
   â””â”€â”€ âš™ï¸  get_bulk_node_attribute_vectors() (line 1314)
       ğŸ“ Calls: â”Œâ”€ HashMap::with_capacity, Ok, Python::with_gil, Some
              â”‚  as_deref, bulk_get_node_attribute_vectors, collect
              â”‚  columnar_store.bulk_get_node_attribute_vectors
              â”‚  filter_map, get, ids.iter, idx.index, index, insert
              â”‚  iter, json_value_to_python, len, map
              â”‚  node_id_to_index.get, node_indices.as_deref
              â”‚  raw_data.len, results.insert
              â”‚  utils::json_value_to_python, values.iter
              â”‚  with_capacity, with_gil
              â””â”€
       ğŸ’¬ Ultra-fast vectorized bulk attribute retrieval using columnar store optimization
   â””â”€â”€ âš™ï¸  get_single_attribute_vectorized() (line 1352)
       ğŸ“ Calls: â”Œâ”€ NodeIndex::new, Ok, Python::with_gil, Some, Vec::new
              â”‚  cloned, collect
              â”‚  columnar_store.get_single_attribute_fast, filter_map
              â”‚  get, get_single_attribute_fast, ids.iter, idx.index
              â”‚  index, indices.iter, iter, json_value_to_python, map
              â”‚  new, node_id_to_index.get, node_index_to_id.get
              â”‚  utils::json_value_to_python, values.iter, with_gil
              â””â”€
       ğŸ’¬ Ultra-fast single attribute column retrieval using vectorized columnar operations
   â””â”€â”€ âš™ï¸  export_node_dataframe_optimized() (line 1390)
       ğŸ“ Calls: â”Œâ”€ HashMap::with_capacity, NodeIndex::new, None, Ok
              â”‚  Python::with_gil, Some, as_deref, attr_name.clone
              â”‚  attr_names.as_deref, clone, collect
              â”‚  columnar_store.export_node_attribute_table, enumerate
              â”‚  export_node_attribute_table, filter_map, get
              â”‚  id.clone, ids.iter, idx.index, index, insert, into_py
              â”‚  iter, json_value_to_python, len, map, new
              â”‚  node_id_to_index.get, node_index_to_id.get
              â”‚  node_indices.as_deref, py.None, results.insert
              â”‚  target_attrs.iter, target_attrs.len
              â”‚  target_nodes.iter, to_string
              â”‚  utils::json_value_to_python, with_capacity, with_gil
              â””â”€
       ğŸ’¬ Ultra-fast DataFrame-style bulk data export optimized for pandas/polars
   â””â”€â”€ âš™ï¸  set_node_attributes_chunked() (line 1441)
       ğŸ“ Calls: â”Œâ”€ Ok, Vec::new, Vec::with_capacity, attributes.clone
              â”‚  bulk_add_nodes_internal, bulk_nodes.is_empty
              â”‚  bulk_nodes.push, chunk.len, chunk_size.unwrap_or
              â”‚  chunks, clone, contains_key, extract, is_empty, iter
              â”‚  len, new, node_id.clone, node_id.extract
              â”‚  node_id_to_index.contains_key, push
              â”‚  python_dict_to_json_map, self.bulk_add_nodes_internal
              â”‚  unwrap_or, update_data.chunks, update_data.push
              â”‚  updates.iter, utils::python_dict_to_json_map
              â”‚  with_capacity
              â””â”€
       ğŸ’¬ Chunked bulk attribute updates for maximum performance with large datasets
   â””â”€â”€ âš™ï¸  add_nodes_chunked() (line 1480)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Ok, Some, Vec::with_capacity
              â”‚  bulk_add_nodes_internal, bulk_nodes.is_empty
              â”‚  bulk_nodes.push, chunk.len, chunk_size.unwrap_or
              â”‚  chunks, clone, is_empty, len, new, node_id.clone
              â”‚  nodes_data.chunks, push, python_dict_to_json_map
              â”‚  self.bulk_add_nodes_internal, unwrap_or
              â”‚  utils::python_dict_to_json_map, with_capacity
              â””â”€
       ğŸ’¬ High-performance batch node creation with chunked processing

ğŸ”§ IMPL: FastGraph (line 1512)
   â””â”€â”€ âš™ï¸  get_node_weight() (line 1514)
       ğŸ“ Calls: graph.node_weight, node_weight
       ğŸ’¬ Get node weight by index (internal use)
   â””â”€â”€ âš™ï¸  get_edge_weight() (line 1519)
       ğŸ“ Calls: edge_weight, graph.edge_weight
       ğŸ’¬ Get edge weight by index (internal use)
   â””â”€â”€ âš™ï¸  get_edge_indices() (line 1524)
       ğŸ“ Calls: edge_indices, graph.edge_indices
       ğŸ’¬ Get all edge indices (internal use)
   â””â”€â”€ âš™ï¸  get_edge_endpoints() (line 1529)
       ğŸ“ Calls: edge_endpoints, graph.edge_endpoints
       ğŸ’¬ Get edge endpoints (internal use)
   â””â”€â”€ âš™ï¸  add_node_to_graph_public() (line 1537)
       ğŸ“ Calls: add_node, graph.add_node
       ğŸ’¬ Add node directly to graph (internal use)
   â””â”€â”€ âš™ï¸  add_edge_to_graph_public() (line 1542)
       ğŸ“ Calls: add_edge, graph.add_edge
       ğŸ’¬ Add edge directly to graph (internal use)
   â””â”€â”€ âš™ï¸  get_neighbors_public() (line 1552)
       ğŸ“ Calls: collect, graph.neighbors, neighbors
       ğŸ’¬ Get neighbors by index (internal use)
   â””â”€â”€ âš™ï¸  get_edges_directed() (line 1560)
       ğŸ“ Calls: edges_directed, graph.edges_directed
       ğŸ’¬ Get directed edges (internal use)

============================================================
FILE: graph/types.rs
============================================================

ğŸ—ï¸  STRUCT: NodeData (line 10)
   ğŸ·ï¸  #derive(Debug, Clone, Serialize, Deserialize)

ğŸ—ï¸  STRUCT: EdgeData (line 18)
   ğŸ·ï¸  #derive(Debug, Clone, Serialize, Deserialize)

ğŸ—ï¸  STRUCT: LegacyNodeData (line 28)
   ğŸ·ï¸  #derive(Debug, Clone, Serialize, Deserialize)

ğŸ—ï¸  STRUCT: LegacyEdgeData (line 34)
   ğŸ·ï¸  #derive(Debug, Clone, Serialize, Deserialize)

ğŸ”¢ ENUM: GraphType (line 62)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: GraphType (line 67)
   â””â”€â”€ âš™ï¸  new_directed() (line 68)
       ğŸ“ Calls: Directed, GraphType::Directed, PetGraph::new, new
   â””â”€â”€ âš™ï¸  new_undirected() (line 72)
       ğŸ“ Calls: â”Œâ”€ GraphType::Undirected, PetGraph::new_undirected
              â”‚  Undirected, new_undirected
              â””â”€
   â””â”€â”€ âš™ï¸  node_count() (line 76)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, g.node_count, node_count
              â””â”€
   â””â”€â”€ âš™ï¸  edge_count() (line 83)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, edge_count, g.edge_count
              â””â”€
   â””â”€â”€ âš™ï¸  add_node() (line 90)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, add_node, g.add_node
              â””â”€
   â””â”€â”€ âš™ï¸  add_edge() (line 97)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, add_edge, g.add_edge
              â””â”€
   â””â”€â”€ âš™ï¸  remove_node() (line 109)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, g.remove_node, remove_node
              â””â”€
   â””â”€â”€ âš™ï¸  remove_edge() (line 116)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, g.remove_edge, remove_edge
              â””â”€
   â””â”€â”€ âš™ï¸  find_edge() (line 123)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, find_edge, g.find_edge
              â””â”€
   â””â”€â”€ âš™ï¸  neighbors() (line 134)
       ğŸ“ Calls: â”Œâ”€ Box::new, Directed, GraphType::Directed
              â”‚  GraphType::Undirected, Undirected, g.neighbors
              â”‚  neighbors, new
              â””â”€
   â””â”€â”€ âš™ï¸  node_weight() (line 141)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, g.node_weight, node_weight
              â””â”€
   â””â”€â”€ âš™ï¸  node_weight_mut() (line 148)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, g.node_weight_mut, node_weight_mut
              â””â”€
   â””â”€â”€ âš™ï¸  edge_weight() (line 155)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, edge_weight, g.edge_weight
              â””â”€
   â””â”€â”€ âš™ï¸  edge_weight_mut() (line 162)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, edge_weight_mut, g.edge_weight_mut
              â””â”€
   â””â”€â”€ âš™ï¸  edge_indices() (line 172)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, collect, edge_indices, g.edge_indices
              â””â”€
   â””â”€â”€ âš™ï¸  edges_directed() (line 179)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, collect, edges_directed, g.edges_directed
              â””â”€
   â””â”€â”€ âš™ï¸  neighbors_directed() (line 190)
       ğŸ“ Calls: â”Œâ”€ Box::new, Directed, GraphType::Directed
              â”‚  GraphType::Undirected, Undirected
              â”‚  g.neighbors_directed, neighbors_directed, new
              â””â”€
   â””â”€â”€ âš™ï¸  edge_endpoints() (line 201)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, edge_endpoints, g.edge_endpoints
              â””â”€
   â””â”€â”€ âš™ï¸  clear() (line 211)
       ğŸ“ Calls: â”Œâ”€ Directed, GraphType::Directed, GraphType::Undirected
              â”‚  Undirected, clear, g.clear
              â””â”€

âš™ï¸  FUNCTION: from() (line 42)
   ğŸ“ Calls: HashSet::new, new

âš™ï¸  FUNCTION: from() (line 51)
   ğŸ“ Calls: HashSet::new, new

============================================================
FILE: graph/algorithms.rs
============================================================

ğŸ”§ IMPL: FastGraph (line 5)
   â””â”€â”€ âš™ï¸  bfs() (line 7)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, Some, Vec::new, VecDeque::new, clone
              â”‚  contains, get, get_neighbors_public, insert, new
              â”‚  node_id.clone, node_id_to_index.get
              â”‚  node_index_to_id.get, pop_front, push, push_back
              â”‚  queue.pop_front, queue.push_back, result.push
              â”‚  self.get_neighbors_public, visited.contains
              â”‚  visited.insert
              â””â”€
       ğŸ’¬ Breadth-First Search from a starting node
   â””â”€â”€ âš™ï¸  dfs() (line 34)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, Some, Vec::new, clone, contains, get
              â”‚  get_neighbors_public, insert, neighbors.reverse, new
              â”‚  node_id.clone, node_id_to_index.get
              â”‚  node_index_to_id.get, pop, push, result.push, reverse
              â”‚  self.get_neighbors_public, stack, stack.pop
              â”‚  stack.push, visited.contains, visited.insert
              â””â”€
       ğŸ’¬ Depth-First Search from a starting node
   â””â”€â”€ âš™ï¸  shortest_path() (line 67)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, HashSet::new, Some, Vec::new
              â”‚  VecDeque::new, clone, contains, get
              â”‚  get_neighbors_public, insert, new, node_id.clone
              â”‚  node_id_to_index.get, node_index_to_id.get
              â”‚  parent.get, parent.insert, path.push, path.reverse
              â”‚  pop_front, push, push_back, queue.pop_front
              â”‚  queue.push_back, reverse, self.get_neighbors_public
              â”‚  start_node_id.to_string, to_string, visited.contains
              â”‚  visited.insert
              â””â”€
       ğŸ’¬ Find shortest path between two nodes (BFS-based)
   â””â”€â”€ âš™ï¸  clustering_coefficient() (line 117)
       ğŸ“ Calls: â”Œâ”€ Some, find_edge, get, get_neighbors_public
              â”‚  graph.find_edge, in, is_some, len, neighbors.len
              â”‚  node_id_to_index.get, node_index_to_id.get
              â”‚  self.get_neighbors_public, unwrap
              â””â”€
       ğŸ’¬ Calculate clustering coefficient for a node
   â””â”€â”€ âš™ï¸  average_clustering_coefficient() (line 153)
       ğŸ“ Calls: â”Œâ”€ clustering_coefficient, coefficients.is_empty
              â”‚  coefficients.iter, coefficients.len, collect
              â”‚  filter_map, is_empty, iter, len
              â”‚  self.clustering_coefficient
              â””â”€
       ğŸ’¬ Calculate average clustering coefficient for the entire graph

============================================================
FILE: graph/bulk_operations.rs
============================================================

ğŸ”§ IMPL: FastGraph (line 10)
   â””â”€â”€ âš™ï¸  bulk_add_nodes_internal() (line 12)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, HashSet::new, Vec::with_capacity
              â”‚  add_node, bulk_set_node_attributes, clone
              â”‚  columnar_store.bulk_set_node_attributes, contains_key
              â”‚  entry, graph.add_node, index, insert, len, new
              â”‚  node_id.clone, node_id_to_index.contains_key
              â”‚  node_id_to_index.insert, node_index.index
              â”‚  node_index_to_id.insert, node_indices.push
              â”‚  nodes_data.len, or_insert_with, push, with_capacity
              â””â”€
       ğŸ’¬ Bulk add nodes with optimized columnar storage - INTERNAL USE ONLY
   â””â”€â”€ âš™ï¸  bulk_add_edges_internal() (line 61)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, HashSet::new, Some, Vec::with_capacity
              â”‚  add_edge, bulk_set_edge_attributes, clone
              â”‚  columnar_store.bulk_set_edge_attributes
              â”‚  edge_index.index, edge_index_to_endpoints.insert
              â”‚  edge_indices.push, edges_data.len, entry, get
              â”‚  graph.add_edge, index, insert, len, new
              â”‚  node_id_to_index.get, or_insert_with, push
              â”‚  source.clone, target.clone, with_capacity
              â””â”€
       ğŸ’¬ Bulk add edges with optimized columnar storage - INTERNAL USE ONLY
   â””â”€â”€ âš™ï¸  create_nodes_from_list() (line 115)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Ok, Vec::new, bulk_add_nodes_internal
              â”‚  clone, created_node_ids.push, extract, get_item, iter
              â”‚  len, new, node_id.clone, nodes_data.push, push
              â”‚  py_nodes.iter, python_dict_to_json_map
              â”‚  self.bulk_add_nodes_internal, tuple.get_item
              â”‚  tuple.len
              â””â”€
       ğŸ’¬ Create nodes from Python list - PYTHON INTERFACE ONLY
   â””â”€â”€ âš™ï¸  create_edges_from_list() (line 148)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Ok, Vec::new, bulk_add_edges_internal
              â”‚  edges_data.push, extract, get_item, iter, len, new
              â”‚  push, py_edges.iter, python_dict_to_json_map
              â”‚  self.bulk_add_edges_internal, tuple.get_item
              â”‚  tuple.len
              â””â”€
       ğŸ’¬ Create edges from Python list - PYTHON INTERFACE ONLY
   â””â”€â”€ âš™ï¸  bulk_set_node_attributes_by_uid() (line 180)
       ğŸ“ Calls: â”Œâ”€ Ok, Some, Vec::new, bulk_set_node_attributes
              â”‚  columnar_store.bulk_set_node_attributes, get, index
              â”‚  index_value_pairs.push, new, node_id_to_index.get
              â”‚  node_idx.index, push
              â””â”€
       ğŸ’¬ Bulk set node attributes using attribute UIDs for efficiency
   â””â”€â”€ âš™ï¸  bulk_set_edge_attributes_by_uid() (line 200)
       ğŸ“ Calls: â”Œâ”€ Ok, Some, Vec::new, bulk_set_edge_attributes
              â”‚  columnar_store.bulk_set_edge_attributes
              â”‚  edge_idx.index, find_edge, get, graph.find_edge
              â”‚  index, index_value_pairs.push, new
              â”‚  node_id_to_index.get, push
              â””â”€
       ğŸ’¬ Bulk set edge attributes using attribute UIDs for efficiency

============================================================
FILE: graph/views.rs
============================================================

ğŸ—ï¸  STRUCT: GraphView (line 11)
   ğŸ·ï¸  #pyclass

ğŸ—ï¸  STRUCT: NodeView (line 51)
   ğŸ·ï¸  #pyclass

ğŸ—ï¸  STRUCT: AttributeView (line 91)
   ğŸ·ï¸  #pyclass

ğŸ—ï¸  STRUCT: ViewManager (line 123)
   ğŸ·ï¸  #pyclass

ğŸ”§ IMPL: GraphView (line 23)
   ğŸ·ï¸  #pymethods
   â””â”€â”€ âš™ï¸  new() (line 25)
       ğŸ·ï¸  #new
       ğŸ“ Calls: â”Œâ”€ ColumnarStore::new, GraphType::new_directed
              â”‚  GraphType::new_undirected, HashMap::new, new
              â”‚  new_directed, new_undirected
              â””â”€
   â””â”€â”€ âš™ï¸  topology_stats() (line 41)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, edge_count, graph.edge_count
              â”‚  graph.node_count, insert, new, node_count
              â”‚  stats.insert, to_string
              â””â”€
       ğŸ’¬ Get graph topology statistics

ğŸ”§ IMPL: NodeView (line 60)
   ğŸ·ï¸  #pymethods
   â””â”€â”€ âš™ï¸  new() (line 62)
       ğŸ·ï¸  #new
       ğŸ“ Calls: ColumnarStore::new, HashMap::new, new
   â””â”€â”€ âš™ï¸  node_stats() (line 71)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, extend, get_stats, insert, len, new
              â”‚  node_index_to_id.len, stats.extend, stats.insert
              â”‚  store.get_stats, to_string
              â””â”€
       ğŸ’¬ Get node statistics

ğŸ”§ IMPL: Default for NodeView (line 83)
   â””â”€â”€ âš™ï¸  default() (line 84)
       ğŸ“ Calls: Self::new, new

ğŸ”§ IMPL: AttributeView (line 97)
   ğŸ·ï¸  #pymethods
   â””â”€â”€ âš™ï¸  new() (line 99)
       ğŸ·ï¸  #new
       ğŸ“ Calls: ColumnarStore::new, new
   â””â”€â”€ âš™ï¸  get_attribute_names() (line 106)
       ğŸ“ Calls: clone, collect, entry.key, iter, key, map
       ğŸ’¬ Get all attribute names

ğŸ”§ IMPL: Default for AttributeView (line 115)
   â””â”€â”€ âš™ï¸  default() (line 116)
       ğŸ“ Calls: Self::new, new

ğŸ”§ IMPL: ViewManager (line 130)
   ğŸ·ï¸  #pymethods
   â””â”€â”€ âš™ï¸  new() (line 132)
       ğŸ·ï¸  #new
       ğŸ“ Calls: AttributeView::new, GraphView::new, NodeView::new, new
   â””â”€â”€ âš™ï¸  stats() (line 145)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, attribute_view.get_attribute_names
              â”‚  extend, get_attribute_names
              â”‚  graph_view.topology_stats, insert, len, new
              â”‚  node_stats, node_view.node_stats, stats.extend
              â”‚  stats.insert, to_string, topology_stats
              â””â”€
       ğŸ’¬ Get unified statistics

============================================================
FILE: graph/operations.rs
============================================================

ğŸ”§ IMPL: FastGraph (line 6)
   ğŸ“ High-level graph operations (subgraphs, algorithms, etc.) This module contains ONLY complex operations that operate on the full graph structure
   â””â”€â”€ âš™ï¸  parallel_subgraph_by_node_ids() (line 8)
       ğŸ“ Calls: â”Œâ”€ FastGraph::new, Some, add_edge_to_graph_public
              â”‚  add_node_to_graph_public, as_str, clone
              â”‚  columnar_store.get_edge_attributes
              â”‚  columnar_store.get_node_attributes
              â”‚  columnar_store.set_edge_attribute
              â”‚  columnar_store.set_node_attribute, contains
              â”‚  edge_data.clone, edge_idx.index, get
              â”‚  get_edge_attributes, get_edge_endpoints
              â”‚  get_edge_indices, get_edge_weight
              â”‚  get_node_attributes, get_node_weight, id.clone, index
              â”‚  insert, new, new_edge_idx.index, new_node_idx.index
              â”‚  node_data.clone, node_id_to_index.get
              â”‚  node_ids.contains, node_idx.index
              â”‚  node_index_to_id.get, self.get_edge_endpoints
              â”‚  self.get_edge_indices, self.get_edge_weight
              â”‚  self.get_node_weight, set_edge_attribute
              â”‚  set_node_attribute, source_id.as_str
              â”‚  subgraph.add_edge_to_graph_public
              â”‚  subgraph.add_node_to_graph_public, target_id.as_str
              â””â”€
       ğŸ’¬ Create subgraph with parallel node filtering - HIGH-LEVEL OPERATION ONLY
   â””â”€â”€ âš™ï¸  create_subgraph_by_node_filter() (line 78)
       ğŸ“ Calls: â”Œâ”€ NodeIndex::new, cloned, collect
              â”‚  columnar_store.filter_nodes_sparse, filter_map
              â”‚  filter_nodes_sparse, get, into_iter, new
              â”‚  node_index_to_id.get, parallel_subgraph_by_node_ids
              â”‚  self.parallel_subgraph_by_node_ids
              â””â”€
       ğŸ’¬ Create subgraph by filtering nodes with specific attributes - HIGH-LEVEL OPERATION
   â””â”€â”€ âš™ï¸  filter_nodes_by_degree() (line 99)
       ğŸ“ Calls: â”Œâ”€ Vec::new, clone, count, degree, filtered_nodes.push
              â”‚  graph.neighbors, neighbors, neighbors_directed, new
              â”‚  node_id.clone, push
              â””â”€
       ğŸ’¬ Degree-based node filtering - HIGH-LEVEL OPERATION
   â””â”€â”€ âš™ï¸  get_node_degree() (line 126)
       ğŸ“ Calls: â”Œâ”€ Some, count, get, graph.neighbors, neighbors
              â”‚  neighbors_directed, node_id_to_index.get
              â””â”€
       ğŸ’¬ Get node degree - HIGH-LEVEL OPERATION

============================================================
FILE: utils/conversion.rs
============================================================

âš™ï¸  FUNCTION: python_dict_to_json_map() (line 7)
   ğŸ“ Calls: â”Œâ”€ HashMap::new, Ok, extract, insert, key.extract
          â”‚  map.insert, new, python_to_json_value
          â””â”€
   ğŸ“ Convert Python dictionary to JSON map

âš™ï¸  FUNCTION: python_to_json_value() (line 20)
   ğŸ“ Calls: â”Œâ”€ Array, Bool, JsonValue::Array, JsonValue::Bool
          â”‚  JsonValue::Number, JsonValue::Object, JsonValue::String
          â”‚  Number, Number::from_f64, Object, Ok, Some, String
          â”‚  Vec::new, collect, extract, from_f64, i.into, into
          â”‚  into_iter, is_none, map.into_iter, new, push
          â”‚  py_value.is_none, py_value.str, python_dict_to_json_map
          â”‚  python_to_json_value, str, vec.push
          â””â”€
   ğŸ“ Convert Python value to JSON value

âš™ï¸  FUNCTION: json_value_to_python() (line 52)
   ğŸ“ Calls: â”Œâ”€ Array, Bool, JsonValue::Array, JsonValue::Bool
          â”‚  JsonValue::Number, JsonValue::Object, JsonValue::String
          â”‚  None, Number, Object, Ok, PyDict::new, PyList::empty
          â”‚  Some, String, append, as_f64, as_i64, b.to_object, empty
          â”‚  f.to_object, i.to_object, json_value_to_python, n.as_f64
          â”‚  n.as_i64, new, py.None, py_dict.set_item
          â”‚  py_dict.to_object, py_list.append, py_list.to_object
          â”‚  s.to_object, set_item, to_object
          â””â”€
   ğŸ“ Convert JSON value to Python value

âš™ï¸  FUNCTION: python_value_to_json() (line 86)
   ğŸ“ Calls: python_to_json_value
   ğŸ“ Convert Python value to JSON (alias for python_to_json_value)

âš™ï¸  FUNCTION: python_pyobject_to_json() (line 91)
   ğŸ“ Calls: as_ref, py_obj.as_ref, python_to_json_value
   ğŸ“ Convert PyObject to JSON value

============================================================
FILE: utils/hash.rs
============================================================

âš™ï¸  FUNCTION: fast_hash() (line 5)
   ğŸ“ Calls: xxh3_64
   ğŸ“ Fast hash function using xxHash

âš™ï¸  FUNCTION: hash_string() (line 10)
   ğŸ“ Calls: as_bytes, fast_hash, s.as_bytes
   ğŸ“ Hash a string

âš™ï¸  FUNCTION: hash_to_hex() (line 15)
   ğŸ“ Create a hex string from hash

============================================================
FILE: storage/columnar.rs
============================================================

ğŸ—ï¸  STRUCT: ColumnarStore (line 18)
   ğŸ·ï¸  #pyclass

ğŸ”§ IMPL: Default for ColumnarStore (line 44)
   â””â”€â”€ âš™ï¸  default() (line 45)
       ğŸ“ Calls: Self::new, new

ğŸ”§ IMPL: ColumnarStore (line 51)
   ğŸ·ï¸  #pymethods
   â””â”€â”€ âš™ï¸  new() (line 53)
       ğŸ·ï¸  #new
       ğŸ“ Calls: â”Œâ”€ AtomicBool::new, AtomicU64::new, AtomicUsize::new
              â”‚  DashMap::new, new
              â””â”€
   â””â”€â”€ âš™ï¸  get_stats() (line 69)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, attr_name_to_uid.len
              â”‚  bitmaps_dirty.load, edge_attributes.len
              â”‚  edge_value_bitmaps.len, insert, len, load
              â”‚  max_edge_index.load, max_node_index.load, new
              â”‚  node_attributes.len, node_value_bitmaps.len
              â”‚  stats.insert, to_string
              â””â”€
       ğŸ’¬ Get storage statistics

ğŸ”§ IMPL: ColumnarStore (line 95)
   â””â”€â”€ âš™ï¸  get_or_create_attr_uid() (line 97)
       ğŸ“ Calls: â”Œâ”€ AttrUID, Some, attr_name.to_string
              â”‚  attr_name_to_uid.get, clone, fetch_add, get, insert
              â”‚  to_string, uid.clone
              â””â”€
       ğŸ’¬ Get or create an attribute UID for a given attribute name
   â””â”€â”€ âš™ï¸  get_attr_name() (line 114)
       ğŸ“ Calls: attr_uid_to_name.get, clone, get, map, name.clone
       ğŸ’¬ Get attribute name from UID
   â””â”€â”€ âš™ï¸  set_node_attribute() (line 119)
       ğŸ“ Calls: â”Œâ”€ Some, attr_map.get, attr_map.insert, attr_uid.clone
              â”‚  bitmap.len, bitmap.set, bitmaps_dirty.store, clone
              â”‚  entry, get, get_mut, get_or_create_attr_uid, insert
              â”‚  len, load, max_node_index.load, max_node_index.store
              â”‚  node_attributes.entry, node_value_bitmaps.get_mut
              â”‚  old_value.clone, or_default
              â”‚  self.get_or_create_attr_uid, set, storage, store
              â”‚  value.clone
              â””â”€
       ğŸ’¬ Set node attribute (simplified approach)
   â””â”€â”€ âš™ï¸  get_node_attribute() (line 149)
       ğŸ“ Calls: attr_name_to_uid.get, cloned, get, storage
       ğŸ’¬ Get node attribute
   â””â”€â”€ âš™ï¸  filter_nodes_by_attribute() (line 160)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::new, attr_name_to_uid.get, attr_uid.clone
              â”‚  bitmap.iter, clone, ensure_bitmap_exists, enumerate
              â”‚  get, iter, new, node_value_bitmaps.get, push
              â”‚  result.push, self.ensure_bitmap_exists, value.clone
              â””â”€
       ğŸ’¬ Fast attribute-based filtering using bitmaps (builds on-demand)
   â””â”€â”€ âš™ï¸  ensure_bitmap_exists() (line 185)
       ğŸ“ Calls: â”Œâ”€ BitVec::with_capacity, Some, attr_map.iter
              â”‚  bitmap.resize, bitmap.set, bitmap_key.clone, clone
              â”‚  contains_key, edge_attributes.get
              â”‚  edge_value_bitmaps.contains_key
              â”‚  edge_value_bitmaps.insert, get, insert, iter, load
              â”‚  max_edge_index.load, max_node_index.load
              â”‚  node_attributes.get, node_value_bitmaps.contains_key
              â”‚  node_value_bitmaps.insert, resize, set, with_capacity
              â””â”€
       ğŸ’¬ Ensure a bitmap exists for the given key
   â””â”€â”€ âš™ï¸  filter_nodes_by_attributes() (line 230)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::new, as_bitslice, attr_name_to_uid.get
              â”‚  attr_uid.clone, bitmap.as_bitslice, bitmap.clone
              â”‚  bitmap.iter, clone, ensure_bitmap_exists, enumerate
              â”‚  expected_value.clone, filters.is_empty, get, is_empty
              â”‚  iter, new, node_value_bitmaps.get, push, result.push
              â”‚  self.ensure_bitmap_exists
              â””â”€
       ğŸ’¬ Multi-attribute filtering with bitmap intersection (builds bitmaps on-demand)
   â””â”€â”€ âš™ï¸  get_node_attributes_by_uids() (line 277)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, attr_map.get, attributes.insert
              â”‚  clone, get, get_attr_name, insert, new
              â”‚  node_attributes.get, self.get_attr_name, value.clone
              â””â”€
       ğŸ’¬ Get all attributes for a node using attr_uids from NodeData
   â””â”€â”€ âš™ï¸  get_edge_attributes_by_uids() (line 294)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, attr_map.get, attributes.insert
              â”‚  clone, edge_attributes.get, get, get_attr_name
              â”‚  insert, new, self.get_attr_name, value.clone
              â””â”€
       ğŸ’¬ Get all attributes for an edge using attr_uids from EdgeData
   â””â”€â”€ âš™ï¸  get_node_attributes() (line 312)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, attr_entry.key, attr_entry.value
              â”‚  attr_map.get, attributes.insert, clone, get
              â”‚  get_attr_name, insert, iter, key, new
              â”‚  node_attributes.iter, self.get_attr_name, value
              â”‚  value.clone
              â””â”€
       ğŸ’¬ Get all attributes for a node (legacy interface - looks up attr_uids from NodeData) This method will need to be called with the actual node data to get attr_uids
   â””â”€â”€ âš™ï¸  get_edge_attributes() (line 332)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, attr_entry.key, attr_entry.value
              â”‚  attr_map.get, attributes.insert, clone
              â”‚  edge_attributes.iter, get, get_attr_name, insert
              â”‚  iter, key, new, self.get_attr_name, value
              â”‚  value.clone
              â””â”€
       ğŸ’¬ Get all attributes for an edge (legacy interface)
   â””â”€â”€ âš™ï¸  filter_nodes_by_numeric_comparison() (line 351)
       ğŸ“ Calls: â”Œâ”€ JsonValue::Number, JsonValue::String, Number, Some
              â”‚  String, Vec::new, Vec::with_capacity, abs, as_f64
              â”‚  attr_map.len, attr_name_to_uid.get, extend
              â”‚  filter_map, get, iter, len, n.as_f64, new
              â”‚  node_attributes.get, ok, result.extend, with_capacity
              â””â”€
       ğŸ’¬ Filter nodes by numeric comparison (optimized implementation)
   â””â”€â”€ âš™ï¸  filter_nodes_by_string_comparison() (line 396)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::new, Vec::with_capacity, as_str
              â”‚  attr_map.len, attr_name_to_uid.get, contains
              â”‚  ends_with, extend, filter_map, get, iter
              â”‚  json_value.as_str, len, new, node_attributes.get
              â”‚  node_value.contains, node_value.ends_with
              â”‚  node_value.starts_with, result.extend, starts_with
              â”‚  with_capacity
              â””â”€
       ğŸ’¬ Filter nodes by string comparison (optimized implementation)
   â””â”€â”€ âš™ï¸  remove_node() (line 436)
       ğŸ“ Calls: â”Œâ”€ Some, attr_map.remove, attr_uid.clone, bitmap.len
              â”‚  bitmap.set, bitmaps_dirty.store, clone, get_mut, len
              â”‚  node_attributes.get_mut, node_value_bitmaps.get_mut
              â”‚  remove, set, store
              â””â”€
       ğŸ’¬ Remove node and clean up attribute storage
   â””â”€â”€ âš™ï¸  remove_node_legacy() (line 456)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, attr_entry.key, attr_entry.value
              â”‚  attr_map.contains_key, attr_uid.clone, clone
              â”‚  contains_key, insert, iter, key, new
              â”‚  node_attr_uids.insert, node_attributes.iter
              â”‚  remove_node, self.remove_node, value
              â””â”€
       ğŸ’¬ Remove node and clean up attribute storage (legacy interface - finds attr_uids automatically)

ğŸ”§ IMPL: ColumnarStore (line 475)
   ğŸ“ Edge storage methods (simplified, same pattern as nodes)
   â””â”€â”€ âš™ï¸  set_edge_attribute() (line 477)
       ğŸ“ Calls: â”Œâ”€ Some, attr_map.get, attr_map.insert, attr_uid.clone
              â”‚  bitmap.len, bitmap.set, bitmaps_dirty.store, clone
              â”‚  edge_attributes.entry, edge_value_bitmaps.get_mut
              â”‚  entry, get, get_mut, get_or_create_attr_uid, insert
              â”‚  len, load, max_edge_index.load, max_edge_index.store
              â”‚  old_value.clone, or_default
              â”‚  self.get_or_create_attr_uid, set, storage, store
              â”‚  value.clone
              â””â”€
       ğŸ’¬ Set edge attribute (simplified approach)
   â””â”€â”€ âš™ï¸  get_edge_attribute() (line 507)
       ğŸ“ Calls: attr_name_to_uid.get, cloned, get, storage
       ğŸ’¬ Get edge attribute
   â””â”€â”€ âš™ï¸  filter_edges_by_attributes() (line 518)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::new, as_bitslice, attr_name_to_uid.get
              â”‚  attr_uid.clone, bitmap.as_bitslice, bitmap.clone
              â”‚  bitmap.iter, clone, edge_value_bitmaps.get
              â”‚  ensure_bitmap_exists, enumerate, expected_value.clone
              â”‚  filters.is_empty, get, is_empty, iter, new, push
              â”‚  result.push, self.ensure_bitmap_exists
              â””â”€
       ğŸ’¬ Fast edge filtering using bitmaps (builds on-demand)
   â””â”€â”€ âš™ï¸  filter_edges_by_numeric_comparison() (line 565)
       ğŸ“ Calls: â”Œâ”€ JsonValue::Number, JsonValue::String, Number, Some
              â”‚  String, Vec::new, Vec::with_capacity, abs, as_f64
              â”‚  attr_map.len, attr_name_to_uid.get
              â”‚  edge_attributes.get, extend, filter_map, get, iter
              â”‚  len, n.as_f64, new, ok, result.extend, with_capacity
              â””â”€
       ğŸ’¬ Filter edges by numeric comparison (optimized implementation)
   â””â”€â”€ âš™ï¸  filter_edges_by_string_comparison() (line 610)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::new, Vec::with_capacity, as_str
              â”‚  attr_map.len, attr_name_to_uid.get, contains
              â”‚  edge_attributes.get, edge_value.contains
              â”‚  edge_value.ends_with, edge_value.starts_with
              â”‚  ends_with, extend, filter_map, get, iter
              â”‚  json_value.as_str, len, new, result.extend
              â”‚  starts_with, with_capacity
              â””â”€
       ğŸ’¬ Filter edges by string comparison (optimized implementation)
   â””â”€â”€ âš™ï¸  remove_edge() (line 650)
       ğŸ“ Calls: â”Œâ”€ Some, attr_map.remove, attr_uid.clone, bitmap.len
              â”‚  bitmap.set, bitmaps_dirty.store, clone
              â”‚  edge_attributes.get_mut, edge_value_bitmaps.get_mut
              â”‚  get_mut, len, remove, set, store
              â””â”€
       ğŸ’¬ Remove edge and clean up attribute storage
   â””â”€â”€ âš™ï¸  remove_edge_legacy() (line 670)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, attr_entry.key, attr_entry.value
              â”‚  attr_map.contains_key, attr_uid.clone, clone
              â”‚  contains_key, edge_attr_uids.insert
              â”‚  edge_attributes.iter, insert, iter, key, new
              â”‚  remove_edge, self.remove_edge, value
              â””â”€
       ğŸ’¬ Remove edge and clean up attribute storage (legacy interface)

ğŸ”§ IMPL: Clone for ColumnarStore (line 688)
   â””â”€â”€ âš™ï¸  clone() (line 689)
       ğŸ“ Calls: â”Œâ”€ AtomicBool::new, AtomicU64::new, AtomicUsize::new
              â”‚  attr_name_to_uid.clone, attr_uid_to_name.clone
              â”‚  bitmaps_dirty.load, clone, edge_attributes.clone
              â”‚  edge_value_bitmaps.clone, load, max_edge_index.load
              â”‚  max_node_index.load, new, node_attributes.clone
              â”‚  node_value_bitmaps.clone
              â””â”€

ğŸ”§ IMPL: ColumnarStore (line 714)
   â””â”€â”€ âš™ï¸  batch_set_node_attributes() (line 717)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, HashSet::new, Some
              â”‚  all_attr_names.insert, attr_map.insert
              â”‚  attr_name.clone, attr_name_to_uid.get
              â”‚  attr_name_to_uid.insert, attr_uid.clone
              â”‚  attr_updates.entry, bitmaps_dirty.store, clone, entry
              â”‚  get, get_or_create_attr_uid, insert, load, max
              â”‚  max_node_in_batch.max, max_node_index.load
              â”‚  max_node_index.store, new, node_attributes.entry
              â”‚  or_default, push, self.get_or_create_attr_uid, store
              â””â”€
       ğŸ’¬ Batch set node attributes for multiple nodes efficiently Uses attr_uid mapping and value deduplication
   â””â”€â”€ âš™ï¸  batch_set_edge_attributes() (line 776)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, HashSet::new, Some
              â”‚  all_attr_names.insert, attr_map.insert
              â”‚  attr_name.clone, attr_name_to_uid.get
              â”‚  attr_name_to_uid.insert, attr_uid.clone
              â”‚  attr_updates.entry, bitmaps_dirty.store, clone
              â”‚  edge_attributes.entry, entry, get
              â”‚  get_or_create_attr_uid, insert, load, max
              â”‚  max_edge_in_batch.max, max_edge_index.load
              â”‚  max_edge_index.store, new, or_default, push
              â”‚  self.get_or_create_attr_uid, store
              â””â”€
       ğŸ’¬ Batch set edge attributes for multiple edges efficiently
   â””â”€â”€ âš™ï¸  filter_nodes_sparse() (line 836)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, Some, Vec::new, attr_name_to_uid.get
              â”‚  attr_uid.clone, attr_uid_filters.push
              â”‚  candidates.into_iter, candidates.is_empty
              â”‚  candidates.retain, clone, collect, contains
              â”‚  expected_value.clone, filter_map, filters.is_empty
              â”‚  first, get, into_iter, is_empty, iter
              â”‚  matching_nodes.contains, new, node_attributes.get
              â”‚  push, result.sort_unstable, retain, sort_unstable
              â””â”€
       ğŸ’¬ High-performance multi-attribute filtering using sparse intersection Instead of building full bitmaps, directly intersect sparse attribute maps
   â””â”€â”€ âš™ï¸  get_unique_values_for_attribute() (line 893)
       ğŸ“ Calls: â”Œâ”€ HashSet::new, Some, Vec::new, attr_map.iter
              â”‚  attr_name_to_uid.get, clone, collect
              â”‚  edge_attributes.get, get, insert, into_iter, iter
              â”‚  new, node_attributes.get, unique_values.insert
              â”‚  unique_values.into_iter, value.clone
              â””â”€
       ğŸ’¬ Get unique values for an attribute (for analytics and optimization)
   â””â”€â”€ âš™ï¸  get_value_distribution() (line 916)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, attr_map.iter
              â”‚  attr_name_to_uid.get, clone, distribution.entry
              â”‚  edge_attributes.get, entry, get, iter, new
              â”‚  node_attributes.get, or_default, value.clone
              â””â”€
       ğŸ’¬ Get value distribution for an attribute (useful for query optimization)
   â””â”€â”€ âš™ï¸  bulk_set_node_attributes() (line 939)
       ğŸ“ Calls: â”Œâ”€ Some, attr_map.insert, bitmaps_dirty.store, entry
              â”‚  fetch_max, get_or_create_attr_uid, insert, is_empty
              â”‚  iter, map, max, max_node_index.fetch_max
              â”‚  node_attributes.entry, node_value_pairs.is_empty
              â”‚  node_value_pairs.iter, or_insert_with
              â”‚  self.get_or_create_attr_uid, store
              â””â”€
       ğŸ’¬ Bulk set node attributes for efficient batch operations
   â””â”€â”€ âš™ï¸  bulk_set_edge_attributes() (line 969)
       ğŸ“ Calls: â”Œâ”€ Some, attr_map.insert, bitmaps_dirty.store
              â”‚  edge_attributes.entry, edge_value_pairs.is_empty
              â”‚  edge_value_pairs.iter, entry, fetch_max
              â”‚  get_or_create_attr_uid, insert, is_empty, iter, map
              â”‚  max, max_edge_index.fetch_max, or_insert_with
              â”‚  self.get_or_create_attr_uid, store
              â””â”€
       ğŸ’¬ Bulk set edge attributes for efficient batch operations
   â””â”€â”€ âš™ï¸  bulk_set_multiple_node_attributes() (line 999)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, bulk_set_node_attributes, entry
              â”‚  fetch_max, is_empty, max_node_index.fetch_max, new
              â”‚  nodes_attrs.is_empty, or_insert_with, push
              â”‚  self.bulk_set_node_attributes
              â””â”€
       ğŸ’¬ Bulk set multiple node attributes efficiently - optimized for graph creation
   â””â”€â”€ âš™ï¸  bulk_set_multiple_edge_attributes() (line 1029)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, bulk_set_edge_attributes
              â”‚  edges_attrs.is_empty, entry, fetch_max, is_empty
              â”‚  max_edge_index.fetch_max, new, or_insert_with, push
              â”‚  self.bulk_set_edge_attributes
              â””â”€
       ğŸ’¬ Bulk set multiple edge attributes efficiently - optimized for graph creation
   â””â”€â”€ âš™ï¸  filter_nodes_multi_criteria() (line 1060)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::new, any, candidates.unwrap_or_default
              â”‚  cands.is_empty, cands.retain, collect, contains
              â”‚  exact_filters.is_empty
              â”‚  filter_nodes_by_numeric_comparison
              â”‚  filter_nodes_by_string_comparison
              â”‚  filter_nodes_sparse, into_iter, is_empty
              â”‚  matching_indices.into_iter, matching_set.contains
              â”‚  new, result.sort_unstable, retain
              â”‚  self.filter_nodes_by_numeric_comparison
              â”‚  self.filter_nodes_by_string_comparison
              â”‚  self.filter_nodes_sparse, sort_unstable
              â”‚  unwrap_or_default
              â””â”€
       ğŸ’¬ Optimized multi-criteria filtering that handles exact matches, numeric comparisons, and string comparisons All filtering and intersection logic is done in Rust to avoid Python overhead
   â””â”€â”€ âš™ï¸  filter_edges_multi_criteria() (line 1126)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::new, any, candidates.unwrap_or_default
              â”‚  cands.is_empty, cands.retain, collect, contains
              â”‚  exact_filters.is_empty, filter_edges_by_attributes
              â”‚  filter_edges_by_numeric_comparison
              â”‚  filter_edges_by_string_comparison, into_iter
              â”‚  is_empty, matching_indices.into_iter
              â”‚  matching_set.contains, new, result.sort_unstable
              â”‚  retain, self.filter_edges_by_attributes
              â”‚  self.filter_edges_by_numeric_comparison
              â”‚  self.filter_edges_by_string_comparison, sort_unstable
              â”‚  unwrap_or_default
              â””â”€
       ğŸ’¬ Similar multi-criteria filtering for edges
   â””â”€â”€ âš™ï¸  bulk_get_node_attribute_vectors() (line 1193)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, Vec::new, attr_map.get
              â”‚  attr_map.iter, attr_map.len, attr_name.clone
              â”‚  attr_name_to_uid.get, attr_uid.clone, attr_uids.push
              â”‚  clone, collect, get, indices.push, indices.reserve
              â”‚  indices.to_vec, insert, is_some, iter, len, load
              â”‚  max_node_index.load, min, new, node_attributes.get
              â”‚  node_indices.is_some, push, reserve, results.insert
              â”‚  target_indices.len, to_vec, value.clone, values.push
              â”‚  values.reserve
              â””â”€
       ğŸ’¬ DataFrame-optimized bulk attribute retrieval - returns raw vectors for fast conversion This method is designed for maximum performance when extracting data for pandas/polars
   â””â”€â”€ âš™ï¸  bulk_get_edge_attribute_vectors() (line 1251)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, Vec::new, attr_map.get
              â”‚  attr_map.iter, attr_map.len, attr_name.clone
              â”‚  attr_name_to_uid.get, attr_uid.clone, attr_uids.push
              â”‚  clone, collect, edge_attributes.get
              â”‚  edge_indices.is_some, get, indices.push
              â”‚  indices.reserve, indices.to_vec, insert, is_some
              â”‚  iter, len, load, max_edge_index.load, min, new, push
              â”‚  reserve, results.insert, target_indices.len, to_vec
              â”‚  value.clone, values.push, values.reserve
              â””â”€
       ğŸ’¬ DataFrame-optimized bulk edge attribute retrieval
   â””â”€â”€ âš™ï¸  get_single_attribute_fast() (line 1310)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::with_capacity, attr_map.iter
              â”‚  attr_map.len, attr_name_to_uid.get, clone
              â”‚  edge_attributes.get, get, indices.push, iter, len
              â”‚  node_attributes.get, push, value.clone, values.push
              â”‚  with_capacity
              â””â”€
       ğŸ’¬ Ultra-fast single attribute retrieval for statistics - returns parallel vectors Optimized for cases like "get all salaries" or "get all weights"
   â””â”€â”€ âš™ï¸  get_attribute_bulk() (line 1338)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::with_capacity, attr_map.get
              â”‚  attr_name_to_uid.get, clone, get, is_empty, len
              â”‚  node_attributes.get, node_indices.len, push
              â”‚  result_indices.is_empty, result_indices.push
              â”‚  result_values.push, value.clone, with_capacity
              â””â”€
       ğŸ’¬ Bulk attribute retrieval for multiple nodes - single attribute Returns (node_indices, values) for efficient processing
   â””â”€â”€ âš™ï¸  get_single_attribute_vectorized() (line 1366)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::with_capacity, attr_map.iter
              â”‚  attr_map.len, attr_name_to_uid.get, clone, collect
              â”‚  combined.into_iter, combined.sort_by_key, get
              â”‚  indices.into_iter, indices.push, into_iter, is_empty
              â”‚  iter, len, node_attributes.get, push, sort_by_key
              â”‚  sorted_indices.is_empty, unzip, value.clone
              â”‚  values.into_iter, values.push, with_capacity, zip
              â””â”€
       ğŸ’¬ Vectorized single attribute retrieval for all nodes with the attribute Optimized for dense attribute access patterns
   â””â”€â”€ âš™ï¸  get_multiple_attributes_bulk() (line 1398)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, HashMap::with_capacity, Some
              â”‚  attr_map.get, attr_name.clone, attr_uid_to_name.iter
              â”‚  clone, collect, entry.key, entry.value, get, insert
              â”‚  is_empty, iter, key, len, map, new
              â”‚  node_attributes.get, node_attrs.insert
              â”‚  node_attrs.is_empty, node_indices.is_empty
              â”‚  node_indices.len, results.insert, results.is_empty
              â”‚  value, value.clone, with_capacity
              â””â”€
       ğŸ’¬ Bulk multi-attribute retrieval for multiple nodes Returns HashMap<node_index, HashMap<attr_name, JsonValue>>
   â””â”€â”€ âš™ï¸  get_dataframe_node_data() (line 1439)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, Vec::with_capacity, attr_map.get
              â”‚  attr_name_to_uid.get, attr_uid_to_name.iter
              â”‚  attrs.to_vec, clone, cloned, collect, entry.value
              â”‚  get, indices.to_vec, insert, iter, len, load, map
              â”‚  max_node_index.load, new, node_attributes.get, push
              â”‚  results.insert, target_nodes.len, to_vec, value
              â”‚  values.push, with_capacity
              â””â”€
       ğŸ’¬ DataFrame-optimized bulk multi-attribute retrieval for all nodes Returns data in format optimized for pandas/polars DataFrame creation
   â””â”€â”€ âš™ï¸  export_node_attribute_table() (line 1486)
       ğŸ“ Calls: â”Œâ”€ Some, Vec::with_capacity, attr_map.get
              â”‚  attr_name_to_uid.get, attr_uid_to_name.iter
              â”‚  attrs.to_vec, clone, cloned, collect, column.push
              â”‚  column.resize, entry.value, get, indices.to_vec, iter
              â”‚  len, load, map, max_node_index.load
              â”‚  node_attributes.get, push, resize, target_attrs.len
              â”‚  target_nodes.len, to_vec, value, value_matrix.push
              â”‚  with_capacity
              â””â”€
       ğŸ’¬ High-performance node attribute table export for DataFrame libraries Returns (node_indices, attribute_names, value_matrix) for maximum efficiency
   â””â”€â”€ âš™ï¸  to_pandas_dict() (line 1533)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, None, Ok, Python::with_gil, Some
              â”‚  as_deref, attr_name.clone, attr_names.as_deref
              â”‚  attrs.iter, clone, collect, enumerate
              â”‚  export_node_attribute_table, idx.into_py, insert
              â”‚  into_py, iter, json_value_to_python, map, new
              â”‚  node_indices.as_deref, nodes.iter, py.None
              â”‚  results.insert, self.export_node_attribute_table
              â”‚  to_string, with_gil
              â””â”€
       ğŸ’¬ DataFrame conversion methods for high-performance batch export Returns formatted data ready for pandas/polars
   â””â”€â”€ âš™ï¸  get_column_fast() (line 1574)
       ğŸ“ Calls: â”Œâ”€ Ok, Python::with_gil, Some, Vec::new, collect
              â”‚  get_attribute_bulk, get_single_attribute_vectorized
              â”‚  iter, json_value_to_python, map, new
              â”‚  self.get_attribute_bulk
              â”‚  self.get_single_attribute_vectorized, values.iter
              â”‚  with_gil
              â””â”€
       ğŸ’¬ Ultra-fast single column extraction for DataFrame operations

============================================================
FILE: storage/graph_store.rs
============================================================

ğŸ—ï¸  STRUCT: GraphState (line 15)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: GraphStore (line 26)
   ğŸ·ï¸  #pyclass

ğŸ”§ IMPL: GraphStore (line 34)
   ğŸ·ï¸  #pymethods
   â””â”€â”€ âš™ï¸  new() (line 36)
       ğŸ·ï¸  #new
       ğŸ“ Calls: â”Œâ”€ Arc::new, ContentPool::new, DashMap::new
              â”‚  RwLock::new, create_initial_state, new
              â”‚  store.create_initial_state
              â””â”€
   â””â”€â”€ âš™ï¸  get_current_hash() (line 50)
       ğŸ“ Calls: clone, current_hash.read, read
       ğŸ’¬ Get current graph hash
   â””â”€â”€ âš™ï¸  get_stats() (line 55)
       ğŸ“ Calls: â”Œâ”€ branches.len, content_pool.get_stats, get_stats
              â”‚  insert, len, states.len, stats.insert, to_string
              â””â”€
       ğŸ’¬ Get storage statistics
   â””â”€â”€ âš™ï¸  create_branch() (line 63)
       ğŸ“ Calls: â”Œâ”€ Err, Ok, branches.insert, contains_key
              â”‚  get_current_hash, insert, ok_or_else, or_else
              â”‚  self.get_current_hash, states.contains_key
              â””â”€
       ğŸ’¬ Create a new branch
   â””â”€â”€ âš™ï¸  list_branches() (line 81)
       ğŸ“ Calls: â”Œâ”€ clone, collect, entry.key, entry.value, iter, key
              â”‚  map, value
              â””â”€
       ğŸ’¬ List all branches
   â””â”€â”€ âš™ï¸  store_current_graph() (line 89)
       ğŸ“ Calls: self.store_graph, store_graph
       ğŸ’¬ Store a graph and return its state hash (exposed to Python)
   â””â”€â”€ âš™ï¸  get_graph_from_state() (line 94)
       ğŸ“ Calls: reconstruct_graph, self.reconstruct_graph
       ğŸ’¬ Reconstruct graph from state hash (exposed to Python)

ğŸ”§ IMPL: GraphStore (line 99)
   â””â”€â”€ âš™ï¸  create_initial_state() (line 101)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, SystemTime::now, as_secs
              â”‚  current_hash.write, duration_since, insert, new, now
              â”‚  states.insert, to_string, unwrap, write
              â””â”€
       ğŸ’¬ Create initial empty state
   â””â”€â”€ âš™ï¸  store_graph() (line 123)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, Some, SystemTime::now, as_bytes
              â”‚  as_secs, clone, columnar_store.get_edge_attributes
              â”‚  columnar_store.get_node_attributes
              â”‚  content_pool.intern_edge, content_pool.intern_node
              â”‚  current_hash.write, duration_since
              â”‚  edge_hashes.insert, edge_idx.index, fast_hash, get
              â”‚  get_current_hash, get_edge_attributes
              â”‚  get_edge_indices, get_edge_weight
              â”‚  get_node_attributes, get_node_ids, get_node_weight
              â”‚  graph.get_edge_indices, graph.get_edge_weight
              â”‚  graph.get_node_ids, graph.get_node_weight, id.clone
              â”‚  index, insert, intern_edge, intern_node, new
              â”‚  node_hashes.insert, node_id_to_index.get
              â”‚  node_idx.index, now, self.get_current_hash
              â”‚  source.clone, state_data.as_bytes, state_hash.clone
              â”‚  states.insert, target.clone, unwrap, write
              â””â”€
       ğŸ’¬ Store a graph and return its state hash
   â””â”€â”€ âš™ï¸  reconstruct_graph() (line 184)
       ğŸ“ Calls: â”Œâ”€ EdgeData::from, FastGraph::new, NodeData::from, Some
              â”‚  add_edge_to_graph_public, add_node_to_graph_public
              â”‚  attr_value.clone, clone
              â”‚  columnar_store.set_edge_attribute
              â”‚  columnar_store.set_node_attribute
              â”‚  content_pool.get_edge, content_pool.get_node
              â”‚  edge_hashes.values, edge_idx.index, from, get
              â”‚  get_edge, get_node, graph.add_edge_to_graph_public
              â”‚  graph.add_node_to_graph_public, index, insert, new
              â”‚  new_node_idx.index, node_id.clone
              â”‚  node_id_to_index.get, node_id_to_index.insert
              â”‚  node_index_to_id.insert, set_edge_attribute
              â”‚  set_node_attribute, states.get, values
              â””â”€
       ğŸ’¬ Reconstruct graph from state hash

============================================================
FILE: storage/content_pool.rs
============================================================

ğŸ—ï¸  STRUCT: ContentPool (line 13)
   ğŸ·ï¸  #pyclass

ğŸ”§ IMPL: ContentPool (line 21)
   ğŸ·ï¸  #pymethods
   â””â”€â”€ âš™ï¸  new() (line 23)
       ğŸ·ï¸  #new
       ğŸ“ Calls: DashMap::new, new
   â””â”€â”€ âš™ï¸  get_stats() (line 33)
       ğŸ“ Calls: â”Œâ”€ HashMap::new, edge_refs.len, edges.len, insert, len
              â”‚  new, node_refs.len, nodes.len, stats.insert
              â”‚  to_string
              â””â”€
       ğŸ’¬ Get storage statistics

ğŸ”§ IMPL: ContentPool (line 43)
   â””â”€â”€ âš™ï¸  hash_node() (line 45)
       ğŸ“ Calls: â”Œâ”€ ContentHash, as_bytes, fast_hash
              â”‚  serde_json::to_string, serialized.as_bytes, to_string
              â”‚  unwrap_or_default
              â””â”€
       ğŸ’¬ Hash a node for content addressing
   â””â”€â”€ âš™ï¸  hash_edge() (line 51)
       ğŸ“ Calls: â”Œâ”€ ContentHash, as_bytes, fast_hash
              â”‚  serde_json::to_string, serialized.as_bytes, to_string
              â”‚  unwrap_or_default
              â””â”€
       ğŸ’¬ Hash an edge for content addressing
   â””â”€â”€ âš™ï¸  intern_node() (line 57)
       ğŸ“ Calls: â”Œâ”€ Arc::new, Self::hash_node, clone, entry, hash.clone
              â”‚  hash_node, new, node_refs.entry, nodes.entry
              â”‚  or_insert
              â””â”€
       ğŸ’¬ Store node in pool and return its content hash
   â””â”€â”€ âš™ï¸  intern_edge() (line 71)
       ğŸ“ Calls: â”Œâ”€ Arc::new, Self::hash_edge, clone, edge_refs.entry
              â”‚  edges.entry, entry, hash.clone, hash_edge, new
              â”‚  or_insert
              â””â”€
       ğŸ’¬ Store edge in pool and return its content hash
   â””â”€â”€ âš™ï¸  get_node() (line 85)
       ğŸ“ Calls: clone, entry.clone, get, map, nodes.get
       ğŸ’¬ Get node by content hash
   â””â”€â”€ âš™ï¸  get_edge() (line 90)
       ğŸ“ Calls: clone, edges.get, entry.clone, get, map
       ğŸ’¬ Get edge by content hash
   â””â”€â”€ âš™ï¸  release_node() (line 95)
       ğŸ“ Calls: â”Œâ”€ Some, drop, get_mut, node_refs.get_mut
              â”‚  node_refs.remove, nodes.remove, remove
              â””â”€
       ğŸ’¬ Release a node reference (for garbage collection)
   â””â”€â”€ âš™ï¸  release_edge() (line 109)
       ğŸ“ Calls: â”Œâ”€ Some, drop, edge_refs.get_mut, edge_refs.remove
              â”‚  edges.remove, get_mut, remove
              â””â”€
       ğŸ’¬ Release an edge reference (for garbage collection)
   â””â”€â”€ âš™ï¸  compact() (line 123)
       ğŸ“ Calls: â”Œâ”€ clone, collect, edge_refs.remove, edges.remove
              â”‚  entry.key, entry.value, filter, iter, key, map
              â”‚  node_refs.remove, nodes.remove, remove, value
              â””â”€
       ğŸ’¬ Compact the pool by removing unreferenced items

ğŸ”§ IMPL: Default for ContentPool (line 158)
   â””â”€â”€ âš™ï¸  default() (line 159)
       ğŸ“ Calls: Self::new, new

============================================================
SUMMARY: Analyzed 12 files
============================================================