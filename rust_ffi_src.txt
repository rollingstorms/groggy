--- FILE: lib.rs ---
//! Groggy Python Bindings
//! 
//! Fast graph library with statistical operations and memory-efficient processing.

use pyo3::prelude::*;

// Import all FFI modules
mod ffi;
mod module;

// Re-export main types
pub use ffi::api::graph::PyGraph;
pub use ffi::core::subgraph::PySubgraph;
pub use ffi::core::array::{PyGraphArray, PyGraphMatrix};
pub use ffi::core::accessors::{PyNodesAccessor, PyEdgesAccessor};
pub use ffi::core::views::{PyNodeView, PyEdgeView};
pub use ffi::types::{PyAttrValue, PyResultHandle, PyAttributeCollection};
pub use ffi::core::query::{PyAttributeFilter, PyNodeFilter, PyEdgeFilter};
pub use ffi::core::history::{PyCommit, PyBranchInfo, PyHistoryStatistics};
pub use ffi::api::graph_version::{PyHistoricalView};
pub use ffi::core::traversal::{PyTraversalResult, PyAggregationResult, PyGroupedAggregationResult};

/// A Python module implemented in Rust.
#[pymodule]
fn _groggy(py: Python, m: &PyModule) -> PyResult<()> {
    // Register core graph components
    m.add_class::<PyGraph>()?;
    m.add_class::<PySubgraph>()?;
    
    // Register array and matrix types
    m.add_class::<PyGraphArray>()?;
    m.add_class::<PyGraphMatrix>()?;
    
    // Register accessor and view types
    m.add_class::<PyNodesAccessor>()?;
    m.add_class::<PyEdgesAccessor>()?;
    m.add_class::<PyNodeView>()?;
    m.add_class::<PyEdgeView>()?;
    
    // Register type system
    m.add_class::<PyAttrValue>()?;
    m.add_class::<PyResultHandle>()?;
    m.add_class::<PyAttributeCollection>()?;
    
    // Register query and filter system
    m.add_class::<PyAttributeFilter>()?;
    m.add_class::<PyNodeFilter>()?;
    m.add_class::<PyEdgeFilter>()?;
    
    // Register version control system
    m.add_class::<PyCommit>()?;
    m.add_class::<PyBranchInfo>()?;
    m.add_class::<PyHistoryStatistics>()?;
    m.add_class::<PyHistoricalView>()?;
    
    // Register traversal and aggregation results
    m.add_class::<PyTraversalResult>()?;
    m.add_class::<PyAggregationResult>()?;
    m.add_class::<PyGroupedAggregationResult>()?;
    
    // Add aliases for Python imports - these are already added with correct names
    
    // Register display functions
    ffi::display::register_display_functions(py, m)?;
    
    // Use the module registration function
    module::register_classes(py, m)?;
    
    Ok(())
}

--- FILE: module.rs ---
//! Python Module Registration
//! 
//! This module handles registration of all Python classes and functions
//! for the Groggy library.

use pyo3::prelude::*;

/// Register all classes and functions with the Python module
pub fn register_classes(_py: Python, m: &PyModule) -> PyResult<()> {
    // For now, return Ok - we'll add class registrations as we implement them
    // Example:
    // m.add_class::<PyGraph>()?;
    // m.add_class::<PySubgraph>()?;
    // m.add_class::<PyGraphArray>()?;
    
    Ok(())
}


--- FILE: lib_old.rs ---
#![allow(non_local_definitions)] // Suppress PyO3 macro warnings

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyValueError, PyTypeError, PyRuntimeError, PyKeyError, PyIndexError, PyImportError, PyNotImplementedError};
// use std::collections::HashMap; // TODO: Remove if not needed

// Import from the main groggy crate
use groggy::{
    Graph as RustGraph,
    AttrValue as RustAttrValue, 
    NodeId, 
    EdgeId,
    AttrName,
    StateId,
    // Phase 3 imports - use explicit paths  
    core::{
        array::{GraphArray, StatsSummary},
        subgraph::Subgraph as RustSubgraph,
        query::{
            NodeFilter,
            EdgeFilter,
            AttributeFilter,
        },
    },
    // Version control imports
    core::history::{
        Commit,
        HistoryStatistics,
    },
    core::ref_manager::BranchInfo,
};

mod utils;
use utils::{python_value_to_attr_value, attr_value_to_python_value, graph_error_to_py_err};

/// Helper function to convert AdjacencyMatrix to PyGraphMatrix
fn adjacency_matrix_to_py_graph_matrix(py: Python, matrix: groggy::AdjacencyMatrix) -> PyResult<Py<PyGraphMatrix>> {
    let (rows, cols) = matrix.shape();
    
    // Create column data from adjacency matrix
    let mut columns = Vec::new();
    let mut column_names = Vec::new();
    
    // Create columns representing each row of the adjacency matrix
    for col_idx in 0..cols {
        let mut column_data = Vec::with_capacity(rows);
        
        // Extract column values from the matrix
        for row_idx in 0..rows {
            let value = match &matrix {
                groggy::AdjacencyMatrix::Dense(m) => {
                    m.get(row_idx, col_idx).cloned().unwrap_or(groggy::AttrValue::Float(0.0))
                },
                groggy::AdjacencyMatrix::Sparse(m) => {
                    m.get(row_idx, col_idx).cloned().unwrap_or(groggy::AttrValue::Float(0.0))
                }
            };
            column_data.push(value);
        }
        
        // Create GraphArray for this column
        let graph_array = groggy::GraphArray::from_vec(column_data);
        let py_graph_array = PyGraphArray { inner: graph_array };
        columns.push(Py::new(py, py_graph_array)?);
        column_names.push(format!("col_{}", col_idx));
    }
    
    let py_matrix = PyGraphMatrix {
        columns,
        column_names,
        num_rows: rows,
    };
    
    Ok(Py::new(py, py_matrix)?)
}

/// Native result handle that keeps data in Rust
#[pyclass]
pub struct PyResultHandle {
    nodes: Vec<NodeId>,
    edges: Vec<EdgeId>,
    result_type: String,
}

/// Subgraph - represents a filtered view of the main graph with same interface
#[pyclass(name = "Subgraph", unsendable)]
pub struct PySubgraph {
    // Use the core Rust Subgraph with proper Rc<RefCell<Graph>> architecture
    inner: Option<RustSubgraph>,
    // Fallback data for legacy compatibility (when inner is None)
    nodes: Vec<NodeId>,
    edges: Vec<EdgeId>,
    subgraph_type: String,
    graph: Option<Py<PyGraph>>,
}

impl PySubgraph {
    /// Create a PySubgraph from a core RustSubgraph (with proper graph reference)
    pub fn from_core_subgraph(subgraph: RustSubgraph) -> Self {
        let nodes = subgraph.node_ids();
        let edges = subgraph.edge_ids();
        let subgraph_type = subgraph.subgraph_type().to_string();
        
        PySubgraph {
            inner: Some(subgraph),
            nodes,
            edges,
            subgraph_type,
            graph: None, // Not needed when we have inner
        }
    }
    
    /// Standard PySubgraph constructor
    pub fn new(nodes: Vec<NodeId>, edges: Vec<EdgeId>, subgraph_type: String, graph: Option<Py<PyGraph>>) -> Self {
        PySubgraph {
            inner: None,
            nodes,
            edges,
            subgraph_type,
            graph,
        }
    }
}

#[pymethods]
impl PyResultHandle {
    /// Get the length of the result set without converting to Python
    fn len(&self) -> usize {
        self.nodes.len()
    }
    
    /// Python's len() function support
    fn __len__(&self) -> usize {
        self.nodes.len()
    }
    
    /// Check if result set is empty
    fn is_empty(&self) -> bool {
        self.nodes.is_empty()
    }
    
    /// Get result type
    fn result_type(&self) -> &str {
        &self.result_type
    }
    
    /// Get a slice of nodes (for iteration) - only convert what's needed
    fn get_nodes_slice(&self, start: usize, length: usize) -> Vec<NodeId> {
        let end = (start + length).min(self.nodes.len());
        self.nodes[start..end].to_vec()
    }
    
    /// Get all nodes (only when explicitly requested)
    fn get_all_nodes(&self) -> Vec<NodeId> {
        self.nodes.clone()
    }
    
    /// Iterate over nodes with a step size
    fn iter_nodes(&self, step: Option<usize>) -> Vec<NodeId> {
        let step_size = step.unwrap_or(1);
        self.nodes.iter().step_by(step_size).copied().collect()
    }
    
    /// Apply another filter to this result set (intersection)
    fn apply_filter(&self, graph: &mut PyGraph, filter: &PyNodeFilter) -> PyResult<PyResultHandle> {
        // Filter the nodes in this result set
        let mut filtered_nodes = Vec::new();
        
        for &node_id in &self.nodes {
            // Check if node matches the additional filter
            // Check if node matches the filter by finding it in filtered results
            let temp_result = graph.inner.find_nodes(filter.inner.clone())
                .map_err(graph_error_to_py_err)?;
            if temp_result.contains(&node_id) {
                filtered_nodes.push(node_id);
            }
        }
        
        Ok(PyResultHandle {
            nodes: filtered_nodes,
            edges: self.edges.clone(),
            result_type: format!("{}_filtered", self.result_type),
        })
    }
    
    /// Union with another result handle
    fn union_with(&self, other: &PyResultHandle) -> PyResultHandle {
        let mut combined_nodes = self.nodes.clone();
        for &node in &other.nodes {
            if !combined_nodes.contains(&node) {
                combined_nodes.push(node);
            }
        }
        
        let mut combined_edges = self.edges.clone();
        for &edge in &other.edges {
            if !combined_edges.contains(&edge) {
                combined_edges.push(edge);
            }
        }
        
        PyResultHandle {
            nodes: combined_nodes,
            edges: combined_edges,
            result_type: format!("{}+{}", self.result_type, other.result_type),
        }
    }
    
    /// Intersection with another result handle
    fn intersect_with(&self, other: &PyResultHandle) -> PyResultHandle {
        let intersection_nodes: Vec<NodeId> = self.nodes.iter()
            .filter(|node| other.nodes.contains(node))
            .copied()
            .collect();
            
        let intersection_edges: Vec<EdgeId> = self.edges.iter()
            .filter(|edge| other.edges.contains(edge))
            .copied()
            .collect();
        
        PyResultHandle {
            nodes: intersection_nodes,
            edges: intersection_edges,
            result_type: format!("{}&{}", self.result_type, other.result_type),
        }
    }
}

#[pymethods]
impl PySubgraph {
    /// Get nodes as a property that supports indexing and attribute access
    #[getter]
    fn nodes(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyNodesAccessor>> {
        if let Some(graph_ref) = &self_.graph {
            Py::new(py, PyNodesAccessor {
                graph: graph_ref.clone(),
                constrained_nodes: Some(self_.nodes.clone()),
            })
        } else {
            Err(PyRuntimeError::new_err("No graph reference available"))
        }
    }
    
    /// Get edges as a property that supports indexing and attribute access
    #[getter] 
    fn edges(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyEdgesAccessor>> {
        if let Some(graph_ref) = &self_.graph {
            Py::new(py, PyEdgesAccessor {
                graph: graph_ref.clone(),
                constrained_edges: Some(self_.edges.clone()),
            })
        } else {
            Err(PyRuntimeError::new_err("No graph reference available"))
        }
    }
    
    /// Python len() support - returns number of nodes
    fn __len__(&self) -> usize {
        self.nodes.len()
    }
    
    /// Node count property
    fn node_count(&self) -> usize {
        self.nodes.len()
    }
    
    /// Edge count property
    fn edge_count(&self) -> usize {
        self.edges.len()
    }
    
    /// Get node IDs in this subgraph as GraphArray (lazy Rust view) - use .values for Python list
    #[getter]
    fn node_ids(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let attr_values: Vec<groggy::AttrValue> = self.nodes.iter()
            .map(|&id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }
    
    /// Get edge IDs in this subgraph as GraphArray (lazy Rust view) - use .values for Python list
    #[getter]
    fn edge_ids(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let attr_values: Vec<groggy::AttrValue> = self.edges.iter()
            .map(|&id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }
    
    /// Check if a node exists in this subgraph
    fn has_node(&self, node_id: NodeId) -> bool {
        self.nodes.contains(&node_id)
    }
    
    /// Check if an edge exists in this subgraph
    fn has_edge(&self, edge_id: EdgeId) -> bool {
        self.edges.contains(&edge_id)
    }
    
    /// String representation
    fn __repr__(&self) -> String {
        format!("Subgraph(nodes={}, edges={}, type={})", 
                self.nodes.len(), self.edges.len(), self.subgraph_type)
    }
    
    
    /// Filter edges within this subgraph (chainable)
    fn filter_edges(&self, _py: Python, _filter: &PyAny) -> PyResult<PySubgraph> {
        // Placeholder implementation
        Ok(PySubgraph::new(
            self.nodes.clone(),
            self.edges.clone(),
            format!("{}_edge_filtered", self.subgraph_type),
            self.graph.clone(),
        ))
    }
    
    /// Connected components within this subgraph
    fn connected_components(&self) -> PyResult<Vec<PySubgraph>> {
        // Use inner subgraph if available
        if let Some(ref inner_subgraph) = self.inner {
            let components = inner_subgraph.connected_components()
                .map_err(|e| PyErr::new::<PyRuntimeError, _>(format!("Failed to get connected components: {}", e)))?;
            
            let mut result = Vec::new();
            for (i, component) in components.iter().enumerate() {
                // STANDARDIZED: Use PySubgraph::new() like all other subgraph creation methods
                // This ensures consistent graph reference handling for .nodes/.edges accessors
                result.push(PySubgraph::new(
                    component.node_ids(),
                    component.edge_ids(),
                    format!("connected_component_{}", i),
                    self.graph.clone(),  // Pass the graph reference consistently
                ));
            }
            Ok(result)
        } else {
            // Fallback - return single component for now
            Ok(vec![PySubgraph::new(
                self.nodes.clone(),
                self.edges.clone(),
                "component".to_string(),
                self.graph.clone(),
            )])
        }
    }
    
    /// Set attributes on all nodes in this subgraph (batch operation)
    #[pyo3(signature = (**kwargs))]
    fn set(&mut self, py: Python, kwargs: Option<&PyDict>) -> PyResult<Py<PySubgraph>> {
        // Use inner Subgraph if available (preferred path)
        if let Some(ref inner_subgraph) = self.inner {
            if let Some(kwargs) = kwargs {
                for (key, value) in kwargs.iter() {
                    let attr_name: String = key.extract()?;
                    let attr_value = python_value_to_attr_value(value)?;
                    
                    // Use the core Subgraph's bulk set method
                    inner_subgraph.set_node_attribute_bulk(&attr_name, attr_value)
                        .map_err(|e| PyErr::new::<PyRuntimeError, _>(format!("Failed to set attribute: {}", e)))?;
                }
            }
            
            // Return self for chaining  
            let new_subgraph = if let Some(ref inner) = self.inner {
                PySubgraph::from_core_subgraph(inner.clone())
            } else {
                PySubgraph::new(
                    self.nodes.clone(),
                    self.edges.clone(), 
                    self.subgraph_type.clone(),
                    self.graph.clone(),
                )
            };
            Ok(Py::new(py, new_subgraph)?)
        }
        // Fallback to legacy implementation
        else if let Some(graph_ref) = &self.graph {
            if let Some(kwargs) = kwargs {
                let mut graph = graph_ref.borrow_mut(py);
                
                // Update all nodes in this subgraph
                for &node_id in &self.nodes {
                    for (key, value) in kwargs.iter() {
                        let attr_name: String = key.extract()?;
                        let attr_value = python_value_to_attr_value(value)?;
                        let py_attr_value = PyAttrValue { inner: attr_value };
                        
                        graph.set_node_attribute(node_id, attr_name.clone(), &py_attr_value)?;
                    }
                }
            }
            
            // Return self for chaining
            Ok(Py::new(py, PySubgraph::new(
                self.nodes.clone(),
                self.edges.clone(),
                self.subgraph_type.clone(),
                self.graph.clone(),
            ))?)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot set attributes on subgraph without graph reference. Use graph.filter_nodes() or similar methods."
            ))
        }
    }
    
    /// Update attributes on all nodes in this subgraph using dict syntax
    fn update(&mut self, py: Python, data: &PyDict) -> PyResult<Py<PySubgraph>> {
        if let Some(graph_ref) = &self.graph {
            let mut graph = graph_ref.borrow_mut(py);
            
            // Update all nodes in this subgraph
            for &node_id in &self.nodes {
                for (key, value) in data.iter() {
                    let attr_name: String = key.extract()?;
                    let attr_value = python_value_to_attr_value(value)?;
                    let py_attr_value = PyAttrValue { inner: attr_value };
                    
                    graph.set_node_attribute(node_id, attr_name.clone(), &py_attr_value)?;
                }
            }
            
            // Return self for chaining
            Ok(Py::new(py, PySubgraph::new(
                self.nodes.clone(),
                self.edges.clone(),
                self.subgraph_type.clone(),
                self.graph.clone(),
            ))?)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot update attributes on subgraph without graph reference. Use graph.filter_nodes() or similar methods."
            ))
        }
    }
    
    /// Column access: get all values for a node attribute within this subgraph
    /// This enables: subgraph['component_id'] -> GraphArray with statistical methods
    fn get_node_attribute_column(&self, py: Python, attr_name: &str) -> PyResult<Py<PyGraphArray>> {
        // Use inner Subgraph if available (preferred path)
        if let Some(ref inner_subgraph) = self.inner {
            let attr_values = inner_subgraph.get_node_attribute_column(&attr_name.to_string())
                .map_err(|e| PyErr::new::<PyRuntimeError, _>(format!("Failed to get attribute column: {}", e)))?;
            
            // Create GraphArray from the attribute values
            let graph_array = groggy::GraphArray::from_vec(attr_values);
            
            // Wrap in Python GraphArray
            let py_graph_array = PyGraphArray { inner: graph_array };
            Ok(Py::new(py, py_graph_array)?)
        }
        // Fallback to legacy implementation
        else if let Some(graph_ref) = &self.graph {
            let graph = graph_ref.borrow(py);
            let mut attr_values = Vec::new();
            
            for &node_id in &self.nodes {
                if let Ok(Some(attr_value)) = graph.inner.get_node_attr(node_id, &attr_name.to_string()) {
                    attr_values.push(attr_value);
                } else {
                    // Handle missing attributes with default value
                    attr_values.push(groggy::AttrValue::Int(0));
                }
            }
            
            // Create GraphArray from the attribute values
            let graph_array = groggy::GraphArray::from_vec(attr_values);
            
            // Wrap in Python GraphArray
            let py_graph_array = PyGraphArray { inner: graph_array };
            Ok(Py::new(py, py_graph_array)?)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot access attributes on subgraph without graph reference."
            ))
        }
    }
    
    /// Column access: get all values for an edge attribute within this subgraph
    fn get_edge_attribute_column(&self, py: Python, attr_name: &str) -> PyResult<Vec<PyObject>> {
        if let Some(graph_ref) = &self.graph {
            let graph = graph_ref.borrow(py);
            let mut values = Vec::new();
            
            for &edge_id in &self.edges {
                if let Ok(Some(attr_value)) = graph.inner.get_edge_attr(edge_id, &attr_name.to_string()) {
                    // Convert AttrValue to Python object
                    let py_value = attr_value_to_python_value(py, &attr_value)?;
                    values.push(py_value);
                } else {
                    // Handle missing attributes - use None
                    values.push(py.None());
                }
            }
            
            Ok(values)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot access edge attributes on subgraph without graph reference."
            ))
        }
    }
    
    /// Python dict-like access with multi-column support
    /// - subgraph['attr_name'] -> single column (Vec<PyObject>)  
    /// - subgraph[['age', 'height']] -> multi-column 2D GraphArray of shape (2, n)
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {
        // Try single string first (existing behavior)
        if let Ok(attr_name) = key.extract::<String>() {
            // CRITICAL FIX: Route to edge attributes for edge subgraphs
            if self.subgraph_type == "edge_slice_selection" {
                // This is an edge subgraph - route to edge attributes
                if attr_name == "id" {
                    // Special case: edge IDs (the edges themselves)
                    let edge_ids = self.edges.iter().map(|&edge_id| {
                        groggy::AttrValue::Int(edge_id as i64)
                    }).collect();
                    let graph_array = groggy::GraphArray::from_vec(edge_ids);
                    let py_graph_array = PyGraphArray { inner: graph_array };
                    return Ok(Py::new(py, py_graph_array)?.to_object(py));
                } else {
                    // Regular edge attributes (strength, weight, etc.)
                    let edge_values = self.get_edge_attribute_column(py, &attr_name)?;
                    // Convert Vec<PyObject> to GraphArray for consistency
                    let mut attr_values = Vec::new();
                    for py_value in edge_values {
                        // Convert Python values back to AttrValue
                        if py_value.is_none(py) {
                            attr_values.push(groggy::AttrValue::Int(0)); // Default for missing
                        } else if let Ok(int_val) = py_value.extract::<i64>(py) {
                            attr_values.push(groggy::AttrValue::Int(int_val));
                        } else if let Ok(float_val) = py_value.extract::<f64>(py) {
                            attr_values.push(groggy::AttrValue::Float(float_val as f32));
                        } else if let Ok(str_val) = py_value.extract::<String>(py) {
                            attr_values.push(groggy::AttrValue::Text(str_val));
                        } else if let Ok(bool_val) = py_value.extract::<bool>(py) {
                            attr_values.push(groggy::AttrValue::Bool(bool_val));
                        } else {
                            attr_values.push(groggy::AttrValue::Int(0)); // Fallback
                        }
                    }
                    let graph_array = groggy::GraphArray::from_vec(attr_values);
                    let py_graph_array = PyGraphArray { inner: graph_array };
                    return Ok(Py::new(py, py_graph_array)?.to_object(py));
                }
            } else {
                // This is a node subgraph - route to node attributes (original behavior)
                let column = self.get_node_attribute_column(py, &attr_name)?;
                return Ok(column.to_object(py));
            }
        }
        
        // Try list of strings (multi-column access)
        if let Ok(attr_names) = key.extract::<Vec<String>>() {
            if attr_names.is_empty() {
                return Err(PyValueError::new_err("Empty attribute list"));
            }
            
            // Collect all columns as GraphArrays
            let mut columns = Vec::new();
            let mut num_rows = 0;
            
            // Type checking for mixed types
            let mut column_types = Vec::new();
            
            for attr_name in &attr_names {
                let column = self.get_node_attribute_column(py, attr_name)?;
                
                // Detect column type by borrowing temporarily
                let column_type = {
                    let graph_array = column.borrow(py);
                    
                    // Get the length and detect column type
                    num_rows = graph_array.inner.len();
                    
                    // Sample a few values to determine the predominant type
                    if num_rows > 0 {
                        let sample_size = std::cmp::min(num_rows, 3);
                        let mut type_counts = std::collections::HashMap::new();
                        
                        for i in 0..sample_size {
                            let type_name = match &graph_array.inner[i] {
                                groggy::AttrValue::Int(_) | groggy::AttrValue::SmallInt(_) => "int",
                                groggy::AttrValue::Float(_) => "float", 
                                groggy::AttrValue::Bool(_) => "bool",
                                groggy::AttrValue::Text(_) | groggy::AttrValue::CompactText(_) => "str",
                                _ => "mixed",
                            };
                            *type_counts.entry(type_name).or_insert(0) += 1;
                        }
                        
                        // Get the most common type
                        type_counts.into_iter()
                            .max_by_key(|(_, count)| *count)
                            .map(|(type_name, _)| type_name)
                            .unwrap_or("mixed")
                    } else {
                        "empty"
                    }
                }; // Borrow ends here
                
                column_types.push(column_type);
                columns.push(column);
            }
            
            // Check for mixed types (GraphMatrix constraint)  
            if attr_names.len() > 1 {
                let first_type = column_types[0];
                let has_mixed_types = column_types.iter().any(|&t| t != first_type && t != "empty");
                
                if has_mixed_types {
                    let detected_types: Vec<&str> = column_types.into_iter().collect();
                    return Err(PyTypeError::new_err(format!(
                        "Mixed types detected: [{}]. GraphMatrix requires homogeneous types.\n\
                        Use subgraph.nodes.table()[{:?}] for mixed-type data.",
                        detected_types.join(", "),
                        attr_names
                    )));
                }
            }
            
            // For single column in list form: [['age']] -> return GraphArray (same as 'age')
            if attr_names.len() == 1 {
                return Ok(columns[0].clone_ref(py).to_object(py));
            } else {
                // Multiple columns: [['age', 'height']] -> return PyGraphMatrix (structured collection)
                let matrix = PyGraphMatrix {
                    columns,
                    column_names: attr_names,
                    num_rows,
                };
                
                return Ok(Py::new(py, matrix)?.to_object(py));
            }
        }
        
        Err(PyTypeError::new_err("Key must be a string or list of strings"))
    }
    
    /// Create GraphTable for DataFrame-like view of this subgraph nodes
    fn table(&self, py: Python) -> PyResult<PyObject> {
        // Temporarily return a simple placeholder until PyO3 trait issue is resolved
        let graph_table_module = py.import("groggy.graph_table")?;
        let graph_table_class = graph_table_module.getattr("GraphTable")?;
        
        // Simple approach: create empty GraphTable and set attributes manually  
        let empty_list = py.eval("[]", None, None)?;
        let table = graph_table_class.call1((empty_list, "nodes"))?;
        Ok(table.to_object(py))
    }
    
    /// Create GraphTable for DataFrame-like view of this subgraph edges
    fn edges_table(&self, py: Python) -> PyResult<PyObject> {
        // Temporarily return a simple placeholder until PyO3 trait issue is resolved
        let graph_table_module = py.import("groggy.graph_table")?;
        let graph_table_class = graph_table_module.getattr("GraphTable")?;
        
        // Simple approach: create empty GraphTable and set attributes manually  
        let empty_list = py.eval("[]", None, None)?;
        let table = graph_table_class.call1((empty_list, "edges"))?;
        Ok(table.to_object(py))
    }
    
    /// Enhanced filter_nodes method using the existing graph's filter capabilities
    /// This enables chaining: subgraph.filter_nodes('age > 30').filter_nodes('dept == "Engineering"')
    fn filter_nodes(&self, py: Python, filter_obj: &PyAny) -> PyResult<PySubgraph> {
        if let Some(graph_ref) = &self.graph {
            let graph = graph_ref.borrow(py);
            
            // Convert the filter and apply it to this subgraph's nodes
            // For now, we'll create a basic attribute filter implementation
            if let Ok(filter_str) = filter_obj.extract::<String>() {
                // Parse the filter string and apply to our node subset
                // This is a simplified implementation - in practice, we'd use the full parser
                let filtered_nodes = self.nodes.iter()
                    .filter(|&&node_id| {
                        // For demonstration, let's support a simple "dept == 'Engineering'" pattern
                        if filter_str.contains("==") {
                            let parts: Vec<&str> = filter_str.split("==").map(|s| s.trim()).collect();
                            if parts.len() == 2 {
                                let attr_name = parts[0].trim_matches('"').trim_matches('\'');
                                let attr_value = parts[1].trim_matches('"').trim_matches('\'');
                                
                                if let Ok(Some(node_attr)) = graph.inner.get_node_attr(node_id, &attr_name.to_string()) {
                                    // Simple string comparison
                                    if let RustAttrValue::Text(text_val) = &node_attr {
                                        return text_val == attr_value;
                                    }
                                }
                            }
                        }
                        false
                    })
                    .copied()
                    .collect::<Vec<_>>();
                
                // Calculate induced edges for the filtered nodes
                let filtered_edges = self.edges.iter()
                    .filter(|&&edge_id| {
                        if let Ok((source, target)) = graph.edge_endpoints(edge_id) {
                            filtered_nodes.contains(&source) && filtered_nodes.contains(&target)
                        } else {
                            false
                        }
                    })
                    .copied()
                    .collect();
                
                Ok(PySubgraph::new(
                    filtered_nodes,
                    filtered_edges,
                    format!("{}_filtered", self.subgraph_type),
                    self.graph.clone(),
                ))
            } else {
                Err(PyErr::new::<PyValueError, _>(
                    "Filter must be a string. Example: subgraph.filter_nodes('dept == \"Engineering\"')"
                ))
            }
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot filter subgraph without graph reference."
            ))
        }
    }
    
    // ========================================================================
    // ADJACENCY MATRIX OPERATIONS (same interface as Graph)
    // ========================================================================
    
    /// Generate adjacency matrix for subgraph - same API as graph.adjacency_matrix()
    fn adjacency_matrix(&self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        if let Some(graph_ref) = &self.graph {
            let graph = graph_ref.borrow(py);
            let node_ids = self.nodes.clone();
            graph.subgraph_adjacency_matrix(py, node_ids)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot create adjacency matrix for subgraph without graph reference."
            ))
        }
    }
    
    /// Generate adjacency matrix for subgraph (cleaner API)
    /// Returns: GraphMatrix with multi-index access (matrix[0, 1])
    /// This is a cleaner alias for adjacency_matrix()
    fn adjacency(&self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        self.adjacency_matrix(py)
    }
    
    /// Generate weighted adjacency matrix for subgraph - same API as graph.weighted_adjacency_matrix()
    fn weighted_adjacency_matrix(&self, py: Python, _weight_attr: &str) -> PyResult<Py<PyGraphMatrix>> {
        if let Some(graph_ref) = &self.graph {
            let graph = graph_ref.borrow(py);
            let node_ids = self.nodes.clone();
            
            // For now, just return unweighted adjacency matrix for subgraph
            // TODO: Implement weighted subgraph matrices by extracting weights from edges
            graph.subgraph_adjacency_matrix(py, node_ids)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot create weighted adjacency matrix for subgraph without graph reference."
            ))
        }
    }
    
    /// Generate Laplacian matrix for subgraph - same API as graph.laplacian_matrix()
    fn laplacian_matrix(&self, _py: Python, _normalized: Option<bool>) -> PyResult<Py<PyGraphMatrix>> {
        Err(PyErr::new::<PyNotImplementedError, _>(
            "Subgraph Laplacian matrices not yet implemented. Use graph.laplacian_matrix() for full graph."
        ))
    }

    ///Generate Laplacian matrix for subgraph (cleaner API)
    fn laplacian(&self, _py: Python, _normalized: Option<bool>) -> PyResult<Py<PyGraphMatrix>> {
        Err(PyErr::new::<PyNotImplementedError, _>(
            "Subgraph Laplacian matrices not yet implemented. Use graph.laplacian_matrix() for full graph."
        ))
    }
    
}

/// Native attribute collection that keeps data in Rust
#[pyclass(unsendable)]
pub struct PyAttributeCollection {
    graph_ref: *const RustGraph, // Unsafe but controlled access
    node_ids: Vec<NodeId>,
    attr_name: String,
}

#[pymethods] 
impl PyAttributeCollection {
    /// Get count of attributes without converting
    fn len(&self) -> usize {
        self.node_ids.len()
    }
    
    /// Compute statistics directly in Rust
    fn compute_stats(&self, py: Python) -> PyResult<PyObject> {
        // Safe because we control the lifetime
        let graph = unsafe { &*self.graph_ref };
        
        let mut values = Vec::new();
        for &node_id in &self.node_ids {
            if let Ok(Some(attr)) = graph.get_node_attr(node_id, &self.attr_name) {
                values.push(attr);
            }
        }
        
        // Compute statistics in Rust
        {
            let dict = PyDict::new(py);
            
            // Count
            dict.set_item("count", values.len())?;
            
            // Type-specific statistics
            if !values.is_empty() {
                match &values[0] {
                    RustAttrValue::Int(_) => {
                        let int_values: Vec<i64> = values.iter()
                            .filter_map(|v| if let RustAttrValue::Int(i) = v { Some(*i) } else { None })
                            .collect();
                        
                        if !int_values.is_empty() {
                            let sum: i64 = int_values.iter().sum();
                            let avg = sum as f64 / int_values.len() as f64;
                            let min = *int_values.iter().min().unwrap();
                            let max = *int_values.iter().max().unwrap();
                            
                            dict.set_item("sum", sum)?;
                            dict.set_item("average", avg)?;
                            dict.set_item("min", min)?;
                            dict.set_item("max", max)?;
                        }
                    },
                    RustAttrValue::Float(_) => {
                        let float_values: Vec<f32> = values.iter()
                            .filter_map(|v| if let RustAttrValue::Float(f) = v { Some(*f) } else { None })
                            .collect();
                        
                        if !float_values.is_empty() {
                            let sum: f32 = float_values.iter().sum();
                            let avg = sum / float_values.len() as f32;
                            let min = float_values.iter().fold(f32::INFINITY, |a, &b| a.min(b));
                            let max = float_values.iter().fold(f32::NEG_INFINITY, |a, &b| a.max(b));
                            
                            dict.set_item("sum", sum)?;
                            dict.set_item("average", avg)?;
                            dict.set_item("min", min)?;
                            dict.set_item("max", max)?;
                        }
                    },
                    _ => {
                        // For other types, just provide count
                    }
                }
            }
            
            Ok(dict.to_object(py))
        }
    }
    
    /// Get sample values without converting all
    fn sample_values(&self, count: usize) -> PyResult<Vec<PyAttrValue>> {
        let graph = unsafe { &*self.graph_ref };
        let mut results = Vec::new();
        
        let step = if self.node_ids.len() <= count { 
            1 
        } else { 
            self.node_ids.len() / count 
        };
        
        for &node_id in self.node_ids.iter().step_by(step).take(count) {
            if let Ok(Some(attr)) = graph.get_node_attr(node_id, &self.attr_name) {
                results.push(PyAttrValue { inner: attr });
            }
        }
        
        Ok(results)
    }
}

/// Python wrapper for AttrValue
#[pyclass(name = "AttrValue")]
#[derive(Clone)]
pub struct PyAttrValue {
    inner: RustAttrValue,
}

#[pymethods]
impl PyAttrValue {
    #[new]
    fn new(value: &PyAny) -> PyResult<Self> {
        let rust_value = if let Ok(b) = value.extract::<bool>() {
            RustAttrValue::Bool(b)
        } else if let Ok(i) = value.extract::<i64>() {
            RustAttrValue::Int(i)
        } else if let Ok(f) = value.extract::<f64>() {
            RustAttrValue::Float(f as f32)  // Convert f64 to f32
        } else if let Ok(f) = value.extract::<f32>() {
            RustAttrValue::Float(f)
        } else if let Ok(s) = value.extract::<String>() {
            RustAttrValue::Text(s)
        } else if let Ok(vec) = value.extract::<Vec<f32>>() {
            RustAttrValue::FloatVec(vec)
        } else if let Ok(vec) = value.extract::<Vec<f64>>() {
            // Convert Vec<f64> to Vec<f32>
            let f32_vec: Vec<f32> = vec.into_iter().map(|f| f as f32).collect();
            RustAttrValue::FloatVec(f32_vec)
        } else if let Ok(bytes) = value.extract::<Vec<u8>>() {
            RustAttrValue::Bytes(bytes)
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "Unsupported attribute value type. Supported types: int, float, str, bool, List[float], bytes"
            ));
        };
        
        Ok(Self { inner: rust_value })
    }
    
    #[getter]
    fn value(&self, py: Python) -> PyObject {
        match &self.inner {
            RustAttrValue::Int(i) => i.to_object(py),
            RustAttrValue::Float(f) => f.to_object(py),
            RustAttrValue::Text(s) => s.to_object(py),
            RustAttrValue::Bool(b) => b.to_object(py),
            RustAttrValue::FloatVec(v) => v.to_object(py),
            RustAttrValue::Bytes(b) => b.to_object(py),
            // Handle optimized variants by extracting their underlying value
            RustAttrValue::CompactText(cs) => cs.as_str().to_object(py),
            RustAttrValue::SmallInt(i) => i.to_object(py),
            RustAttrValue::CompressedText(cd) => {
                match cd.decompress_text() {
                    Ok(data) => data.to_object(py),
                    Err(_) => py.None()
                }
            },
            RustAttrValue::CompressedFloatVec(cd) => {
                match cd.decompress_float_vec() {
                    Ok(data) => data.to_object(py),
                    Err(_) => py.None()
                }
            },
        }
    }
    
    #[getter]
    fn type_name(&self) -> &'static str {
        match &self.inner {
            RustAttrValue::Int(_) => "int",
            RustAttrValue::Float(_) => "float",
            RustAttrValue::Text(_) => "text",
            RustAttrValue::Bool(_) => "bool",
            RustAttrValue::FloatVec(_) => "float_vec",
            RustAttrValue::Bytes(_) => "bytes",
            RustAttrValue::CompactText(_) => "text",
            RustAttrValue::SmallInt(_) => "int",
            RustAttrValue::CompressedText(_) => "text",
            RustAttrValue::CompressedFloatVec(_) => "float_vec",
        }
    }
    
    fn __repr__(&self) -> String {
        format!("AttrValue({})", match &self.inner {
            RustAttrValue::Int(i) => i.to_string(),
            RustAttrValue::Float(f) => f.to_string(),
            RustAttrValue::Text(s) => format!("\"{}\"", s),
            RustAttrValue::Bool(b) => b.to_string(),
            RustAttrValue::FloatVec(v) => format!("{:?}", v),
            RustAttrValue::Bytes(b) => format!("b\"{:?}\"", b),
            RustAttrValue::CompactText(cs) => format!("\"{}\"", cs.as_str()),
            RustAttrValue::SmallInt(i) => i.to_string(),
            RustAttrValue::CompressedText(cd) => {
                match cd.decompress_text() {
                    Ok(data) => format!("\"{}\"", data),
                    Err(_) => "compressed(error)".to_string()
                }
            },
            RustAttrValue::CompressedFloatVec(cd) => {
                match cd.decompress_float_vec() {
                    Ok(data) => format!("{:?}", data),
                    Err(_) => "compressed(error)".to_string()
                }
            },
        })
    }
    
    fn __eq__(&self, other: &PyAttrValue) -> bool {
        self.inner == other.inner
    }
    
    fn __hash__(&self) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        // Create a hash based on the variant and value
        match &self.inner {
            RustAttrValue::Int(i) => {
                0u8.hash(&mut hasher);
                i.hash(&mut hasher);
            },
            RustAttrValue::Float(f) => {
                1u8.hash(&mut hasher);
                f.to_bits().hash(&mut hasher);
            },
            RustAttrValue::Text(s) => {
                2u8.hash(&mut hasher);
                s.hash(&mut hasher);
            },
            RustAttrValue::Bool(b) => {
                3u8.hash(&mut hasher);
                b.hash(&mut hasher);
            },
            RustAttrValue::FloatVec(v) => {
                4u8.hash(&mut hasher);
                for f in v {
                    f.to_bits().hash(&mut hasher);
                }
            },
            RustAttrValue::Bytes(b) => {
                5u8.hash(&mut hasher);
                b.hash(&mut hasher);
            },
            RustAttrValue::CompactText(cs) => {
                6u8.hash(&mut hasher);
                cs.as_str().hash(&mut hasher);
            },
            RustAttrValue::SmallInt(i) => {
                7u8.hash(&mut hasher);
                i.hash(&mut hasher);
            },
            RustAttrValue::CompressedText(cd) => {
                8u8.hash(&mut hasher);
                if let Ok(text) = cd.decompress_text() {
                    text.hash(&mut hasher);
                }
            },
            RustAttrValue::CompressedFloatVec(cd) => {
                9u8.hash(&mut hasher);
                if let Ok(vec) = cd.decompress_float_vec() {
                    for f in vec {
                        f.to_bits().hash(&mut hasher);
                    }
                }
            },
        }
        hasher.finish()
    }
}

/// Python wrapper for AttributeFilter
#[pyclass(name = "AttributeFilter")]
#[derive(Clone)]
pub struct PyAttributeFilter {
    inner: AttributeFilter,
}

#[pymethods]
impl PyAttributeFilter {
    #[staticmethod]
    fn equals(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::Equals(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn greater_than(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::GreaterThan(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn less_than(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::LessThan(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn not_equals(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::NotEquals(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn greater_than_or_equal(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::GreaterThanOrEqual(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn less_than_or_equal(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::LessThanOrEqual(value.inner.clone()) }
    }
}

/// Python wrapper for NodeFilter
#[pyclass(name = "NodeFilter")]
#[derive(Clone)]
pub struct PyNodeFilter {
    inner: NodeFilter,
}

#[pymethods]
impl PyNodeFilter {
    #[staticmethod]
    fn has_attribute(name: AttrName) -> Self {
        Self { inner: NodeFilter::HasAttribute { name } }
    }
    
    #[staticmethod]
    fn attribute_equals(name: AttrName, value: &PyAttrValue) -> Self {
        Self { 
            inner: NodeFilter::AttributeEquals { 
                name, 
                value: value.inner.clone() 
            } 
        }
    }
    
    #[staticmethod]
    fn attribute_filter(name: AttrName, filter: &PyAttributeFilter) -> Self {
        Self { 
            inner: NodeFilter::AttributeFilter { 
                name, 
                filter: filter.inner.clone() 
            } 
        }
    }
    
    #[staticmethod]
    fn and_filters(filters: Vec<PyRef<PyNodeFilter>>) -> Self {
        let rust_filters: Vec<NodeFilter> = filters.iter()
            .map(|f| f.inner.clone())
            .collect();
        Self { inner: NodeFilter::And(rust_filters) }
    }
    
    #[staticmethod]
    fn or_filters(filters: Vec<PyRef<PyNodeFilter>>) -> Self {
        let rust_filters: Vec<NodeFilter> = filters.iter()
            .map(|f| f.inner.clone())
            .collect();
        Self { inner: NodeFilter::Or(rust_filters) }
    }
    
    #[staticmethod]
    fn not_filter(filter: &PyNodeFilter) -> Self {
        Self { inner: NodeFilter::Not(Box::new(filter.inner.clone())) }
    }
}

/// Python wrapper for EdgeFilter
#[pyclass(name = "EdgeFilter")]
#[derive(Clone)]
pub struct PyEdgeFilter {
    inner: EdgeFilter,
}

#[pymethods]
impl PyEdgeFilter {
    #[staticmethod]
    fn has_attribute(name: AttrName) -> Self {
        Self { inner: EdgeFilter::HasAttribute { name } }
    }
    
    #[staticmethod]
    fn attribute_equals(name: AttrName, value: &PyAttrValue) -> Self {
        Self { 
            inner: EdgeFilter::AttributeEquals { 
                name, 
                value: value.inner.clone() 
            } 
        }
    }
    
    #[staticmethod]
    fn attribute_filter(name: AttrName, filter: &PyAttributeFilter) -> Self {
        Self { 
            inner: EdgeFilter::AttributeFilter { 
                name, 
                filter: filter.inner.clone() 
            } 
        }
    }
    
    #[staticmethod]
    fn and_filters(filters: Vec<PyRef<PyEdgeFilter>>) -> Self {
        let rust_filters: Vec<EdgeFilter> = filters.iter()
            .map(|f| f.inner.clone())
            .collect();
        Self { inner: EdgeFilter::And(rust_filters) }
    }
    
    #[staticmethod]
    fn or_filters(filters: Vec<PyRef<PyEdgeFilter>>) -> Self {
        let rust_filters: Vec<EdgeFilter> = filters.iter()
            .map(|f| f.inner.clone())
            .collect();
        Self { inner: EdgeFilter::Or(rust_filters) }
    }
    
    #[staticmethod]
    fn not_filter(filter: &PyEdgeFilter) -> Self {
        Self { inner: EdgeFilter::Not(Box::new(filter.inner.clone())) }
    }
}

/// Python wrapper for TraversalResult (stub)
#[pyclass(name = "TraversalResult")]
pub struct PyTraversalResult {
    nodes: Vec<NodeId>,
    edges: Vec<EdgeId>,
}

#[pymethods]
impl PyTraversalResult {
    #[getter]
    fn nodes(&self) -> Vec<NodeId> {
        self.nodes.clone()
    }
    
    #[getter]
    fn edges(&self) -> Vec<EdgeId> {
        self.edges.clone()  
    }
    
    #[getter]
    fn algorithm(&self) -> String {
        "NotImplemented".to_string()
    }
}

/// Python wrapper for GroupedAggregationResult
#[pyclass(name = "GroupedAggregationResult")]
pub struct PyGroupedAggregationResult {
    pub value: PyObject,
}

#[pymethods]
impl PyGroupedAggregationResult {
    #[getter]
    fn value(&self) -> PyObject {
        self.value.clone()
    }
    
    fn __repr__(&self) -> String {
        "GroupedAggregationResult(...)".to_string()
    }
}

/// Python wrapper for AggregationResult
#[pyclass(name = "AggregationResult")]
pub struct PyAggregationResult {
    pub value: f64,
}

#[pymethods]
impl PyAggregationResult {
    #[getter]
    fn value(&self) -> f64 {
        self.value
    }
    
    fn __repr__(&self) -> String {
        format!("AggregationResult({})", self.value)
    }
}

/// Python wrapper for Commit
#[pyclass(name = "Commit")]
#[derive(Clone)]
pub struct PyCommit {
    inner: std::sync::Arc<Commit>,
}

#[pymethods]
impl PyCommit {
    #[getter]
    fn id(&self) -> StateId {
        self.inner.id
    }
    
    #[getter]
    fn parents(&self) -> Vec<StateId> {
        self.inner.parents.clone()
    }
    
    #[getter]
    fn message(&self) -> String {
        self.inner.message.clone()
    }
    
    #[getter]
    fn author(&self) -> String {
        self.inner.author.clone()
    }
    
    #[getter]
    fn timestamp(&self) -> u64 {
        self.inner.timestamp
    }
    
    fn is_root(&self) -> bool {
        self.inner.is_root()
    }
    
    fn is_merge(&self) -> bool {
        self.inner.is_merge()
    }
    
    fn __repr__(&self) -> String {
        format!("Commit(id={}, message='{}', author='{}')", 
                self.inner.id, self.inner.message, self.inner.author)
    }
}

/// Python wrapper for BranchInfo
#[pyclass(name = "BranchInfo")]
#[derive(Clone)]
pub struct PyBranchInfo {
    inner: BranchInfo,
}

#[pymethods]
impl PyBranchInfo {
    #[getter]
    fn name(&self) -> String {
        self.inner.name.clone()
    }
    
    #[getter]
    fn head(&self) -> StateId {
        self.inner.head
    }
    
    #[getter]
    fn is_default(&self) -> bool {
        self.inner.is_default
    }
    
    #[getter]
    fn is_current(&self) -> bool {
        self.inner.is_current
    }
    
    fn __repr__(&self) -> String {
        format!("BranchInfo(name='{}', head={})", 
                self.inner.name, self.inner.head)
    }
}

/// Python wrapper for HistoryStatistics
#[pyclass(name = "HistoryStatistics")]
#[derive(Clone)]
pub struct PyHistoryStatistics {
    inner: HistoryStatistics,
}

#[pymethods]
impl PyHistoryStatistics {
    #[getter]
    fn total_commits(&self) -> usize {
        self.inner.total_commits
    }
    
    #[getter]
    fn total_branches(&self) -> usize {
        self.inner.total_branches
    }
    
    #[getter]
    fn total_tags(&self) -> usize {
        self.inner.total_tags
    }
    
    #[getter]
    fn storage_efficiency(&self) -> f64 {
        self.inner.storage_efficiency
    }
    
    #[getter]
    fn oldest_commit_age(&self) -> u64 {
        self.inner.oldest_commit_age
    }
    
    #[getter]
    fn newest_commit_age(&self) -> u64 {
        self.inner.newest_commit_age
    }
    
    fn __repr__(&self) -> String {
        format!("HistoryStatistics(commits={}, branches={}, efficiency={:.2})", 
                self.inner.total_commits, self.inner.total_branches, self.inner.storage_efficiency)
    }
}

/// Python wrapper for HistoricalView
#[pyclass(name = "HistoricalView")]
pub struct PyHistoricalView {
    // Store the state ID that this view represents
    state_id: StateId,
    // For actual graph operations, we'll need to call back to the graph
    // In a full implementation, this would contain a HistoricalView<'graph>
}

#[pymethods]
impl PyHistoricalView {
    #[getter]
    fn state_id(&self) -> StateId {
        self.state_id
    }
    
    /// Get nodes from this historical state
    /// Note: This is a simplified implementation. In practice, you'd need
    /// access to the graph to reconstruct the state.
    fn get_node_ids(&self) -> PyResult<Vec<NodeId>> {
        // Placeholder - in real implementation, would query graph state
        Ok(Vec::new())
    }
    
    /// Get edges from this historical state
    fn get_edge_ids(&self) -> PyResult<Vec<EdgeId>> {
        // Placeholder - in real implementation, would query graph state
        Ok(Vec::new())
    }
    
    /// Get a node attribute from this historical state
    fn get_node_attribute(&self, _node: NodeId, _attr: AttrName) -> PyResult<Option<PyAttrValue>> {
        // Placeholder - in real implementation, would query historical state
        Ok(None)
    }
    
    /// Get an edge attribute from this historical state
    fn get_edge_attribute(&self, _edge: EdgeId, _attr: AttrName) -> PyResult<Option<PyAttrValue>> {
        // Placeholder - in real implementation, would query historical state
        Ok(None)
    }
    
    /// Check if a node exists in this historical state
    fn has_node(&self, _node: NodeId) -> PyResult<bool> {
        // Placeholder - in real implementation, would query historical state
        Ok(false)
    }
    
    /// Check if an edge exists in this historical state
    fn has_edge(&self, _edge: EdgeId) -> PyResult<bool> {
        // Placeholder - in real implementation, would query historical state
        Ok(false)
    }
    
    /// Get the neighbors of a node in this historical state
    fn get_neighbors(&self, _node: NodeId) -> PyResult<Vec<NodeId>> {
        // Placeholder - in real implementation, would query historical state
        Ok(Vec::new())
    }
    
    fn __repr__(&self) -> String {
        format!("HistoricalView(state_id={})", self.state_id)
    }
}

/// Python wrapper for accessing node attributes as columns
#[pyclass(name = "NodeAttributes", unsendable)]
pub struct PyNodeAttributes {
    graph: *const RustGraph, // Pointer to avoid ownership issues
}

/// Python wrapper for accessing edge attributes as columns
#[pyclass(name = "EdgeAttributes", unsendable)]
pub struct PyEdgeAttributes {
    graph: *const RustGraph, // Pointer to avoid ownership issues
}

/// Unified attributes accessor that provides both node and edge attributes
#[pyclass(name = "Attributes", unsendable)]
pub struct PyAttributes {
    graph: *const RustGraph, // Pointer to avoid ownership issues
}

#[pymethods]
impl PyAttributes {
    /// Access node attributes - g.attributes.nodes["salary"] 
    #[getter]
    fn nodes(&self) -> PyNodeAttributes {
        PyNodeAttributes {
            graph: self.graph,
        }
    }
    
    /// Access edge attributes - g.attributes.edges["weight"]
    #[getter] 
    fn edges(&self) -> PyEdgeAttributes {
        PyEdgeAttributes {
            graph: self.graph,
        }
    }
    
    /// Legacy support: g.attributes["attr_name"] defaults to node attributes
    fn __getitem__(&self, attr_name: &str) -> PyResult<Vec<PyObject>> {
        let node_attrs = PyNodeAttributes { graph: self.graph };
        node_attrs.__getitem__(attr_name)
    }
    
    /// List available attribute names (both nodes and edges)
    fn keys(&self) -> PyResult<PyObject> {
        Python::with_gil(|py| {
            let dict = PyDict::new(py);
            
            let node_attrs = PyNodeAttributes { graph: self.graph };
            let edge_attrs = PyEdgeAttributes { graph: self.graph };
            
            dict.set_item("nodes", node_attrs.keys()?)?;
            dict.set_item("edges", edge_attrs.keys()?)?;
            
            Ok(dict.to_object(py))
        })
    }
    
    fn __repr__(&self) -> String {
        "Attributes(nodes=NodeAttributes(...), edges=EdgeAttributes(...))".to_string()
    }
}

#[pymethods]
impl PyNodeAttributes {
    /// Access attribute column by name - g.attributes["salary"]
    fn __getitem__(&self, attr_name: &str) -> PyResult<Vec<PyObject>> {
        unsafe {
            let graph = &*self.graph;
            let node_ids = graph.node_ids();
            
            Python::with_gil(|py| {
                let mut values = Vec::new();
                
                for node_id in node_ids {
                    match graph.get_node_attr(node_id, &attr_name.to_string()) {
                        Ok(Some(attr_value)) => {
                            let py_value = match attr_value {
                                RustAttrValue::Int(i) => i.to_object(py),
                                RustAttrValue::Float(f) => f.to_object(py),
                                RustAttrValue::Text(s) => s.to_object(py),
                                RustAttrValue::Bool(b) => b.to_object(py),
                                RustAttrValue::FloatVec(v) => v.to_object(py),
                                RustAttrValue::CompactText(s) => s.as_str().to_object(py),
                                RustAttrValue::SmallInt(i) => i.to_object(py),
                                RustAttrValue::Bytes(b) => b.to_object(py),
                                RustAttrValue::CompressedText(_) => "CompressedText".to_object(py), // TODO: decompress
                                RustAttrValue::CompressedFloatVec(_) => "CompressedFloatVec".to_object(py), // TODO: decompress
                            };
                            values.push(py_value);
                        },
                        Ok(None) => {
                            // Node doesn't have this attribute, use None
                            values.push(py.None());
                        },
                        Err(_) => {
                            // Error getting attribute, use None
                            values.push(py.None());
                        }
                    }
                }
                
                Ok(values)
            })
        }
    }
    
    /// List available attribute names
    fn keys(&self) -> PyResult<Vec<String>> {
        unsafe {
            let graph = &*self.graph;
            let node_ids = graph.node_ids();
            let mut attr_names = std::collections::HashSet::new();
            
            // Collect all unique attribute names across all nodes
            for node_id in node_ids {
                if let Ok(attrs) = graph.get_node_attrs(node_id) {
                    for (name, _) in attrs {
                        attr_names.insert(name);
                    }
                }
            }
            
            Ok(attr_names.into_iter().collect())
        }
    }
    
    /// Check if attribute exists
    fn __contains__(&self, attr_name: &str) -> PyResult<bool> {
        Ok(self.keys()?.contains(&attr_name.to_string()))
    }
    
    fn __repr__(&self) -> String {
        format!("NodeAttributes(keys={:?})", self.keys().unwrap_or_default())
    }
}

#[pymethods]
impl PyEdgeAttributes {
    /// Access edge attribute column by name - g.attributes.edges["weight"]
    fn __getitem__(&self, attr_name: &str) -> PyResult<Vec<PyObject>> {
        unsafe {
            let graph = &*self.graph;
            let edge_ids = graph.edge_ids();
            
            Python::with_gil(|py| {
                let mut values = Vec::new();
                
                for edge_id in edge_ids {
                    match graph.get_edge_attr(edge_id, &attr_name.to_string()) {
                        Ok(Some(attr_value)) => {
                            let py_value = match attr_value {
                                RustAttrValue::Int(i) => i.to_object(py),
                                RustAttrValue::Float(f) => f.to_object(py),
                                RustAttrValue::Text(s) => s.to_object(py),
                                RustAttrValue::Bool(b) => b.to_object(py),
                                RustAttrValue::FloatVec(v) => v.to_object(py),
                                RustAttrValue::CompactText(s) => s.as_str().to_object(py),
                                RustAttrValue::SmallInt(i) => i.to_object(py),
                                RustAttrValue::Bytes(b) => b.to_object(py),
                                RustAttrValue::CompressedText(_) => "CompressedText".to_object(py),
                                RustAttrValue::CompressedFloatVec(_) => "CompressedFloatVec".to_object(py),
                            };
                            values.push(py_value);
                        },
                        Ok(None) => {
                            values.push(py.None());
                        },
                        Err(_) => {
                            values.push(py.None());
                        }
                    }
                }
                
                Ok(values)
            })
        }
    }
    
    /// List available edge attribute names
    fn keys(&self) -> PyResult<Vec<String>> {
        unsafe {
            let graph = &*self.graph;
            let edge_ids = graph.edge_ids();
            let mut attr_names = std::collections::HashSet::new();
            
            // Collect all unique attribute names across all edges
            for edge_id in edge_ids {
                if let Ok(attrs) = graph.get_edge_attrs(edge_id) {
                    for (name, _) in attrs {
                        attr_names.insert(name);
                    }
                }
            }
            
            Ok(attr_names.into_iter().collect())
        }
    }
    
    /// Check if edge attribute exists
    fn __contains__(&self, attr_name: &str) -> PyResult<bool> {
        Ok(self.keys()?.contains(&attr_name.to_string()))
    }
    
    fn __repr__(&self) -> String {
        format!("EdgeAttributes(keys={:?})", self.keys().unwrap_or_default())
    }
}

/// Python wrapper for the main Graph
#[pyclass(name = "Graph", unsendable)]
pub struct PyGraph {
    inner: RustGraph,
}

#[pymethods]
impl PyGraph {
    #[new]
    fn new(_config: Option<&PyDict>) -> PyResult<Self> {
        // For now, ignore config and just create a default graph
        // TODO: Convert Python config to GraphConfig when needed
        let rust_graph = RustGraph::new();
        Ok(Self { inner: rust_graph })
    }
    
    // === CORE GRAPH OPERATIONS ===
    
    #[pyo3(signature = (**kwargs))]
    fn add_node(&mut self, kwargs: Option<&PyDict>) -> PyResult<NodeId> {
        let node_id = self.inner.add_node();
        
        // Fast path: if no kwargs, just return the node_id
        if let Some(attrs) = kwargs {
            if !attrs.is_empty() {
                // Only do attribute setting if we actually have attributes
                for (key, value) in attrs.iter() {
                    let attr_name: String = key.extract()?;
                    let attr_value = python_value_to_attr_value(value)?;
                    
                    self.inner.set_node_attr(node_id, attr_name, attr_value)
                        .map_err(graph_error_to_py_err)?;
                }
            }
        }
        
        Ok(node_id)
    }
    
    #[pyo3(signature = (data, uid_key = None))]
    fn add_nodes(&mut self, data: &PyAny, uid_key: Option<String>) -> PyResult<PyObject> {
        // Fast path optimization: Check for integer first (most common case)
        if let Ok(count) = data.extract::<usize>() {
            // Old API: add_nodes(5) -> [0, 1, 2, 3, 4] - fastest path
            let node_ids = self.inner.add_nodes(count);
            return Python::with_gil(|py| Ok(node_ids.to_object(py)));
        }
        
        // Only use Python::with_gil for complex operations
        Python::with_gil(|py| {
            if let Ok(node_data_list) = data.extract::<Vec<&PyDict>>() {
                // New API: add_nodes([{"id": "alice", "age": 30}, ...], id_key="id")
                let mut id_mapping = std::collections::HashMap::new();
                
                // Create all nodes first
                let node_ids = self.inner.add_nodes(node_data_list.len());
                
                // Process each node's data
                for (i, node_dict) in node_data_list.iter().enumerate() {
                    let node_id = node_ids[i];
                    
                    // Extract the ID if id_key is provided
                    if let Some(ref key) = uid_key {
                        match node_dict.get_item(key) {
                            Ok(Some(id_value)) => {
                                if let Ok(user_id) = id_value.extract::<String>() {
                                    id_mapping.insert(user_id, node_id);
                                }
                            }
                            Ok(None) => {
                                return Err(PyErr::new::<PyKeyError, _>(format!("Missing key: {}", key)));
                            }
                            Err(e) => return Err(e),
                        }
                    }
                    
                    // Set all attributes from the dict
                    for (attr_key, attr_value) in node_dict.iter() {
                        let attr_name: String = attr_key.extract()?;
                        
                        // Store all attributes including the id_key for later uid_key lookups
                        // (Previous version skipped id_key, but we need it for uid_key resolution)
                        
                        let attr_val = python_value_to_attr_value(attr_value)?;
                        self.inner.set_node_attr(node_id, attr_name, attr_val)
                            .map_err(graph_error_to_py_err)?;
                    }
                }
                
                // Return the mapping if id_key was provided, otherwise return node IDs
                if uid_key.is_some() {
                    Ok(id_mapping.to_object(py))
                } else {
                    Ok(node_ids.to_object(py))
                }
            } else {
                Err(PyErr::new::<PyTypeError, _>(
                    "add_nodes expects either an integer count or a list of dictionaries"
                ))
            }
        })
    }
    
    /// Helper method to resolve string ID to NodeId using uid_key attribute
    fn resolve_string_id_to_node(&self, string_id: &str, uid_key: &str) -> PyResult<NodeId> {
        let node_ids = self.inner.node_ids();
        
        for node_id in node_ids {
            if let Ok(Some(attr_value)) = self.inner.get_node_attr(node_id, &uid_key.to_string()) {
                match attr_value {
                    RustAttrValue::Text(s) => {
                        if s == string_id {
                            return Ok(node_id);
                        }
                    },
                    RustAttrValue::CompactText(s) => {
                        if s.as_str() == string_id {
                            return Ok(node_id);
                        }
                    },
                    _ => continue, // Skip non-text attributes
                }
            }
        }
        
        Err(PyErr::new::<PyKeyError, _>(format!("No node found with {}='{}'", uid_key, string_id)))
    }
    
    #[pyo3(signature = (source, target, uid_key = None, **kwargs))]
    fn add_edge(&mut self, _py: Python, source: &PyAny, target: &PyAny, uid_key: Option<String>, kwargs: Option<&PyDict>) -> PyResult<EdgeId> {
        // Try to extract as NodeId first (most common case)
        let source_id = if let Ok(node_id) = source.extract::<NodeId>() {
            node_id
        } else if let Some(ref key) = uid_key {
            // String ID with uid_key resolution
            let source_str: String = source.extract()?;
            self.resolve_string_id_to_node(&source_str, key)?
        } else {
            return Err(PyErr::new::<PyTypeError, _>("Source must be NodeId or string with uid_key"));
        };
        
        let target_id = if let Ok(node_id) = target.extract::<NodeId>() {
            node_id
        } else if let Some(ref key) = uid_key {
            // String ID with uid_key resolution  
            let target_str: String = target.extract()?;
            self.resolve_string_id_to_node(&target_str, key)?
        } else {
            return Err(PyErr::new::<PyTypeError, _>("Target must be NodeId or string with uid_key"));
        };
        
        let edge_id = self.inner.add_edge(source_id, target_id)
            .map_err(graph_error_to_py_err)?;
        
        // Fast path: if no kwargs, just return the edge_id
        if let Some(attrs) = kwargs {
            if !attrs.is_empty() {
                // Only do attribute setting if we actually have attributes
                for (key, value) in attrs.iter() {
                    let attr_name: String = key.extract()?;
                    
                    // Skip uid_key if it's in kwargs
                    if let Some(ref uid_k) = uid_key {
                        if attr_name == *uid_k {
                            continue;
                        }
                    }
                    
                    let attr_value = python_value_to_attr_value(value)?;
                    
                    self.inner.set_edge_attr(edge_id, attr_name, attr_value)
                        .map_err(graph_error_to_py_err)?;
                }
            }
        }
        
        Ok(edge_id)
    }
    
    #[pyo3(signature = (edges, node_mapping = None, uid_key = None))]
    fn add_edges(&mut self, edges: &PyAny, node_mapping: Option<std::collections::HashMap<String, NodeId>>, uid_key: Option<String>) -> PyResult<Vec<EdgeId>> {
        // If uid_key is provided but no node_mapping, generate it automatically  
        let resolved_node_mapping = if uid_key.is_some() && node_mapping.is_none() {
            if let Some(ref key) = uid_key {
                Python::with_gil(|py| -> PyResult<std::collections::HashMap<String, NodeId>> {
                    let mapping_obj = self.get_node_mapping(key.clone())?;
                    let mapping_dict: &PyDict = mapping_obj.downcast(py)?;
                    
                    let mut string_mapping = std::collections::HashMap::new();
                    for (k, v) in mapping_dict.iter() {
                        let key_str: String = k.extract()?;
                        let node_id: NodeId = v.extract()?;
                        string_mapping.insert(key_str, node_id);
                    }
                    Ok(string_mapping)
                })?
            } else {
                std::collections::HashMap::new()
            }
        } else {
            node_mapping.unwrap_or_default()
        };
        let final_mapping = if resolved_node_mapping.is_empty() { None } else { Some(resolved_node_mapping) };
        
        // Fast path optimization: Check for simple tuple list first (most common case)
        if let Ok(edge_pairs) = edges.extract::<Vec<(NodeId, NodeId)>>() {
            // Format 1: List of (source, target) tuples - fastest path
            return Ok(self.inner.add_edges(&edge_pairs));
        }
        // Format 2: List of (source, target, attrs_dict) tuples  
        else if let Ok(edge_tuples) = edges.extract::<Vec<(&PyAny, &PyAny, Option<&PyDict>)>>() {
            let mut edge_ids = Vec::new();
            
            for (src_any, tgt_any, attrs_opt) in edge_tuples {
                let source: NodeId = src_any.extract()?;
                let target: NodeId = tgt_any.extract()?;
                
                let edge_id = self.inner.add_edge(source, target)
                    .map_err(graph_error_to_py_err)?;
                
                // Set attributes if provided
                if let Some(attrs) = attrs_opt {
                    for (key, value) in attrs.iter() {
                        let attr_name: String = key.extract()?;
                        let attr_value = python_value_to_attr_value(value)?;
                        
                        self.inner.set_edge_attr(edge_id, attr_name, attr_value)
                            .map_err(graph_error_to_py_err)?;
                    }
                }
                
                edge_ids.push(edge_id);
            }
            
            Ok(edge_ids)
        }
        // Format 3: List of dictionaries with node_mapping 
        else if let Ok(edge_dicts) = edges.extract::<Vec<&PyDict>>() {
            if let Some(mapping) = final_mapping {
                // Use the existing add_edges_from_dicts logic
                let mut edge_ids = Vec::new();
                
                for edge_dict in edge_dicts {
                    // Extract source and target IDs (support both "source"/"target" and flexible keys)
                    let source_val = edge_dict.get_item("source")
                        .or_else(|_| edge_dict.get_item("src"))
                        .or_else(|_| edge_dict.get_item("from"))?;
                    let target_val = edge_dict.get_item("target")
                        .or_else(|_| edge_dict.get_item("tgt"))
                        .or_else(|_| edge_dict.get_item("to"))?;
                    
                    if let (Some(src), Some(tgt)) = (source_val, target_val) {
                        let source_str: String = src.extract()?;
                        let target_str: String = tgt.extract()?;
                        
                        // Resolve to internal node IDs
                        let source_node = mapping.get(&source_str)
                            .ok_or_else(|| PyErr::new::<PyValueError, _>(format!("Unknown source ID: {}", source_str)))?;
                        let target_node = mapping.get(&target_str)
                            .ok_or_else(|| PyErr::new::<PyValueError, _>(format!("Unknown target ID: {}", target_str)))?;
                        
                        // Create the edge
                        let edge_id = self.inner.add_edge(*source_node, *target_node)
                            .map_err(graph_error_to_py_err)?;
                        
                        // Set attributes from dict (excluding source/target keys)
                        for (key, value) in edge_dict.iter() {
                            let attr_name: String = key.extract()?;
                            
                            // Skip source/target keys
                            if attr_name == "source" || attr_name == "target" || 
                               attr_name == "src" || attr_name == "tgt" ||
                               attr_name == "from" || attr_name == "to" {
                                continue;
                            }
                            
                            let attr_value = python_value_to_attr_value(value)?;
                            self.inner.set_edge_attr(edge_id, attr_name, attr_value)
                                .map_err(graph_error_to_py_err)?;
                        }
                        
                        edge_ids.push(edge_id);
                    } else {
                        return Err(PyErr::new::<PyKeyError, _>("Edge dict must have 'source' and 'target' keys"));
                    }
                }
                
                Ok(edge_ids)
            } else {
                Err(PyErr::new::<PyValueError, _>(
                    "Dictionary edges require node_mapping parameter"
                ))
            }
        }
        else {
            Err(PyErr::new::<PyTypeError, _>(
                "add_edges expects a list of (source, target) tuples, (source, target, attrs) tuples, or dictionaries with node_mapping"
            ))
        }
    }
    
    fn remove_node(&mut self, node: NodeId) -> PyResult<()> {
        self.inner.remove_node(node)
            .map_err(graph_error_to_py_err)
    }
    
    fn remove_edge(&mut self, edge: EdgeId) -> PyResult<()> {
        self.inner.remove_edge(edge)
            .map_err(graph_error_to_py_err)
    }
    
    fn remove_nodes(&mut self, nodes: Vec<NodeId>) -> PyResult<()> {
        self.inner.remove_nodes(&nodes)
            .map_err(graph_error_to_py_err)
    }
    
    fn remove_edges(&mut self, edges: Vec<EdgeId>) -> PyResult<()> {
        self.inner.remove_edges(&edges)
            .map_err(graph_error_to_py_err)
    }
    
    // === ATTRIBUTE OPERATIONS ===
    
    fn set_node_attribute(&mut self, node: NodeId, attr: AttrName, value: &PyAttrValue) -> PyResult<()> {
        self.inner.set_node_attr(node, attr, value.inner.clone())
            .map_err(graph_error_to_py_err)
    }
    
    fn set_edge_attribute(&mut self, edge: EdgeId, attr: AttrName, value: &PyAttrValue) -> PyResult<()> {
        self.inner.set_edge_attr(edge, attr, value.inner.clone())
            .map_err(graph_error_to_py_err)
    }
    
    fn get_node_attribute(&self, node: NodeId, attr: AttrName) -> PyResult<Option<PyAttrValue>> {
        match self.inner.get_node_attr(node, &attr) {
            Ok(Some(value)) => Ok(Some(PyAttrValue { inner: value })),
            Ok(None) => Ok(None),
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    fn get_edge_attribute(&self, edge: EdgeId, attr: AttrName) -> PyResult<Option<PyAttrValue>> {
        match self.inner.get_edge_attr(edge, &attr) {
            Ok(Some(value)) => Ok(Some(PyAttrValue { inner: value })),
            Ok(None) => Ok(None),
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    // === BULK COLUMN ACCESS (GraphTable Optimization) ===
    
    /// Get complete attribute column for ALL nodes (optimized for table() method)
    /// 
    /// INTERNAL: This is the key optimization for GraphTable - instead of O(n*m) individual calls,
    /// we make O(m) calls to get complete columns.
    fn _get_node_attribute_column(&self, py: Python, attr_name: &str) -> PyResult<Py<PyGraphArray>> {
        match self.inner._get_node_attribute_column(&attr_name.to_string()) {
            Ok(values) => {
                // Convert Option<AttrValue> vector to AttrValue vector (convert None to appropriate AttrValue)
                let attr_values: Vec<groggy::AttrValue> = values.into_iter()
                    .map(|opt_val| opt_val.unwrap_or(groggy::AttrValue::Int(0))) // Use default for None values
                    .collect();
                
                // Create GraphArray from the attribute values
                let graph_array = groggy::GraphArray::from_vec(attr_values);
                
                // Wrap in Python GraphArray
                let py_graph_array = PyGraphArray { inner: graph_array };
                Ok(Py::new(py, py_graph_array)?)
            }
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Get complete attribute column for ALL edges (optimized for edge table() method)
    fn _get_edge_attribute_column(&self, py: Python, attr_name: &str) -> PyResult<Vec<PyObject>> {
        match self.inner._get_edge_attribute_column(&attr_name.to_string()) {
            Ok(values) => {
                let mut py_values = Vec::with_capacity(values.len());
                for value in values {
                    match value {
                        Some(attr_value) => py_values.push(attr_value_to_python_value(py, &attr_value)?),
                        None => py_values.push(py.None()),
                    }
                }
                Ok(py_values)
            }
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Get attribute column for specific nodes (optimized for subgraph tables)
    fn _get_node_attributes_for_nodes(&self, py: Python, node_ids: Vec<NodeId>, attr_name: &str) -> PyResult<Vec<PyObject>> {
        match self.inner._get_node_attributes_for_nodes(&node_ids, &attr_name.to_string()) {
            Ok(values) => {
                let mut py_values = Vec::with_capacity(values.len());
                for value in values {
                    match value {
                        Some(attr_value) => py_values.push(attr_value_to_python_value(py, &attr_value)?),
                        None => py_values.push(py.None()),
                    }
                }
                Ok(py_values)
            }
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Get attribute column for specific edges (optimized for subgraph edge tables)
    fn _get_edge_attributes_for_edges(&self, py: Python, edge_ids: Vec<EdgeId>, attr_name: &str) -> PyResult<Vec<PyObject>> {
        match self.inner._get_edge_attributes_for_edges(&edge_ids, &attr_name.to_string()) {
            Ok(values) => {
                let mut py_values = Vec::with_capacity(values.len());
                for value in values {
                    match value {
                        Some(attr_value) => py_values.push(attr_value_to_python_value(py, &attr_value)?),
                        None => py_values.push(py.None()),
                    }
                }
                Ok(py_values)
            }
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    // === OPTIMIZED BULK OPERATIONS (Phase 1 - Zero PyAttrValue) ===
    
    fn set_node_attributes(&mut self, _py: Python, attrs_dict: &PyDict) -> PyResult<()> {
        // HYPER-OPTIMIZED bulk API - minimize PyO3 overhead and allocations
        let mut attrs_values = std::collections::HashMap::with_capacity(attrs_dict.len());
        
        for (attr_name, attr_data) in attrs_dict {
            let attr: AttrName = attr_name.extract()?;
            let data_dict: &PyDict = attr_data.downcast()?;
            
            // OPTIMIZATION: Extract all fields at once to reduce PyO3 calls
            let (nodes, values_obj, value_type): (Vec<NodeId>, &pyo3::PyAny, String) = {
                let nodes_item = data_dict.get_item("nodes")?.ok_or_else(|| 
                    PyErr::new::<PyKeyError, _>("Missing 'nodes' key"))?;
                let values_item = data_dict.get_item("values")?.ok_or_else(|| 
                    PyErr::new::<PyKeyError, _>("Missing 'values' key"))?;
                let type_item = data_dict.get_item("value_type")?.ok_or_else(|| 
                    PyErr::new::<PyKeyError, _>("Missing 'value_type' key"))?;
                    
                (nodes_item.extract()?, values_item, type_item.extract()?)
            };
            
            let len = nodes.len();
            
            // OPTIMIZATION: Pre-allocate result vector and use direct indexing
            let mut pairs = Vec::with_capacity(len);
            
            // OPTIMIZATION: Match on str slice to avoid repeated string comparisons
            match value_type.as_str() {
                "text" => {
                    let values: Vec<String> = values_obj.extract()?;
                    if values.len() != len {
                        return Err(PyErr::new::<PyValueError, _>("Length mismatch"));
                    }
                    
                    // OPTIMIZATION: Direct loop instead of iterator chain
                    for i in 0..len {
                        pairs.push((nodes[i], RustAttrValue::Text(values[i].clone())));
                    }
                },
                "int" => {
                    let values: Vec<i64> = values_obj.extract()?;
                    if values.len() != len {
                        return Err(PyErr::new::<PyValueError, _>("Length mismatch"));
                    }
                    
                    for i in 0..len {
                        pairs.push((nodes[i], RustAttrValue::Int(values[i])));
                    }
                },
                "float" => {
                    let values: Vec<f64> = values_obj.extract()?;
                    if values.len() != len {
                        return Err(PyErr::new::<PyValueError, _>("Length mismatch"));
                    }
                    
                    for i in 0..len {
                        pairs.push((nodes[i], RustAttrValue::Float(values[i] as f32)));
                    }
                },
                "bool" => {
                    let values: Vec<bool> = values_obj.extract()?;
                    if values.len() != len {
                        return Err(PyErr::new::<PyValueError, _>("Length mismatch"));
                    }
                    
                    for i in 0..len {
                        pairs.push((nodes[i], RustAttrValue::Bool(values[i])));
                    }
                },
                _ => return Err(PyErr::new::<PyValueError, _>("Unsupported type"))
            };
            
            attrs_values.insert(attr, pairs);
        }
        
        self.inner.set_node_attrs(attrs_values)
            .map_err(graph_error_to_py_err)
    }
    

    fn set_edge_attributes(&mut self, _py: Python, attrs_dict: &PyDict) -> PyResult<()> {
        // New efficient columnar API for edges - zero PyAttrValue objects created!
        let mut attrs_values = std::collections::HashMap::new();
        
        for (attr_name, attr_data) in attrs_dict {
            let attr: AttrName = attr_name.extract()?;
            let data_dict: &PyDict = attr_data.downcast()?;
            
            // Extract components in bulk using the same pattern as node attributes
            let edges: Vec<EdgeId> = if let Ok(Some(item)) = data_dict.get_item("edges") {
                item.extract()?
            } else {
                return Err(PyErr::new::<PyKeyError, _>("Missing 'edges' key in attribute data"));
            };
            let value_type: String = if let Ok(Some(item)) = data_dict.get_item("value_type") {
                item.extract()?
            } else {
                return Err(PyErr::new::<PyKeyError, _>("Missing 'value_type' key in attribute data"));
            };
            
            // Batch convert based on known type - no individual type detection!
            let pairs = match value_type.as_str() {
                "text" => {
                    let values: Vec<String> = if let Ok(Some(item)) = data_dict.get_item("values") {
                        item.extract()?
                    } else {
                        return Err(PyErr::new::<PyKeyError, _>("Missing 'values' key in attribute data"));
                    };
                    
                    if values.len() != edges.len() {
                        return Err(PyErr::new::<PyValueError, _>(
                            format!("Mismatched lengths: {} edges vs {} values", edges.len(), values.len())
                        ));
                    }
                    
                    edges.into_iter()
                        .zip(values.into_iter())
                        .map(|(edge, val)| (edge, RustAttrValue::Text(val)))
                        .collect()
                },
                "int" => {
                    let values: Vec<i64> = if let Ok(Some(item)) = data_dict.get_item("values") {
                        item.extract()?
                    } else {
                        return Err(PyErr::new::<PyKeyError, _>("Missing 'values' key in attribute data"));
                    };
                    
                    if values.len() != edges.len() {
                        return Err(PyErr::new::<PyValueError, _>(
                            format!("Mismatched lengths: {} edges vs {} values", edges.len(), values.len())
                        ));
                    }
                    
                    edges.into_iter()
                        .zip(values.into_iter())
                        .map(|(edge, val)| (edge, RustAttrValue::Int(val)))
                        .collect()
                },
                "float" => {
                    let values: Vec<f64> = if let Ok(Some(item)) = data_dict.get_item("values") {
                        item.extract()?
                    } else {
                        return Err(PyErr::new::<PyKeyError, _>("Missing 'values' key in attribute data"));
                    };
                    
                    if values.len() != edges.len() {
                        return Err(PyErr::new::<PyValueError, _>(
                            format!("Mismatched lengths: {} edges vs {} values", edges.len(), values.len())
                        ));
                    }
                    
                    edges.into_iter()
                        .zip(values.into_iter())
                        .map(|(edge, val)| (edge, RustAttrValue::Float(val as f32)))
                        .collect()
                },
                "bool" => {
                    let values: Vec<bool> = if let Ok(Some(item)) = data_dict.get_item("values") {
                        item.extract()?
                    } else {
                        return Err(PyErr::new::<PyKeyError, _>("Missing 'values' key in attribute data"));
                    };
                    
                    if values.len() != edges.len() {
                        return Err(PyErr::new::<PyValueError, _>(
                            format!("Mismatched lengths: {} edges vs {} values", edges.len(), values.len())
                        ));
                    }
                    
                    edges.into_iter()
                        .zip(values.into_iter())
                        .map(|(edge, val)| (edge, RustAttrValue::Bool(val)))
                        .collect()
                },
                _ => return Err(PyErr::new::<PyValueError, _>(
                    format!("Unsupported value_type: '{}'. Supported: text, int, float, bool", value_type)
                ))
            };
            
            attrs_values.insert(attr, pairs);
        }
        
        self.inner.set_edge_attrs(attrs_values)
            .map_err(graph_error_to_py_err)
    }
    
    
    fn get_edges_attributes(&self, attr: AttrName, edges: Vec<EdgeId>) -> PyResult<Vec<Option<PyAttrValue>>> {
        let result = self.inner.get_edges_attrs(&attr, &edges)
            .map_err(graph_error_to_py_err)?;
        
        Ok(result.into_iter()
            .map(|opt| opt.map(|val| PyAttrValue { inner: val }))
            .collect())
    }
    
    
    fn get_edge_attributes(&self, edge: EdgeId, py: Python) -> PyResult<PyObject> {
        let attrs = self.inner.get_edge_attrs(edge)
            .map_err(graph_error_to_py_err)?;
        
        // Convert HashMap to Python dict
        let dict = PyDict::new(py);
        for (attr_name, attr_value) in attrs {
            let py_value = Py::new(py, PyAttrValue { inner: attr_value })?;
            dict.set_item(attr_name, py_value)?;
        }
        Ok(dict.to_object(py))
    }
    
    // === TOPOLOGY OPERATIONS ===
    
    fn contains_node(&self, node: NodeId) -> bool {
        self.inner.contains_node(node) 
    }
    
    fn contains_edge(&self, edge: EdgeId) -> bool {
        self.inner.contains_edge(edge)
    }
    
    
    fn edge_endpoints(&self, edge: EdgeId) -> PyResult<(NodeId, NodeId)> {
        self.inner.edge_endpoints(edge)
            .map_err(graph_error_to_py_err)
    }
    
    fn neighbors(&self, node: NodeId) -> PyResult<Vec<NodeId>> {
        self.inner.neighbors(node)
            .map_err(graph_error_to_py_err)
    }
    
    fn degree(&self, node: NodeId) -> PyResult<usize> {
        self.inner.degree(node)
            .map_err(graph_error_to_py_err)
    }
    
    // === STATISTICS ===
    
    fn memory_statistics(&self, py: Python) -> PyResult<PyObject> {
        let stats = self.inner.memory_statistics();
        
        // Convert MemoryStatistics to Python dict
        let dict = PyDict::new(py);
        dict.set_item("pool_memory_bytes", stats.pool_memory_bytes)?;
        dict.set_item("space_memory_bytes", stats.space_memory_bytes)?;
        dict.set_item("history_memory_bytes", stats.history_memory_bytes)?;
        dict.set_item("change_tracker_memory_bytes", stats.change_tracker_memory_bytes)?;
        dict.set_item("total_memory_bytes", stats.total_memory_bytes)?;
        dict.set_item("total_memory_mb", stats.total_memory_mb)?;
        
        // Add memory efficiency stats
        let efficiency_dict = PyDict::new(py);
        efficiency_dict.set_item("bytes_per_node", stats.memory_efficiency.bytes_per_node)?;
        efficiency_dict.set_item("bytes_per_edge", stats.memory_efficiency.bytes_per_edge)?;
        efficiency_dict.set_item("bytes_per_entity", stats.memory_efficiency.bytes_per_entity)?;
        efficiency_dict.set_item("overhead_ratio", stats.memory_efficiency.overhead_ratio)?;
        efficiency_dict.set_item("cache_efficiency", stats.memory_efficiency.cache_efficiency)?;
        dict.set_item("memory_efficiency", efficiency_dict)?;
        
        // Add compression statistics
        let compression_dict = PyDict::new(py);
        compression_dict.set_item("compressed_attributes", stats.compression_stats.compressed_attributes)?;
        compression_dict.set_item("total_attributes", stats.compression_stats.total_attributes)?;
        compression_dict.set_item("average_compression_ratio", stats.compression_stats.average_compression_ratio)?;
        compression_dict.set_item("memory_saved_bytes", stats.compression_stats.memory_saved_bytes)?;
        compression_dict.set_item("memory_saved_percentage", stats.compression_stats.memory_saved_percentage)?;
        dict.set_item("compression_stats", compression_dict)?;
        
        Ok(dict.to_object(py))
    }
    
    fn statistics(&self, py: Python) -> PyResult<PyObject> {
        let stats = self.inner.statistics();
        
        // Convert basic statistics to Python dict  
        let dict = PyDict::new(py);
        dict.set_item("node_count", stats.node_count)?;
        dict.set_item("edge_count", stats.edge_count)?;
        dict.set_item("attribute_count", stats.attribute_count)?;
        
        Ok(dict.to_object(py))
    }
    
    fn __repr__(&self) -> String {
        let node_count = self.inner.node_ids().len();
        let edge_count = self.inner.edge_ids().len();
        format!("Graph(nodes={}, edges={})", node_count, edge_count)
    }
    
    /// Python len() support - returns number of nodes
    fn __len__(&self) -> usize {
        self.inner.node_ids().len()
    }
    
    /// Check if a node exists in the graph
    fn has_node(&self, node_id: NodeId) -> bool {
        self.inner.contains_node(node_id)
    }
    
    /// Check if an edge exists in the graph
    fn has_edge(&self, edge_id: EdgeId) -> bool {
        self.inner.contains_edge(edge_id)
    }
    
    /// Get the number of nodes in the graph
    fn node_count(&self) -> usize {
        self.inner.node_ids().len()
    }
    
    /// Get the number of edges in the graph
    fn edge_count(&self) -> usize {
        self.inner.edge_ids().len()
    }
    
    /// Get all active node IDs as GraphArray (lazy Rust view) - use .values for Python list
    #[getter]
    fn node_ids(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let node_ids = self.inner.node_ids();
        let attr_values: Vec<groggy::AttrValue> = node_ids.into_iter()
            .map(|id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }
    
    /// Get all active edge IDs as GraphArray (lazy Rust view) - use .values for Python list
    #[getter]
    fn edge_ids(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let edge_ids = self.inner.edge_ids();
        let attr_values: Vec<groggy::AttrValue> = edge_ids.into_iter()
            .map(|id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }
    
    /// Get nodes accessor for fluent API (g.nodes property) 
    #[getter]
    fn nodes(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyNodesAccessor>> {
        let graph_ref = self_.into();
        PyGraph::create_nodes_accessor_internal(graph_ref, py)
    }
    
    /// Get edges accessor for fluent API (g.edges property)
    #[getter]
    fn edges(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyEdgesAccessor>> {
        let graph_ref = self_.into();
        PyGraph::create_edges_accessor_internal(graph_ref, py)
    }
    
    /// Get unified attributes accessor for both nodes and edges (g.attributes property)
    #[getter]
    fn attributes(&self) -> PyAttributes {
        PyAttributes {
            graph: &self.inner as *const RustGraph,
        }
    }
    
    // === PHASE 3 QUERYING METHODS ===
    
    /// Phase 3.1: Advanced filtering - accepts NodeFilter or string query
    fn filter_nodes(mut self_: PyRefMut<Self>, py: Python, filter: &PyAny) -> PyResult<PySubgraph> {
        // Fast path optimization: Check for NodeFilter object first (most common case)
        let node_filter = if let Ok(filter_obj) = filter.extract::<PyNodeFilter>() {
            // Direct NodeFilter object - fastest path
            filter_obj.inner.clone()
        } else if let Ok(query_str) = filter.extract::<String>() {
            // String query - parse it using our query parser
            let query_parser = py.import("groggy.query_parser")?;
            let parse_func = query_parser.getattr("parse_node_query")?;
            let parsed_filter: PyNodeFilter = parse_func.call1((query_str,))?.extract()?;
            parsed_filter.inner.clone()
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "filter must be a NodeFilter object or a string query (e.g., 'salary > 120000')"
            ));
        };
        
        let filtered_nodes = self_.inner.find_nodes(node_filter)
            .map_err(graph_error_to_py_err)?;
        
        // O(k) Calculate induced edges using optimized core subgraph method
        use std::collections::HashSet;
        let node_set: HashSet<NodeId> = filtered_nodes.iter().copied().collect();
        
        // Get columnar topology vectors (edge_ids, sources, targets) - O(1) if cached
        let (edge_ids, sources, targets) = self_.inner.get_columnar_topology();
        let mut induced_edges = Vec::new();
        
        // Iterate through parallel vectors - O(k) where k = active edges
        for i in 0..edge_ids.len() {
            let edge_id = edge_ids[i];
            let source = sources[i];
            let target = targets[i];
            
            // O(1) HashSet lookups instead of O(n) Vec::contains
            if node_set.contains(&source) && node_set.contains(&target) {
                induced_edges.push(edge_id);
            }
        }
        
        // Get a reference to this graph to pass to the subgraph
        let graph_ref = self_.into();
        
        Ok(PySubgraph::new(
            filtered_nodes,
            induced_edges,
            "filtered_nodes".to_string(),
            Some(graph_ref),
        ))
    }
    
    /// Filter nodes within an existing subgraph (enables chaining)
    fn filter_subgraph_nodes(&mut self, py: Python, subgraph: &PySubgraph, filter: &PyAny) -> PyResult<PySubgraph> {
        // Parse the filter like in filter_nodes
        let node_filter = if let Ok(filter_obj) = filter.extract::<PyNodeFilter>() {
            filter_obj.inner.clone()
        } else if let Ok(query_str) = filter.extract::<String>() {
            let query_parser = py.import("groggy.query_parser")?;
            let parse_func = query_parser.getattr("parse_node_query")?;
            let parsed_filter: PyNodeFilter = parse_func.call1((query_str,))?.extract()?;
            parsed_filter.inner.clone()
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "filter must be a NodeFilter object or a string query"
            ));
        };
        
        // Filter only the nodes in the current subgraph
        // Use the existing find_nodes and then intersect with subgraph nodes
        let all_matching_nodes = self.inner.find_nodes(node_filter)
            .map_err(graph_error_to_py_err)?;
        
        let mut filtered_nodes = Vec::new();
        for &node_id in &subgraph.nodes {
            if all_matching_nodes.contains(&node_id) {
                filtered_nodes.push(node_id);
            }
        }
        
        // Calculate induced edges among the filtered nodes
        let mut induced_edges = Vec::new();
        for &edge_id in &subgraph.edges {
            if let Ok((source, target)) = self.inner.edge_endpoints(edge_id) {
                if filtered_nodes.contains(&source) && filtered_nodes.contains(&target) {
                    induced_edges.push(edge_id);
                }
            }
        }
        
        Ok(PySubgraph::new(
            filtered_nodes,
            induced_edges,
            format!("{}_filtered", subgraph.subgraph_type),
            subgraph.graph.clone(),
        ))
    }
    
    /// Advanced edge filtering - accepts EdgeFilter or string query
    fn filter_edges(mut self_: PyRefMut<Self>, py: Python, filter: &PyAny) -> PyResult<PySubgraph> {
        // Fast path optimization: Check for EdgeFilter object first (most common case)
        let edge_filter = if let Ok(filter_obj) = filter.extract::<PyEdgeFilter>() {
            // Direct EdgeFilter object - fastest path
            filter_obj.inner.clone()
        } else if let Ok(query_str) = filter.extract::<String>() {
            // String query - parse it using our query parser
            let query_parser = py.import("groggy.query_parser")?;
            let parse_func = query_parser.getattr("parse_edge_query")?;
            let parsed_filter: PyEdgeFilter = parse_func.call1((query_str,))?.extract()?;
            parsed_filter.inner.clone()
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "filter must be an EdgeFilter object or a string query (e.g., 'weight > 0.5')"
            ));
        };
        
        let filtered_edges = self_.inner.find_edges(edge_filter)
            .map_err(graph_error_to_py_err)?;
        
        // Collect all endpoints of the filtered edges to create the node set
        // 🚀 PERFORMANCE FIX: Use HashSet for O(1) contains/insert instead of O(n) Vec operations
        let mut endpoint_nodes_set = std::collections::HashSet::new();
        for &edge_id in &filtered_edges {
            if let Ok((source, target)) = self_.inner.edge_endpoints(edge_id) {
                endpoint_nodes_set.insert(source);  // O(1) hash insert
                endpoint_nodes_set.insert(target);  // O(1) hash insert
            }
        }
        
        // Convert to Vec for compatibility
        let endpoint_nodes: Vec<NodeId> = endpoint_nodes_set.into_iter().collect();
        
        // Get a reference to this graph to pass to the subgraph
        let graph_ref = self_.into();
        
        Ok(PySubgraph::new(
            endpoint_nodes,
            filtered_edges,
            "filtered_edges".to_string(),
            Some(graph_ref),
        ))
    }
    
    /// Phase 3.2: Graph traversal algorithms
    
    
    
    /// Cleaner alias for traverse_bfs - shorter and more intuitive
    #[pyo3(signature = (start_node, max_depth = None, node_filter = None, edge_filter = None, inplace = false, attr_name = None))]
    fn bfs(&mut self, _py: Python, start_node: NodeId, max_depth: Option<usize>, 
           node_filter: Option<&PyNodeFilter>, edge_filter: Option<&PyEdgeFilter>,
           inplace: Option<bool>, attr_name: Option<String>) -> PyResult<PySubgraph> {
        let inplace = inplace.unwrap_or(false);
        
        // Create traversal options
        let mut options = groggy::core::traversal::TraversalOptions::default();
        if let Some(depth) = max_depth {
            options.max_depth = Some(depth);
        }
        if let Some(filter) = node_filter {
            options.node_filter = Some(filter.inner.clone());
        }
        if let Some(filter) = edge_filter {
            options.edge_filter = Some(filter.inner.clone());
        }
        
        // Perform BFS traversal
        let result = self.inner.bfs(start_node, options)
            .map_err(graph_error_to_py_err)?;
        
        // If inplace=True, set distance/order attributes on nodes
        if inplace {
            let attr_name = attr_name.unwrap_or_else(|| "bfs_distance".to_string());
            
            // Set distance attributes (distance from start_node)
            // For now, we'll set a simple order attribute
            for (order, &node_id) in result.nodes.iter().enumerate() {
                let order_value = PyAttrValue { inner: groggy::AttrValue::Int(order as i64) };
                self.set_node_attribute(node_id, attr_name.clone(), &order_value)?;
            }
        }
        
        Ok(PySubgraph::new(
            result.nodes,
            result.edges,
            "bfs_traversal".to_string(),
            None,
        ))
    }
    
    /// Cleaner alias for traverse_dfs - shorter and more intuitive  
    #[pyo3(signature = (start_node, max_depth = None, node_filter = None, edge_filter = None, inplace = false, node_attr = None, edge_attr = None))]
    fn dfs(&mut self, _py: Python, start_node: NodeId, max_depth: Option<usize>,
           node_filter: Option<&PyNodeFilter>, edge_filter: Option<&PyEdgeFilter>,
           inplace: Option<bool>, node_attr: Option<String>, edge_attr: Option<String>) -> PyResult<PySubgraph> {
        let inplace = inplace.unwrap_or(false);
        
        // Create traversal options
        let mut options = groggy::core::traversal::TraversalOptions::default();
        if let Some(depth) = max_depth {
            options.max_depth = Some(depth);
        }
        if let Some(filter) = node_filter {
            options.node_filter = Some(filter.inner.clone());
        }
        if let Some(filter) = edge_filter {
            options.edge_filter = Some(filter.inner.clone());
        }
        
        // Perform DFS traversal
        let result = self.inner.dfs(start_node, options)
            .map_err(graph_error_to_py_err)?;
        
        // If inplace=True, set attributes on nodes and edges
        if inplace {
            // Set node attributes (DFS order/distance)
            if let Some(node_attr_name) = node_attr {
                for (order, &node_id) in result.nodes.iter().enumerate() {
                    let order_value = PyAttrValue { inner: groggy::AttrValue::Int(order as i64) };
                    self.set_node_attribute(node_id, node_attr_name.clone(), &order_value)?;
                }
            } else {
                // Default node attribute
                let default_attr = "dfs_order".to_string();
                for (order, &node_id) in result.nodes.iter().enumerate() {
                    let order_value = PyAttrValue { inner: groggy::AttrValue::Int(order as i64) };
                    self.set_node_attribute(node_id, default_attr.clone(), &order_value)?;
                }
            }
            
            // Set edge attributes (tree edge or back edge)
            if let Some(edge_attr_name) = edge_attr {
                for &edge_id in &result.edges {
                    // For now, mark all edges in result as tree edges
                    let tree_edge_value = PyAttrValue { inner: groggy::AttrValue::Bool(true) };
                    self.set_edge_attribute(edge_id, edge_attr_name.clone(), &tree_edge_value)?;
                }
            }
        }
        
        Ok(PySubgraph::new(
            result.nodes,
            result.edges,
            "dfs_traversal".to_string(),
            None,
        ))
    }
    
    /// Find shortest path between two nodes with optional in-place attribute setting
    #[pyo3(signature = (source, target, weight_attribute = None, inplace = false, attr_name = None))]
    fn shortest_path(&mut self, source: NodeId, target: NodeId, weight_attribute: Option<AttrName>, 
                    inplace: Option<bool>, attr_name: Option<String>) -> PyResult<Option<PySubgraph>> {
        let inplace = inplace.unwrap_or(false);
        
        let options = groggy::core::traversal::PathFindingOptions {
            weight_attribute,
            max_path_length: None,
            heuristic: None,
        };
        
        let result = self.inner.shortest_path(source, target, options)
            .map_err(graph_error_to_py_err)?;
            
        match result {
            Some(path) => {
                if inplace {
                    if let Some(attr_name) = attr_name {
                        // Set path distance attribute on nodes
                        for (distance, &node_id) in path.nodes.iter().enumerate() {
                            let attr_value = groggy::AttrValue::Int(distance as i64);
                            self.inner.set_node_attr(node_id, attr_name.clone(), attr_value)
                                .map_err(graph_error_to_py_err)?;
                        }
                    }
                }
                
                Ok(Some(PySubgraph::new(
                    path.nodes,
                    path.edges,
                    "shortest_path".to_string(),
                    None,
                )))
            },
            None => Ok(None),
        }
    }
    
    /// Find connected components with optional in-place attribute setting
    #[pyo3(signature = (inplace = false, attr_name = None))]
    fn connected_components(mut self_: PyRefMut<Self>, py: Python, inplace: Option<bool>, attr_name: Option<String>) -> PyResult<Vec<PySubgraph>> {
        let inplace = inplace.unwrap_or(false);
        
        let options = groggy::core::traversal::TraversalOptions::default();
        let result = self_.inner.connected_components(options)
            .map_err(graph_error_to_py_err)?;
        
        // Convert each component to a PySubgraph  
        let mut subgraphs = Vec::new();
        
        // Get columnar topology once for efficient edge processing (same pattern as filter_nodes)
        let (edge_ids, sources, targets) = self_.inner.get_columnar_topology();
        
        // Process components and collect results first (avoid borrow conflicts)
        let mut components_with_edges = Vec::new();
        for (i, component) in result.components.into_iter().enumerate() {
            // Calculate induced edges using optimized columnar topology method (same as filter_nodes)
            use std::collections::HashSet;
            let component_nodes: HashSet<NodeId> = component.nodes.iter().copied().collect();
            let mut induced_edges = Vec::new();
            
            // Iterate through parallel vectors - O(k) where k = active edges
            for j in 0..edge_ids.len() {
                let edge_id = edge_ids[j];
                let source = sources[j];
                let target = targets[j];
                
                // O(1) HashSet lookups instead of O(n) Vec::contains
                if component_nodes.contains(&source) && component_nodes.contains(&target) {
                    induced_edges.push(edge_id);
                }
            }
            
            // Store component data for later processing
            components_with_edges.push((component.nodes.clone(), induced_edges, i));
        }
        
        // Now create subgraphs and handle inplace attributes without borrow conflicts
        for (nodes, induced_edges, i) in components_with_edges {
            // Create subgraph with proper induced edges
            let subgraph = PySubgraph::new(
                nodes.clone(),
                induced_edges, // Include all edges within this component
                format!("connected_component_{}", i),
                None, // Temporarily None - will be set below
            );
            subgraphs.push(subgraph);
            
            // If inplace=True, set component_id attribute on nodes
            if inplace {
                let attr_name = attr_name.clone().unwrap_or_else(|| "component_id".to_string());
                let component_value = PyAttrValue { inner: groggy::AttrValue::Int(i as i64) };
                
                for &node_id in &nodes {
                    self_.set_node_attribute(node_id, attr_name.clone(), &component_value)?;
                }
            }
        }
        
        // Now set the graph reference for all subgraphs
        let graph_ref: Py<PyGraph> = self_.into();
        for subgraph in &mut subgraphs {
            subgraph.graph = Some(graph_ref.clone());
        }
        
        Ok(subgraphs)
    }
    
    /// Phase 3.4: Query result aggregation and analytics - UNIFIED AGGREGATE METHOD
    #[pyo3(signature = (attribute, operation, target = None, node_ids = None))]
    fn aggregate(&self, attribute: AttrName, operation: String, target: Option<String>, node_ids: Option<Vec<NodeId>>, py: Python) -> PyResult<PyObject> {
        let target = target.unwrap_or_else(|| "nodes".to_string());
        
        match target.as_str() {
            "nodes" => {
                if let Some(node_list) = node_ids {
                    // Custom node list aggregation (replaces aggregate_nodes)
                    self.aggregate_custom_nodes(node_list, attribute, py)
                } else {
                    // All nodes aggregation (replaces aggregate_node_attribute)
                    let result = self.inner.aggregate_node_attribute(&attribute, &operation)
                        .map_err(graph_error_to_py_err)?;
                    let py_result = PyAggregationResult { value: result.value };
                    Ok(Py::new(py, py_result)?.to_object(py))
                }
            },
            "edges" => {
                // Edge aggregation (replaces aggregate_edge_attribute)
                let result = self.inner.aggregate_edge_attribute(&attribute, &operation)
                    .map_err(graph_error_to_py_err)?;
                let py_result = PyAggregationResult { value: result.value };
                Ok(Py::new(py, py_result)?.to_object(py))
            },
            _ => {
                Err(PyValueError::new_err(format!("Invalid target '{}'. Use 'nodes' or 'edges'", target)))
            }
        }
    }
    
    // Helper method for custom node list aggregation (extracted from aggregate_nodes)
    fn aggregate_custom_nodes(&self, node_ids: Vec<NodeId>, attribute: AttrName, py: Python) -> PyResult<PyObject> {
        // Use bulk attribute retrieval for much better performance (10-100x faster than individual lookups)
        let bulk_attributes = self.inner._get_node_attributes_for_nodes(&node_ids, &attribute)
            .map_err(graph_error_to_py_err)?;
        let mut values = Vec::new();
        
        // Extract values from bulk result
        for attr_value in bulk_attributes {
            if let Some(value) = attr_value {
                values.push(value);
            }
        }
        
        // Compute all statistics in one pass in Rust
        {
            let dict = PyDict::new(py);
            
            dict.set_item("count", values.len())?;
            
            if !values.is_empty() {
                match &values[0] {
                    RustAttrValue::Int(_) => {
                        let int_values: Vec<i64> = values.iter()
                            .filter_map(|v| if let RustAttrValue::Int(i) = v { Some(*i) } else { None })
                            .collect();
                        
                        if !int_values.is_empty() {
                            let sum: i64 = int_values.iter().sum();
                            let avg = sum as f64 / int_values.len() as f64;
                            let min = *int_values.iter().min().unwrap();
                            let max = *int_values.iter().max().unwrap();
                            
                            // Compute variance/stddev
                            let variance = int_values.iter()
                                .map(|&x| (x as f64 - avg).powi(2))
                                .sum::<f64>() / int_values.len() as f64;
                            let stddev = variance.sqrt();
                            
                            dict.set_item("sum", sum)?;
                            dict.set_item("average", avg)?;
                            dict.set_item("min", min)?;
                            dict.set_item("max", max)?;
                            dict.set_item("variance", variance)?;
                            dict.set_item("stddev", stddev)?;
                        }
                    },
                    RustAttrValue::Float(_) => {
                        let float_values: Vec<f32> = values.iter()
                            .filter_map(|v| if let RustAttrValue::Float(f) = v { Some(*f) } else { None })
                            .collect();
                        
                        if !float_values.is_empty() {
                            let sum: f64 = float_values.iter().map(|&x| x as f64).sum();
                            let avg = sum / float_values.len() as f64;
                            let min = float_values.iter().fold(f32::INFINITY, |a, &b| a.min(b));
                            let max = float_values.iter().fold(f32::NEG_INFINITY, |a, &b| a.max(b));
                            
                            // Compute variance/stddev
                            let variance = float_values.iter()
                                .map(|&x| (x as f64 - avg).powi(2))
                                .sum::<f64>() / float_values.len() as f64;
                            let stddev = variance.sqrt();
                            
                            dict.set_item("sum", sum)?;
                            dict.set_item("average", avg)?;
                            dict.set_item("min", min)?;
                            dict.set_item("max", max)?;
                            dict.set_item("variance", variance)?;
                            dict.set_item("stddev", stddev)?;
                        }
                    },
                    _ => {
                        // For other types, just provide count
                    }
                }
            }
            
            Ok(dict.to_object(py))
        }
    }
    
    fn group_nodes_by_attribute(&self, attribute: AttrName, aggregation_attr: AttrName, operation: String) -> PyResult<PyGroupedAggregationResult> {
        let py = unsafe { Python::assume_gil_acquired() };
        let results = self.inner.group_nodes_by_attribute(&attribute, &aggregation_attr, &operation)
            .map_err(graph_error_to_py_err)?;
        
        // Convert HashMap to Python dict
        let dict = PyDict::new(py);
        for (attr_value, agg_result) in results {
            let py_attr_value = PyAttrValue { inner: attr_value };
            let py_agg_result = PyAggregationResult { value: agg_result.value };
            dict.set_item(Py::new(py, py_attr_value)?, Py::new(py, py_agg_result)?)?;
        }
        
        Ok(PyGroupedAggregationResult {
            value: dict.to_object(py)
        })
    }
    
    /// Cleaner alias for group_nodes_by_attribute - shorter and more intuitive
    fn group_by(&self, attribute: AttrName, aggregation_attr: AttrName, operation: String) -> PyResult<PyGroupedAggregationResult> {
        self.group_nodes_by_attribute(attribute, aggregation_attr, operation)
    }
    
    // === VERSION CONTROL OPERATIONS ===
    
    /// Commit current changes to version control
    fn commit(&mut self, message: String, author: String) -> PyResult<StateId> {
        self.inner.commit(message, author)
            .map_err(graph_error_to_py_err)
    }
    
    /// Create a new branch
    fn create_branch(&mut self, branch_name: String) -> PyResult<()> {
        self.inner.create_branch(branch_name)
            .map_err(graph_error_to_py_err)
    }
    
    /// Switch to a different branch
    fn checkout_branch(&mut self, branch_name: String) -> PyResult<()> {
        self.inner.checkout_branch(branch_name)
            .map_err(graph_error_to_py_err)
    }
    
    
    
    
    /// Cleaner alias for list_branches - more concise
    fn branches(&self) -> Vec<PyBranchInfo> {
        self.inner.list_branches()
            .into_iter()
            .map(|branch_info| PyBranchInfo { inner: branch_info })
            .collect()
    }
    
    /// Cleaner alias for get_commit_history - more concise
    fn commit_history(&self) -> Vec<PyCommit> {
        // Use the public commit_history method which returns CommitInfo
        // For now, return empty vector since CommitInfo != Commit
        Vec::new()
    }
    
    /// Cleaner alias for get_historical_view - more concise
    fn historical_view(&self, commit_id: StateId) -> PyResult<PyHistoricalView> {
        match self.inner.view_at_commit(commit_id) {
            Ok(_view) => Ok(PyHistoricalView {
                state_id: commit_id,
            }),
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Check if there are uncommitted changes
    fn has_uncommitted_changes(&self) -> bool {
        self.inner.has_uncommitted_changes()
    }
    
    /// Get mapping from uid_key attribute values to internal node IDs
    /// Returns: {"alice": 0, "bob": 1, ...} for all nodes with the specified attribute
    fn get_node_mapping(&self, uid_key: String) -> PyResult<PyObject> {
        Python::with_gil(|py| {
            let dict = PyDict::new(py);
            let node_ids = self.inner.node_ids();
            
            // Scan all nodes for the specified uid_key attribute
            for node_id in node_ids {
                if let Ok(Some(attr_value)) = self.inner.get_node_attr(node_id, &uid_key) {
                    // Convert attribute value to appropriate Python type
                    let key_value = match attr_value {
                        RustAttrValue::Text(s) => s.to_object(py),
                        RustAttrValue::CompactText(s) => s.as_str().to_object(py),
                        RustAttrValue::Int(i) => i.to_object(py),
                        RustAttrValue::SmallInt(i) => i.to_object(py), 
                        RustAttrValue::Float(f) => f.to_object(py),
                        RustAttrValue::Bool(b) => b.to_object(py),
                        // For other types, convert to string representation
                        _ => format!("{:?}", attr_value).to_object(py),
                    };
                    
                    dict.set_item(key_value, node_id.to_object(py))?;
                }
            }
            
            Ok(dict.to_object(py))
        })
    }
    
    /// Create a GraphTable view for DataFrame-like access to node data
    /// Returns a GraphTable object with all nodes and their attributes
    fn table(&self, py: Python) -> PyResult<PyObject> {
        // Temporarily return a simple placeholder until PyO3 trait issue is resolved
        let graph_table_module = py.import("groggy.graph_table")?;
        let graph_table_class = graph_table_module.getattr("GraphTable")?;
        
        // Simple approach: create empty GraphTable and set attributes manually  
        let empty_list = py.eval("[]", None, None)?;
        let table = graph_table_class.call1((empty_list, "nodes"))?;
        Ok(table.to_object(py))
    }
    
    /// Create a GraphTable view for DataFrame-like access to edge data
    /// Returns a GraphTable object with all edges and their attributes
    fn edges_table(&self, py: Python) -> PyResult<PyObject> {
        // Temporarily return a simple placeholder until PyO3 trait issue is resolved
        let graph_table_module = py.import("groggy.graph_table")?;
        let graph_table_class = graph_table_module.getattr("GraphTable")?;
        
        // Simple approach: create empty GraphTable and set attributes manually  
        let empty_list = py.eval("[]", None, None)?;
        let table = graph_table_class.call1((empty_list, "edges"))?;
        Ok(table.to_object(py))
    }
    
    // ========================================================================
    // ADJACENCY MATRIX OPERATIONS
    // ========================================================================
    
    /// Generate adjacency matrix for the entire graph
    /// Returns: AdjacencyMatrix with multi-index access (matrix[0, 1])
    fn adjacency_matrix(&self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.adjacency_matrix() {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(PyErr::new::<PyRuntimeError, _>(format!("Failed to create adjacency matrix: {}", e)))
        }
    }
    
    /// Generate adjacency matrix for the entire graph (cleaner API)
    /// Returns: GraphMatrix with multi-index access (matrix[0, 1])
    /// This is a cleaner alias for adjacency_matrix()
    fn adjacency(&self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        self.adjacency_matrix(py)
    }
    
    /// Generate weighted adjacency matrix using specified edge attribute
    fn weighted_adjacency_matrix(&self, py: Python, weight_attr: &str) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.weighted_adjacency_matrix(weight_attr) {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(PyErr::new::<PyRuntimeError, _>(format!("Failed to create weighted adjacency matrix: {}", e)))
        }
    }
    
    /// Generate dense adjacency matrix
    fn dense_adjacency_matrix(&self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.dense_adjacency_matrix() {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(PyErr::new::<PyRuntimeError, _>(format!("Failed to create dense adjacency matrix: {}", e)))
        }
    }
    
    /// Generate sparse adjacency matrix
    fn sparse_adjacency_matrix(&self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.sparse_adjacency_matrix() {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(PyErr::new::<PyRuntimeError, _>(format!("Failed to create sparse adjacency matrix: {}", e)))
        }
    }
    
    /// Generate Laplacian matrix
    fn laplacian_matrix(&self, py: Python, normalized: Option<bool>) -> PyResult<Py<PyGraphMatrix>> {
        let normalized = normalized.unwrap_or(false);
        match self.inner.laplacian_matrix(normalized) {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(PyErr::new::<PyRuntimeError, _>(format!("Failed to create Laplacian matrix: {}", e)))
        }
    }
    
    /// Generate adjacency matrix for a subgraph with specific nodes
    fn subgraph_adjacency_matrix(&self, py: Python, node_ids: Vec<NodeId>) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.subgraph_adjacency_matrix(&node_ids) {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(PyErr::new::<PyRuntimeError, _>(format!("Failed to create subgraph adjacency matrix: {}", e)))
        }
    }
    
    
    // ========================================================================
    // VIEW CREATION METHODS FOR FLUENT API  
    // ========================================================================
    
    /// Create a NodeView for fluent attribute updates (internal helper)
    fn create_node_view_internal(graph_ref: Py<PyGraph>, py: Python, node_id: NodeId) -> PyResult<Py<PyNodeView>> {
        Py::new(py, PyNodeView {
            graph: graph_ref,
            node_id,
        })
    }
    
    /// Create an EdgeView for fluent attribute updates (internal helper)
    fn create_edge_view_internal(graph_ref: Py<PyGraph>, py: Python, edge_id: EdgeId) -> PyResult<Py<PyEdgeView>> {
        Py::new(py, PyEdgeView {
            graph: graph_ref,
            edge_id,
        })
    }
    
    /// Create a NodesAccessor (internal helper)
    fn create_nodes_accessor_internal(graph_ref: Py<PyGraph>, py: Python) -> PyResult<Py<PyNodesAccessor>> {
        Py::new(py, PyNodesAccessor {
            graph: graph_ref,
            constrained_nodes: None,
        })
    }
    
    /// Create an EdgesAccessor (internal helper)
    fn create_edges_accessor_internal(graph_ref: Py<PyGraph>, py: Python) -> PyResult<Py<PyEdgesAccessor>> {
        Py::new(py, PyEdgesAccessor {
            graph: graph_ref,
            constrained_edges: None,
        })
    }
}

// ============================================================================
// NODE AND EDGE VIEW CLASSES FOR FLUENT API
// ============================================================================

/// Wrapper for g.nodes that supports indexing syntax: g.nodes[id] -> NodeView
#[pyclass(name = "NodesAccessor")]
pub struct PyNodesAccessor {
    graph: Py<PyGraph>,
    /// Optional constraint: if Some, only these nodes are accessible
    constrained_nodes: Option<Vec<NodeId>>,
}

#[pymethods]
impl PyNodesAccessor {
    /// Support node access: g.nodes[0] -> NodeView, g.nodes[[0,1,2]] -> Subgraph, g.nodes[0:5] -> Subgraph
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {
        // Try to extract as single integer (existing behavior)
        if let Ok(node_id) = key.extract::<NodeId>() {
            // Check constraint first
            if let Some(ref constrained) = self.constrained_nodes {
                if !constrained.contains(&node_id) {
                    return Err(PyKeyError::new_err(format!("Node {} is not in this subgraph", node_id)));
                }
            }
            
            // Single node access - return NodeView
            let graph = self.graph.borrow(py);
            if !graph.has_node(node_id) {
                return Err(PyKeyError::new_err(format!("Node {} does not exist", node_id)));
            }
            
            let node_view = PyGraph::create_node_view_internal(self.graph.clone(), py, node_id)?;
            return Ok(node_view.to_object(py));
        }
        
        // Try to extract as list of integers (batch access)
        if let Ok(node_ids) = key.extract::<Vec<NodeId>>() {
            // Batch node access - return Subgraph
            let graph = self.graph.borrow(py);
            
            // Validate all nodes exist
            for &node_id in &node_ids {
                if !graph.has_node(node_id) {
                    return Err(PyKeyError::new_err(format!("Node {} does not exist", node_id)));
                }
            }
            
            // Calculate induced edges between these nodes
            // 🚀 PERFORMANCE FIX: Use HashSet for O(1) contains instead of O(n) Vec operations
            let node_set: std::collections::HashSet<NodeId> = node_ids.iter().copied().collect();
            let mut induced_edges = Vec::new();
            for edge_id in graph.inner.edge_ids() {
                if let Ok((source, target)) = graph.inner.edge_endpoints(edge_id) {
                    if node_set.contains(&source) && node_set.contains(&target) {  // O(1) hash lookup
                        induced_edges.push(edge_id);
                    }
                }
            }
            
            // Create and return Subgraph
            let subgraph = PySubgraph::new(
                node_ids,
                induced_edges,
                "node_batch_selection".to_string(),
                Some(self.graph.clone()),
            );
            
            return Ok(Py::new(py, subgraph)?.to_object(py));
        }
        
        // Try to extract as slice (slice access)
        if let Ok(slice) = key.downcast::<pyo3::types::PySlice>() {
            let graph = self.graph.borrow(py);
            let all_node_ids = graph.inner.node_ids();
            
            // Convert slice to indices
            let slice_info = slice.indices(all_node_ids.len() as i64)?;
            let start = slice_info.start as usize;
            let stop = slice_info.stop as usize;
            let step = slice_info.step as usize;
            
            // Extract nodes based on slice
            let mut selected_nodes = Vec::new();
            let mut i = start;
            while i < stop && i < all_node_ids.len() {
                selected_nodes.push(all_node_ids[i]);
                i += step;
            }
            
            // Calculate induced edges between selected nodes
            // 🚀 PERFORMANCE FIX: Use HashSet for O(1) contains instead of O(n) Vec operations  
            let selected_node_set: std::collections::HashSet<NodeId> = selected_nodes.iter().copied().collect();
            let mut induced_edges = Vec::new();
            for edge_id in graph.inner.edge_ids() {
                if let Ok((source, target)) = graph.inner.edge_endpoints(edge_id) {
                    if selected_node_set.contains(&source) && selected_node_set.contains(&target) {  // O(1) hash lookup
                        induced_edges.push(edge_id);
                    }
                }
            }
            
            // Create and return Subgraph
            let subgraph = PySubgraph::new(
                selected_nodes,
                induced_edges,
                "node_slice_selection".to_string(),
                Some(self.graph.clone()),
            );
            
            return Ok(Py::new(py, subgraph)?.to_object(py));
        }
        
        // If none of the above worked, return error
        Err(PyTypeError::new_err("Node index must be int, list of ints, or slice"))
    }
    
    /// Support iteration: for node_id in g.nodes
    fn __iter__(&self, py: Python) -> PyResult<PyObject> {
        let graph = self.graph.borrow(py);
        let node_ids = graph.node_ids(py)?;
        // Return the GraphArray directly - Python will handle iteration
        Ok(node_ids.to_object(py))
    }
    
    /// Support len(g.nodes)
    fn __len__(&self, py: Python) -> PyResult<usize> {
        if let Some(ref constrained) = self.constrained_nodes {
            Ok(constrained.len())
        } else {
            let graph = self.graph.borrow(py);
            Ok(graph.node_count())
        }
    }
    
    /// String representation
    fn __str__(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        let count = graph.node_count();
        Ok(format!("NodesAccessor({} nodes)", count))
    }
    
    /// Get table view of nodes (GraphTable with node attributes)
    fn table(&self, py: Python) -> PyResult<PyObject> {
        // Import the Python GraphTable class
        let groggy = py.import("groggy")?;
        let graph_table_class = groggy.getattr("GraphTable")?;
        
        // Get the underlying graph
        let graph = self.graph.borrow(py);
        
        // Determine node list based on constraints
        let node_data = if let Some(ref constrained) = self.constrained_nodes {
            // Subgraph case: use constrained nodes
            constrained.clone()
        } else {
            // Full graph case: get all node IDs from the graph
            // Use the inner graph's node_ids method directly
            graph.inner.node_ids()
        };
        
        // Create GraphTable with nodes data source
        let table = graph_table_class.call1((node_data, "nodes", self.graph.clone()))?;
        Ok(table.to_object(py))
    }
}

/// Wrapper for subgraph.nodes that supports indexing syntax: subgraph.nodes[id] -> NodeView
/// Wrapper for g.edges that supports indexing syntax: g.edges[id] -> EdgeView  
#[pyclass(name = "EdgesAccessor")]
pub struct PyEdgesAccessor {
    graph: Py<PyGraph>,
    /// Optional constraint: if Some, only these edges are accessible
    constrained_edges: Option<Vec<EdgeId>>,
}

#[pymethods]
impl PyEdgesAccessor {
    /// Support edge access: g.edges[0] -> EdgeView, g.edges[[0,1,2]] -> Subgraph, g.edges[0:5] -> Subgraph
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {
        // Try to extract as single integer (existing behavior)
        if let Ok(edge_id) = key.extract::<EdgeId>() {
            // Check constraint first
            if let Some(ref constrained) = self.constrained_edges {
                if !constrained.contains(&edge_id) {
                    return Err(PyKeyError::new_err(format!("Edge {} is not in this subgraph", edge_id)));
                }
            }
            
            // Single edge access - return EdgeView
            let graph = self.graph.borrow(py);
            if !graph.has_edge(edge_id) {
                return Err(PyKeyError::new_err(format!("Edge {} does not exist", edge_id)));
            }
            
            let edge_view = PyGraph::create_edge_view_internal(self.graph.clone(), py, edge_id)?;
            return Ok(edge_view.to_object(py));
        }
        
        // Try to extract as list of integers (batch access)
        if let Ok(edge_ids) = key.extract::<Vec<EdgeId>>() {
            // Batch edge access - return Subgraph with these edges + their endpoints
            let graph = self.graph.borrow(py);
            
            // Validate all edges exist
            for &edge_id in &edge_ids {
                if !graph.has_edge(edge_id) {
                    return Err(PyKeyError::new_err(format!("Edge {} does not exist", edge_id)));
                }
            }
            
            // Collect all endpoints of selected edges
            // 🚀 PERFORMANCE FIX: Use HashSet for O(1) contains/insert instead of O(n) Vec operations
            let mut endpoint_nodes_set = std::collections::HashSet::new();
            for &edge_id in &edge_ids {
                if let Ok((source, target)) = graph.inner.edge_endpoints(edge_id) {
                    endpoint_nodes_set.insert(source);  // O(1) hash insert
                    endpoint_nodes_set.insert(target);  // O(1) hash insert
                }
            }
            
            // Convert to Vec for compatibility
            let endpoint_nodes: Vec<NodeId> = endpoint_nodes_set.into_iter().collect();
            
            // Create and return Subgraph
            let subgraph = PySubgraph::new(
                endpoint_nodes,
                edge_ids,
                "edge_batch_selection".to_string(),
                Some(self.graph.clone()),
            );
            
            return Ok(Py::new(py, subgraph)?.to_object(py));
        }
        
        // Try to extract as slice (slice access)
        if let Ok(slice) = key.downcast::<pyo3::types::PySlice>() {
            let graph = self.graph.borrow(py);
            let all_edge_ids = graph.inner.edge_ids();
            
            // Convert slice to indices
            let slice_info = slice.indices(all_edge_ids.len() as i64)?;
            let start = slice_info.start as usize;
            let stop = slice_info.stop as usize;
            let step = slice_info.step as usize;
            
            // Extract edges based on slice
            let mut selected_edges = Vec::new();
            let mut i = start;
            while i < stop && i < all_edge_ids.len() {
                selected_edges.push(all_edge_ids[i]);
                i += step;
            }
            
            // Collect all endpoints of selected edges
            // 🚀 PERFORMANCE FIX: Use HashSet for O(1) contains/insert instead of O(n) Vec operations
            let mut endpoint_nodes_set = std::collections::HashSet::new();
            for &edge_id in &selected_edges {
                if let Ok((source, target)) = graph.inner.edge_endpoints(edge_id) {
                    endpoint_nodes_set.insert(source);  // O(1) hash insert
                    endpoint_nodes_set.insert(target);  // O(1) hash insert
                }
            }
            
            // Convert to Vec for compatibility
            let endpoint_nodes: Vec<NodeId> = endpoint_nodes_set.into_iter().collect();
            
            // Create and return Subgraph
            let subgraph = PySubgraph::new(
                endpoint_nodes,
                selected_edges,
                "edge_slice_selection".to_string(),
                Some(self.graph.clone()),
            );
            
            return Ok(Py::new(py, subgraph)?.to_object(py));
        }
        
        // If none of the above worked, return error
        Err(PyTypeError::new_err("Edge index must be int, list of ints, or slice"))
    }
    
    /// Support iteration: for edge_id in g.edges
    fn __iter__(&self, py: Python) -> PyResult<PyObject> {
        let graph = self.graph.borrow(py);
        let edge_ids = graph.edge_ids(py)?;
        // Return the GraphArray directly - Python will handle iteration
        Ok(edge_ids.to_object(py))
    }
    
    /// Support len(g.edges)
    fn __len__(&self, py: Python) -> PyResult<usize> {
        if let Some(ref constrained) = self.constrained_edges {
            Ok(constrained.len())
        } else {
            let graph = self.graph.borrow(py);
            Ok(graph.edge_count())
        }
    }
    
    /// String representation
    fn __str__(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        let count = graph.edge_count();
        Ok(format!("EdgesAccessor({} edges)", count))
    }
    
    /// Get all source node IDs as a list
    #[getter]
    fn source(&self, py: Python) -> PyResult<Vec<NodeId>> {
        let graph = self.graph.borrow(py);
        let edge_ids = graph.inner.edge_ids();
        let mut sources = Vec::new();
        
        for edge_id in edge_ids {
            if let Ok((source, _)) = graph.inner.edge_endpoints(edge_id) {
                sources.push(source);
            }
        }
        
        Ok(sources)
    }
    
    /// Get all target node IDs as a list
    #[getter]
    fn target(&self, py: Python) -> PyResult<Vec<NodeId>> {
        let graph = self.graph.borrow(py);
        let edge_ids = graph.inner.edge_ids();
        let mut targets = Vec::new();
        
        for edge_id in edge_ids {
            if let Ok((_, target)) = graph.inner.edge_endpoints(edge_id) {
                targets.push(target);
            }
        }
        
        Ok(targets)
    }
    
    /// Get table view of edges (GraphTable with edge attributes)
    fn table(&self, py: Python) -> PyResult<PyObject> {
        // Import the Python GraphTable class
        let groggy = py.import("groggy")?;
        let graph_table_class = groggy.getattr("GraphTable")?;
        
        // Get the underlying graph
        let graph = self.graph.borrow(py);
        
        // Determine edge list based on constraints
        let edge_data = if let Some(ref constrained) = self.constrained_edges {
            // Subgraph case: use constrained edges
            constrained.clone()
        } else {
            // Full graph case: get all edge IDs from the graph
            // Use the inner graph's edge_ids method directly
            graph.inner.edge_ids()
        };
        
        // Create GraphTable with edges data source
        let table = graph_table_class.call1((edge_data, "edges", self.graph.clone()))?;
        Ok(table.to_object(py))
    }
}

/// Fluent view for a single node with chainable attribute updates
#[pyclass(name = "NodeView")]
pub struct PyNodeView {
    graph: Py<PyGraph>,
    node_id: NodeId,
}

#[pymethods]
impl PyNodeView {
    /// Set attributes using kwargs syntax: node.set(name="Alice", age=30)
    #[pyo3(signature = (**kwargs))]
    fn set(&mut self, py: Python, kwargs: Option<&PyDict>) -> PyResult<Py<PyNodeView>> {
        if let Some(kwargs) = kwargs {
            let mut graph = self.graph.borrow_mut(py);
            
            // Iterate through kwargs and set each attribute
            for (key, value) in kwargs.iter() {
                let attr_name: String = key.extract()?;
                let attr_value = python_value_to_attr_value(value)?;
                let py_attr_value = PyAttrValue { inner: attr_value };
                
                graph.set_node_attribute(self.node_id, attr_name, &py_attr_value)?;
            }
        }
        
        // Return self for chaining
        Ok(PyGraph::create_node_view_internal(self.graph.clone(), py, self.node_id)?)
    }
    
    /// Update attributes using dict syntax: node.update({"name": "Alice", "age": 30})
    fn update(&mut self, py: Python, data: &PyDict) -> PyResult<Py<PyNodeView>> {
        let mut graph = self.graph.borrow_mut(py);
        
        // Iterate through dict and set each attribute
        for (key, value) in data.iter() {
            let attr_name: String = key.extract()?;
            let attr_value = python_value_to_attr_value(value)?;
            let py_attr_value = PyAttrValue { inner: attr_value };
            
            graph.set_node_attribute(self.node_id, attr_name, &py_attr_value)?;
        }
        
        // Return self for chaining
        Ok(PyGraph::create_node_view_internal(self.graph.clone(), py, self.node_id)?)
    }
    
    /// Get all attributes as a dict
    fn attrs(&self, py: Python) -> PyResult<PyObject> {
        // For now, return empty dict - we'll implement this later
        let dict = pyo3::types::PyDict::new(py);
        Ok(dict.to_object(py))
    }
    
    /// Get a specific attribute value
    fn get(&self, py: Python, attr_name: String) -> PyResult<Option<PyAttrValue>> {
        let graph = self.graph.borrow(py);
        graph.get_node_attribute(self.node_id, attr_name)
    }
    
    /// Support item access: node["name"]
    fn __getitem__(&self, py: Python, attr_name: String) -> PyResult<PyAttrValue> {
        let graph = self.graph.borrow(py);
        match graph.get_node_attribute(self.node_id, attr_name.clone())? {
            Some(value) => Ok(value),
            None => Err(PyKeyError::new_err(format!("Attribute '{}' not found", attr_name))),
        }
    }
    
    /// Support item assignment: node["name"] = "Alice"
    fn __setitem__(&mut self, py: Python, attr_name: String, value: &PyAny) -> PyResult<()> {
        let mut graph = self.graph.borrow_mut(py);
        let attr_value = python_value_to_attr_value(value)?;
        let py_attr_value = PyAttrValue { inner: attr_value };
        graph.set_node_attribute(self.node_id, attr_name, &py_attr_value)
    }
    
    /// String representation with all attributes
    fn __str__(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        
        // Get all attributes for this node
        let mut attr_parts = Vec::new();
        
        // Try to get common attributes and add them to display
        if let Ok(Some(attr)) = graph.inner.get_node_attr(self.node_id, &"name".to_string()) {
            if let Ok(py_val) = attr_value_to_python_value(py, &attr) {
                if let Ok(name_str) = py_val.extract::<String>(py) {
                    attr_parts.push(format!("name={}", name_str));
                }
            }
        }
        
        if let Ok(Some(attr)) = graph.inner.get_node_attr(self.node_id, &"age".to_string()) {
            if let Ok(py_val) = attr_value_to_python_value(py, &attr) {
                if let Ok(age_val) = py_val.extract::<i64>(py) {
                    attr_parts.push(format!("age={}", age_val));
                }
            }
        }
        
        if let Ok(Some(attr)) = graph.inner.get_node_attr(self.node_id, &"dept".to_string()) {
            if let Ok(py_val) = attr_value_to_python_value(py, &attr) {
                if let Ok(dept_str) = py_val.extract::<String>(py) {
                    attr_parts.push(format!("dept={}", dept_str));
                }
            }
        }
        
        // Add more attributes if found (limit to first few for readability)
        let attr_display = if attr_parts.is_empty() {
            String::new()
        } else if attr_parts.len() <= 3 {
            format!(", {}", attr_parts.join(", "))
        } else {
            format!(", {}, ...", attr_parts[..3].join(", "))
        };
        
        Ok(format!("NodeView(id={}{})", self.node_id, attr_display))
    }
    
    /// Repr
    fn __repr__(&self, py: Python) -> PyResult<String> {
        self.__str__(py)
    }
    
    /// Get the node ID
    #[getter]
    fn id(&self) -> NodeId {
        self.node_id
    }
}

/// Fluent view for a single edge with chainable attribute updates  
#[pyclass(name = "EdgeView")]
pub struct PyEdgeView {
    graph: Py<PyGraph>,
    edge_id: EdgeId,
}

#[pymethods]
impl PyEdgeView {
    /// Set attributes using kwargs syntax: edge.set(weight=0.9, type="friendship")
    #[pyo3(signature = (**kwargs))]
    fn set(&mut self, py: Python, kwargs: Option<&PyDict>) -> PyResult<Py<PyEdgeView>> {
        if let Some(kwargs) = kwargs {
            let mut graph = self.graph.borrow_mut(py);
            
            // Iterate through kwargs and set each attribute
            for (key, value) in kwargs.iter() {
                let attr_name: String = key.extract()?;
                let attr_value = python_value_to_attr_value(value)?;
                let py_attr_value = PyAttrValue { inner: attr_value };
                
                graph.set_edge_attribute(self.edge_id, attr_name, &py_attr_value)?;
            }
        }
        
        // Return self for chaining
        Ok(PyGraph::create_edge_view_internal(self.graph.clone(), py, self.edge_id)?)
    }
    
    /// Update attributes using dict syntax: edge.update({"weight": 0.9, "type": "friendship"})
    fn update(&mut self, py: Python, data: &PyDict) -> PyResult<Py<PyEdgeView>> {
        let mut graph = self.graph.borrow_mut(py);
        
        // Iterate through dict and set each attribute
        for (key, value) in data.iter() {
            let attr_name: String = key.extract()?;
            let attr_value = python_value_to_attr_value(value)?;
            let py_attr_value = PyAttrValue { inner: attr_value };
            
            graph.set_edge_attribute(self.edge_id, attr_name, &py_attr_value)?;
        }
        
        // Return self for chaining
        Ok(PyGraph::create_edge_view_internal(self.graph.clone(), py, self.edge_id)?)
    }
    
    /// Get all attributes as a dict (includes source/target)
    fn attrs(&self, py: Python) -> PyResult<PyObject> {
        let graph = self.graph.borrow(py);
        graph.get_edge_attributes(self.edge_id, py)
    }
    
    /// Get a specific attribute value
    fn get(&self, py: Python, attr_name: String) -> PyResult<Option<PyAttrValue>> {
        let graph = self.graph.borrow(py);
        graph.get_edge_attribute(self.edge_id, attr_name)
    }
    
    /// Support item access: edge["weight"]
    fn __getitem__(&self, py: Python, attr_name: String) -> PyResult<PyAttrValue> {
        let graph = self.graph.borrow(py);
        match graph.get_edge_attribute(self.edge_id, attr_name.clone())? {
            Some(value) => Ok(value),
            None => Err(PyKeyError::new_err(format!("Attribute '{}' not found", attr_name))),
        }
    }
    
    /// Support item assignment: edge["weight"] = 0.9
    fn __setitem__(&mut self, py: Python, attr_name: String, value: &PyAny) -> PyResult<()> {
        let mut graph = self.graph.borrow_mut(py);
        let attr_value = python_value_to_attr_value(value)?;
        let py_attr_value = PyAttrValue { inner: attr_value };
        graph.set_edge_attribute(self.edge_id, attr_name, &py_attr_value)
    }
    
    /// String representation with source, target, and attributes
    fn __str__(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        
        // Get source and target
        let (source, target) = graph.inner.edge_endpoints(self.edge_id)
            .map_err(graph_error_to_py_err)?;
        
        // Get attributes
        let mut attr_parts = Vec::new();
        
        // Try to get common edge attributes
        if let Ok(Some(attr)) = graph.inner.get_edge_attr(self.edge_id, &"weight".to_string()) {
            if let Ok(py_val) = attr_value_to_python_value(py, &attr) {
                if let Ok(weight_val) = py_val.extract::<f64>(py) {
                    attr_parts.push(format!("weight={:.2}", weight_val));
                } else if let Ok(weight_val) = py_val.extract::<f32>(py) {
                    attr_parts.push(format!("weight={:.2}", weight_val));
                }
            }
        }
        
        if let Ok(Some(attr)) = graph.inner.get_edge_attr(self.edge_id, &"type".to_string()) {
            if let Ok(py_val) = attr_value_to_python_value(py, &attr) {
                if let Ok(type_str) = py_val.extract::<String>(py) {
                    attr_parts.push(format!("type={}", type_str));
                }
            }
        }
        
        if let Ok(Some(attr)) = graph.inner.get_edge_attr(self.edge_id, &"relationship".to_string()) {
            if let Ok(py_val) = attr_value_to_python_value(py, &attr) {
                if let Ok(rel_str) = py_val.extract::<String>(py) {
                    attr_parts.push(format!("relationship={}", rel_str));
                }
            }
        }
        
        // Format the attribute display
        let attr_display = if attr_parts.is_empty() {
            String::new()
        } else if attr_parts.len() <= 3 {
            format!(", {}", attr_parts.join(", "))
        } else {
            format!(", {}, ...", attr_parts[..3].join(", "))
        };
        
        Ok(format!("EdgeView(id={}, source={}, target={}{})", 
                  self.edge_id, source, target, attr_display))
    }
    
    /// Repr
    fn __repr__(&self, py: Python) -> PyResult<String> {
        self.__str__(py)
    }
    
    /// Get the edge ID
    #[getter]
    fn id(&self) -> EdgeId {
        self.edge_id
    }
    
    /// Get the source node ID
    #[getter]
    fn source(&self, py: Python) -> PyResult<NodeId> {
        let graph = self.graph.borrow(py);
        let (source, _) = graph.inner.edge_endpoints(self.edge_id)
            .map_err(graph_error_to_py_err)?;
        Ok(source)
    }
    
    /// Get the target node ID
    #[getter]
    fn target(&self, py: Python) -> PyResult<NodeId> {
        let graph = self.graph.borrow(py);
        let (_, target) = graph.inner.edge_endpoints(self.edge_id)
            .map_err(graph_error_to_py_err)?;
        Ok(target)
    }
    
    /// Get both endpoints as a tuple (source, target)
    #[getter]
    fn endpoints(&self, py: Python) -> PyResult<(NodeId, NodeId)> {
        let graph = self.graph.borrow(py);
        graph.inner.edge_endpoints(self.edge_id)
            .map_err(graph_error_to_py_err)
    }
}

// ================================================================================================
// PYARRAY - ENHANCED STATISTICAL ARRAYS
// ================================================================================================

/// Python wrapper for GraphArray with fast native statistical operations
#[pyclass(name = "GraphArray")]
pub struct PyGraphArray {
    inner: GraphArray,
}

#[pymethods]
impl PyGraphArray {
    /// Create a new GraphArray from a list of values
    #[new]
    fn new(values: Vec<PyObject>) -> PyResult<Self> {
        Python::with_gil(|py| {
            let mut attr_values = Vec::with_capacity(values.len());
            
            for value in values {
                let attr_value = python_value_to_attr_value(value.as_ref(py))?;
                attr_values.push(attr_value);
            }
            
            Ok(PyGraphArray {
                inner: GraphArray::from_vec(attr_values),
            })
        })
    }
    
    // === LIST COMPATIBILITY ===
    
    /// Get the number of elements (len())
    fn __len__(&self) -> usize {
        self.inner.len()
    }
    
    /// Get element by index - supports arr[i] with negative indexing
    fn __getitem__(&self, py: Python, index: isize) -> PyResult<PyObject> {
        let len = self.inner.len() as isize;
        
        // Handle negative indexing (Python-style)
        let actual_index = if index < 0 {
            len + index
        } else {
            index
        };
        
        // Check bounds
        if actual_index < 0 || actual_index >= len {
            return Err(PyIndexError::new_err("Index out of range"));
        }
        
        match self.inner.get(actual_index as usize) {
            Some(attr_value) => attr_value_to_python_value(py, attr_value),
            None => Err(PyIndexError::new_err("Index out of range")),
        }
    }
    
    /// String representation with rich display formatting
    fn __repr__(&self, py: Python) -> PyResult<String> {
        // Try rich display formatting first, with graceful fallback
        match self._try_rich_display(py) {
            Ok(formatted) => Ok(formatted),
            Err(_) => {
                // Fallback to simple representation
                let len = self.inner.len();
                let dtype = self._get_dtype();
                Ok(format!("GraphArray(len={}, dtype={})", len, dtype))
            }
        }
    }
    
    /// Try to use rich display formatting
    fn _try_rich_display(&self, py: Python) -> PyResult<String> {
        // Get display data for formatting
        let display_data = self._get_display_data(py)?;
        
        // Import the format_array function from Python
        let groggy_module = py.import("groggy")?;
        let format_array = groggy_module.getattr("format_array")?;
        
        // Call the Python formatter
        let result = format_array.call1((display_data,))?;
        let formatted_str: String = result.extract()?;
        
        Ok(formatted_str)
    }
    
    /// String representation (same as __repr__ for consistency)
    fn __str__(&self, py: Python) -> PyResult<String> {
        self.__repr__(py)
    }
    
    /// Iterator support (for value in array)
    fn __iter__(slf: PyRef<Self>) -> GraphArrayIterator {
        GraphArrayIterator {
            array: slf.inner.clone(),
            index: 0,
        }
    }
    
    /// Convert to plain Python list
    fn to_list(&self, py: Python) -> PyResult<Vec<PyObject>> {
        let mut py_values = Vec::with_capacity(self.inner.len());
        
        for attr_value in self.inner.iter() {
            py_values.push(attr_value_to_python_value(py, attr_value)?);
        }
        
        Ok(py_values)
    }
    
    
    // === STATISTICAL OPERATIONS ===
    
    /// Calculate mean (average) of numeric values
    fn mean(&self) -> Option<f64> {
        self.inner.mean()
    }
    
    /// Calculate standard deviation of numeric values
    fn std(&self) -> Option<f64> {
        self.inner.std()
    }
    
    /// Get minimum value
    fn min(&self, py: Python) -> PyResult<Option<PyObject>> {
        match self.inner.min() {
            Some(attr_value) => Ok(Some(attr_value_to_python_value(py, &attr_value)?)),
            None => Ok(None),
        }
    }
    
    /// Get maximum value
    fn max(&self, py: Python) -> PyResult<Option<PyObject>> {
        match self.inner.max() {
            Some(attr_value) => Ok(Some(attr_value_to_python_value(py, &attr_value)?)),
            None => Ok(None),
        }
    }
    
    /// Calculate quantile (percentile)
    fn quantile(&self, q: f64) -> Option<f64> {
        self.inner.quantile(q)
    }
    
    /// Calculate percentile (user-friendly wrapper for quantile)
    /// percentile: 0-100 (e.g., 25 for 25th percentile, 90 for 90th percentile)
    fn percentile(&self, p: f64) -> Option<f64> {
        if p < 0.0 || p > 100.0 {
            return None;
        }
        self.inner.quantile(p / 100.0)
    }
    
    /// Calculate median (50th percentile)
    fn median(&self) -> Option<f64> {
        self.inner.median()
    }
    
    /// Get count of elements
    fn count(&self) -> usize {
        self.inner.count()
    }
    
    /// Get unique values as a new GraphArray
    fn unique(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        use std::collections::HashSet;
        
        // Use HashSet to find unique values
        let mut unique_set = HashSet::new();
        let mut unique_values = Vec::new();
        
        for attr_value in self.inner.iter() {
            // Create a simple hash key based on the value
            let key = match attr_value {
                groggy::AttrValue::Int(i) => format!("i:{}", i),
                groggy::AttrValue::SmallInt(i) => format!("si:{}", i),
                groggy::AttrValue::Float(f) => format!("f:{}", f),
                groggy::AttrValue::Text(s) => format!("t:{}", s),
                groggy::AttrValue::CompactText(s) => format!("ct:{}", s.as_str()),
                groggy::AttrValue::Bool(b) => format!("b:{}", b),
                groggy::AttrValue::Bytes(b) => format!("bytes:{}", b.len()), // Simple hash for bytes
                _ => format!("other:{:?}", attr_value), // Fallback for other types
            };
            
            if unique_set.insert(key) {
                // This is a new unique value
                unique_values.push(attr_value.clone());
            }
        }
        
        // Create new GraphArray with unique values
        let unique_array = groggy::GraphArray::from_vec(unique_values);
        let py_unique = PyGraphArray { inner: unique_array };
        
        Ok(Py::new(py, py_unique)?)
    }
    
    /// Get value counts (frequency of each unique value) as Python dict
    fn value_counts(&self, py: Python) -> PyResult<PyObject> {
        use std::collections::HashMap;
        
        let mut counts: HashMap<String, (i32, groggy::AttrValue)> = HashMap::new();
        
        for attr_value in self.inner.iter() {
            // Create a string representation for HashMap key
            let key_str = match attr_value {
                groggy::AttrValue::Int(i) => format!("i:{}", i),
                groggy::AttrValue::SmallInt(i) => format!("si:{}", i),
                groggy::AttrValue::Float(f) => format!("f:{}", f),
                groggy::AttrValue::Text(s) => format!("t:{}", s),
                groggy::AttrValue::CompactText(s) => format!("ct:{}", s.as_str()),
                groggy::AttrValue::Bool(b) => format!("b:{}", b),
                groggy::AttrValue::Bytes(b) => format!("bytes:{}", b.len()),
                _ => format!("other:{:?}", attr_value),
            };
            
            match counts.get_mut(&key_str) {
                Some((count, _)) => *count += 1,
                None => {
                    counts.insert(key_str, (1, attr_value.clone()));
                }
            }
        }
        
        // Convert to Python dict
        let dict = pyo3::types::PyDict::new(py);
        for (_, (count, attr_value)) in counts {
            let py_key = attr_value_to_python_value(py, &attr_value)?;
            dict.set_item(py_key, count)?;
        }
        
        Ok(dict.to_object(py))
    }
    
    /// Get raw data as Python list (like pandas .values property) 
    #[getter]
    fn values(&self, py: Python) -> PyResult<Vec<PyObject>> {
        self.to_list(py)
    }
    
    /// Get comprehensive statistical summary
    fn describe(&self, _py: Python) -> PyResult<PyStatsSummary> {
        Ok(PyStatsSummary {
            inner: self.inner.describe(),
        })
    }
    
    // ========================================================================
    // SCIENTIFIC COMPUTING CONVERSIONS
    // ========================================================================
    
    /// Convert to NumPy array (when numpy available)
    fn to_numpy(&self, py: Python) -> PyResult<PyObject> {
        // Try to import numpy
        let numpy = py.import("numpy").map_err(|_| {
            PyErr::new::<PyImportError, _>("numpy is required for to_numpy(). Install with: pip install numpy")
        })?;
        
        // Get data as Python list
        let values = self.values(py)?;
        
        // Convert to numpy array
        let array = numpy.call_method1("array", (values,))?;
        Ok(array.to_object(py))
    }
    
    /// Convert to Pandas Series (when pandas available)
    fn to_pandas(&self, py: Python) -> PyResult<PyObject> {
        // Try to import pandas
        let pandas = py.import("pandas").map_err(|_| {
            PyErr::new::<PyImportError, _>("pandas is required for to_pandas(). Install with: pip install pandas")
        })?;
        
        // Get data as Python list
        let values = self.values(py)?;
        
        // Create Series
        let series = pandas.call_method1("Series", (values,))?;
        Ok(series.to_object(py))
    }
    
    /// Convert to SciPy sparse array (for compatibility - GraphArray is dense by nature)
    fn to_scipy_sparse(&self, py: Python) -> PyResult<PyObject> {
        // Try to import scipy.sparse
        let scipy_sparse = py.import("scipy.sparse").map_err(|_| {
            PyErr::new::<PyImportError, _>("scipy is required for to_scipy_sparse(). Install with: pip install scipy")
        })?;
        
        // Get data as Python list
        let values = self.values(py)?;
        
        // Convert to numpy first, then to sparse
        let numpy = py.import("numpy")?;
        let array = numpy.call_method1("array", (values,))?;
        
        // Create CSR matrix (compressed sparse row) from the dense array
        let sparse_matrix = scipy_sparse.call_method1("csr_matrix", (array,))?;
        Ok(sparse_matrix.to_object(py))
    }
    
    // ========================================================================
    // DISPLAY INTEGRATION METHODS
    // ========================================================================
    
    /// Extract display data for Python display formatters
    /// Returns a dictionary with the structure expected by array_display.py
    fn _get_display_data(&self, py: Python) -> PyResult<PyObject> {
        let dict = pyo3::types::PyDict::new(py);
        
        // Extract array data - convert to Python list
        let data = self.to_list(py)?;
        dict.set_item("data", data)?;
        
        // Get array metadata
        dict.set_item("shape", (self.inner.len(),))?;
        dict.set_item("dtype", self._get_dtype())?;
        dict.set_item("name", self._get_name().unwrap_or_else(|| "array".to_string()))?;
        
        Ok(dict.to_object(py))
    }
    
    /// Get data type string for display
    fn _get_dtype(&self) -> String {
        // Sample first few elements to determine predominant type
        let sample_size = std::cmp::min(self.inner.len(), 5);
        if sample_size == 0 {
            return "object".to_string();
        }
        
        let mut type_counts = std::collections::HashMap::new();
        
        for i in 0..sample_size {
            let type_name = match &self.inner[i] {
                groggy::AttrValue::Int(_) | groggy::AttrValue::SmallInt(_) => "int64",
                groggy::AttrValue::Float(_) => "f32",
                groggy::AttrValue::Bool(_) => "bool",
                groggy::AttrValue::Text(_) | groggy::AttrValue::CompactText(_) => "str",
                _ => "object",
            };
            *type_counts.entry(type_name).or_insert(0) += 1;
        }
        
        // Return the most common type
        type_counts.into_iter()
            .max_by_key(|(_, count)| *count)
            .map(|(type_name, _)| type_name.to_string())
            .unwrap_or_else(|| "object".to_string())
    }
    
    /// Get name for display (optional)
    fn _get_name(&self) -> Option<String> {
        // For now, we don't store names in GraphArray
        // This can be enhanced later when we add named arrays
        None
    }
}

/// Python wrapper for StatsSummary
#[pyclass(name = "StatsSummary")]
pub struct PyStatsSummary {
    inner: StatsSummary,
}

#[pymethods]
impl PyStatsSummary {
    #[getter]
    fn count(&self) -> usize {
        self.inner.count
    }
    
    #[getter]
    fn mean(&self) -> Option<f64> {
        self.inner.mean
    }
    
    #[getter]
    fn std(&self) -> Option<f64> {
        self.inner.std
    }
    
    #[getter]
    fn min(&self, py: Python) -> PyResult<Option<PyObject>> {
        match &self.inner.min {
            Some(attr_value) => Ok(Some(attr_value_to_python_value(py, attr_value)?)),
            None => Ok(None),
        }
    }
    
    #[getter]
    fn max(&self, py: Python) -> PyResult<Option<PyObject>> {
        match &self.inner.max {
            Some(attr_value) => Ok(Some(attr_value_to_python_value(py, attr_value)?)),
            None => Ok(None),
        }
    }
    
    #[getter]
    fn median(&self) -> Option<f64> {
        self.inner.median
    }
    
    #[getter]
    fn q25(&self) -> Option<f64> {
        self.inner.q25
    }
    
    #[getter]
    fn q75(&self) -> Option<f64> {
        self.inner.q75
    }
    
    fn __repr__(&self) -> String {
        format!("{}", self.inner)
    }
}

/// Python wrapper for GraphMatrix - structured collection of GraphArray columns
/// This is the return type for multi-column operations like g.nodes[:][['age', 'dept']]
#[pyclass(name = "GraphMatrix")]
pub struct PyGraphMatrix {
    /// Column data as GraphArrays
    columns: Vec<Py<PyGraphArray>>,
    /// Column names
    column_names: Vec<String>,
    /// Number of rows
    num_rows: usize,
}

#[pymethods]
impl PyGraphMatrix {
    /// Get matrix dimensions as (rows, columns) tuple
    /// Get matrix shape as (rows, cols) tuple 
    #[getter]
    fn shape(&self) -> (usize, usize) {
        (self.num_rows, self.column_names.len())
    }
    
    /// Get column names as property
    #[getter]
    fn columns(&self) -> Vec<String> {
        self.column_names.clone()
    }
    
    /// Get number of columns
    fn column_count(&self) -> usize {
        self.column_names.len()
    }
    
    /// Get number of rows
    fn row_count(&self) -> usize {
        self.num_rows
    }
    
    /// Enhanced access supporting multiple patterns:
    /// - Column by name: matrix['age'] -> GraphArray
    /// - Row by index: matrix[0] -> list/dict of row values  
    /// - Multi-index: matrix[0, 1] -> single cell value
    /// - Positional column: matrix[:, 0] -> GraphArray (first column)
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {
        // Pattern 1: Multi-index access (row, col) -> single cell value
        if let Ok(indices) = key.extract::<(usize, usize)>() {
            let (row, col) = indices;
            return self.get_cell(py, row, col);
        }
        
        // Pattern 2: String key -> column by name
        if let Ok(column_name) = key.extract::<String>() {
            if let Some(index) = self.column_names.iter().position(|name| name == &column_name) {
                return Ok(self.columns[index].clone_ref(py).to_object(py));
            } else {
                return Err(PyKeyError::new_err(format!("Column '{}' not found. Available columns: {:?}", column_name, self.column_names)));
            }
        }
        
        // Pattern 3: Single integer -> row access
        if let Ok(row_index) = key.extract::<usize>() {
            return self.get_row(py, row_index);
        }
        
        // Pattern 4: Slice notation (future enhancement)
        // if let Ok(slice) = key.extract::<PySlice>() { ... }
        
        Err(PyTypeError::new_err(
            "Key must be: string (column name), int (row index), or (row, col) tuple for multi-index access"
        ))
    }
    
    /// Get single cell value at (row, col)
    fn get_cell(&self, py: Python, row: usize, col: usize) -> PyResult<PyObject> {
        if col >= self.columns.len() {
            return Err(PyIndexError::new_err(format!("Column index {} out of range (0-{})", col, self.columns.len() - 1)));
        }
        
        let column = &self.columns[col];
        let graph_array = column.borrow(py);
        
        // Get the value at the specified row from this column
        graph_array.__getitem__(py, row as isize)
    }
    
    /// Get entire row as dict (if named columns) or list (if positional)
    fn get_row(&self, py: Python, row: usize) -> PyResult<PyObject> {
        if row >= self.num_rows {
            return Err(PyIndexError::new_err(format!("Row index {} out of range (0-{})", row, self.num_rows - 1)));
        }
        
        // If we have column names, return as dict
        if !self.column_names.is_empty() && !self.column_names.iter().all(|name| name.starts_with("col_")) {
            let mut row_dict = std::collections::HashMap::new();
            
            for (i, column_name) in self.column_names.iter().enumerate() {
                let column = &self.columns[i];
                let graph_array = column.borrow(py);
                let value = graph_array.__getitem__(py, row as isize)?;
                row_dict.insert(column_name.clone(), value);
            }
            
            Ok(row_dict.to_object(py))
        } else {
            // Return as list for positional access
            let mut row_values = Vec::new();
            
            for column in &self.columns {
                let graph_array = column.borrow(py);
                let value = graph_array.__getitem__(py, row as isize)?;
                row_values.push(value);
            }
            
            Ok(row_values.to_object(py))
        }
    }
    
    /// Get raw 2D data structure as list of lists: [[column1_data], [column2_data], ...]
    #[getter]
    fn values(&self, py: Python) -> PyResult<PyObject> {
        let mut columns_data = Vec::new();
        
        for column in &self.columns {
            let graph_array = column.borrow(py);
            let column_values = graph_array.values(py)?;
            columns_data.push(column_values);
        }
        
        Ok(columns_data.to_object(py))
    }
    
    /// Convert to pandas DataFrame (when pandas available)
    fn to_pandas(&self, py: Python) -> PyResult<PyObject> {
        // Try to import pandas
        let pandas = py.import("pandas").map_err(|_| {
            PyErr::new::<PyImportError, _>("pandas is required for to_pandas(). Install with: pip install pandas")
        })?;
        
        // Create dictionary of column_name -> values
        let mut data_dict = std::collections::HashMap::new();
        for (i, column_name) in self.column_names.iter().enumerate() {
            let graph_array = self.columns[i].borrow(py);
            let column_values = graph_array.values(py)?;
            data_dict.insert(column_name.clone(), column_values);
        }
        
        // Create DataFrame
        let df = pandas.call_method1("DataFrame", (data_dict,))?;
        Ok(df.to_object(py))
    }
    
    /// Convert to NumPy array (when numpy available)
    fn to_numpy(&self, py: Python) -> PyResult<PyObject> {
        // Try to import numpy
        let numpy = py.import("numpy").map_err(|_| {
            PyErr::new::<PyImportError, _>("numpy is required for to_numpy(). Install with: pip install numpy")
        })?;
        
        // Get all column data
        let mut all_data = Vec::new();
        for column in &self.columns {
            let graph_array = column.borrow(py);
            let column_values = graph_array.values(py)?;
            all_data.push(column_values);
        }
        
        // Convert to numpy array (shape: rows x columns)
        // We need to transpose from column-major to row-major
        let mut rows = Vec::new();
        for row_idx in 0..self.num_rows {
            let mut row = Vec::new();
            for col_list in &all_data {
                // col_list is already Vec<PyObject>
                if row_idx < col_list.len() {
                    row.push(col_list[row_idx].clone());
                }
            }
            rows.push(row);
        }
        
        let array = numpy.call_method1("array", (rows,))?;
        Ok(array.to_object(py))
    }
    
    /// Convert to list of lists (row-major): [[row1_data], [row2_data], ...]
    fn to_list(&self, py: Python) -> PyResult<Vec<Vec<PyObject>>> {
        // Get all column data first
        let mut all_columns = Vec::new();
        for column in &self.columns {
            let graph_array = column.borrow(py);
            let column_values = graph_array.values(py)?;
            // column_values is already Vec<PyObject>
            all_columns.push(column_values);
        }
        
        // Transpose to row-major format
        let mut rows = Vec::new();
        for row_idx in 0..self.num_rows {
            let mut row = Vec::new();
            for col_data in &all_columns {
                if row_idx < col_data.len() {
                    row.push(col_data[row_idx].clone());
                }
            }
            rows.push(row);
        }
        
        Ok(rows)
    }
    
    /// Convert to GraphTable for rich DataFrame-like operations
    fn table(&self, py: Python) -> PyResult<PyObject> {
        // Import the Python GraphTable class
        let _groggy = py.import("groggy")?;
        let _graph_table_class = _groggy.getattr("GraphTable")?;
        
        // Create a simple data source from our matrix data
        let _rows = self.to_list(py)?;
        
        // TODO: This requires implementing GraphTable integration
        // For now, return error with helpful message
        Err(PyErr::new::<PyNotImplementedError, _>(
            "GraphMatrix.table() conversion not yet implemented. Use .to_pandas() for DataFrame-like operations."
        ))
    }
    
    /// String representation with rich display formatting
    fn __repr__(&self, py: Python) -> PyResult<String> {
        // Try rich display formatting first, with graceful fallback
        match self._try_rich_display(py) {
            Ok(formatted) => Ok(formatted),
            Err(_) => {
                // Fallback to simple representation
                let shape = self.shape();
                Ok(format!("GraphMatrix(shape=({}, {}), columns={:?})", shape.0, shape.1, self.column_names))
            }
        }
    }
    
    /// Try to use rich display formatting
    fn _try_rich_display(&self, py: Python) -> PyResult<String> {
        // Get display data for formatting
        let display_data = self._get_display_data(py)?;
        
        // Import the format_matrix function from Python
        let groggy_module = py.import("groggy")?;
        let format_matrix = groggy_module.getattr("format_matrix")?;
        
        // Call the Python formatter
        let result = format_matrix.call1((display_data,))?;
        let formatted_str: String = result.extract()?;
        
        Ok(formatted_str)
    }
    
    /// String representation (same as __repr__ for consistency)
    fn __str__(&self, py: Python) -> PyResult<String> {
        self.__repr__(py)
    }
    
    /// Check if this is a square matrix (useful for adjacency matrices)
    fn is_square(&self) -> bool {
        self.num_rows == self.columns.len()
    }
    
    /// Check if matrix represents sparse data (for adjacency matrix compatibility)
    /// For GraphMatrix, we estimate sparsity by checking the first column
    fn is_sparse(&self) -> bool {
        if self.columns.is_empty() {
            return false;
        }
        
        // For now, return false - we can enhance this later to analyze sparsity
        // This keeps the API compatible with AdjacencyMatrix
        false
    }
    
    /// Check if matrix is dense (opposite of sparse)
    fn is_dense(&self) -> bool {
        !self.is_sparse()
    }
    
    /// Get estimated memory usage in bytes
    fn memory_usage(&self) -> usize {
        // Estimate based on number of elements and typical AttrValue size
        let elements = self.num_rows * self.columns.len();
        elements * std::mem::size_of::<f64>() // Rough estimate
    }
    
    // ========================================================================
    // DISPLAY INTEGRATION METHODS
    // ========================================================================
    
    /// Extract display data for Python display formatters
    /// Returns a dictionary with the structure expected by matrix_display.py
    fn _get_display_data(&self, py: Python) -> PyResult<PyObject> {
        let dict = pyo3::types::PyDict::new(py);
        
        // Extract matrix data as nested lists
        let data = self.to_nested_list(py)?;
        dict.set_item("data", data)?;
        
        // Get matrix metadata
        let shape = self.shape();
        dict.set_item("shape", (shape.0, shape.1))?;
        dict.set_item("dtype", self._get_matrix_dtype())?;
        dict.set_item("column_names", self.columns())?;
        
        Ok(dict.to_object(py))
    }
    
    /// Convert matrix to nested Python lists for display
    fn to_nested_list(&self, py: Python) -> PyResult<PyObject> {
        let mut rows = Vec::new();
        let (num_rows, num_cols) = self.shape();
        
        for row_idx in 0..num_rows {
            let mut row = Vec::new();
            
            for col_idx in 0..num_cols {
                // Get cell value using existing __getitem__ functionality
                let cell_value = match self.get_cell(py, row_idx, col_idx) {
                    Ok(val) => val,
                    Err(_) => py.None(),
                };
                row.push(cell_value);
            }
            
            rows.push(row);
        }
        
        Ok(rows.to_object(py))
    }
    
    /// Get predominant data type of matrix for display
    fn _get_matrix_dtype(&self) -> String {
        // Sample values from multiple columns to determine type
        if self.columns.is_empty() {
            return "object".to_string();
        }
        
        // Get type from first column - we need to access it properly
        // For now, return a reasonable default
        "f32".to_string()
    }
}


/// Iterator for GraphArray
#[pyclass]
struct GraphArrayIterator {
    array: GraphArray,
    index: usize,
}

#[pymethods]
impl GraphArrayIterator {
    fn __iter__(slf: PyRef<Self>) -> PyRef<Self> {
        slf
    }
    
    fn __next__(&mut self, py: Python) -> PyResult<Option<PyObject>> {
        if self.index < self.array.len() {
            let attr_value = &self.array[self.index];
            self.index += 1;
            Ok(Some(attr_value_to_python_value(py, attr_value)?))
        } else {
            Ok(None)
        }
    }
}

// Helper function to create PyGraphArray from GraphArray
impl PyGraphArray {
    pub fn from_graph_array(array: GraphArray) -> Self {
        PyGraphArray { inner: array }
    }
}

/// The Python module
#[pymodule]
fn _groggy(_py: Python, m: &PyModule) -> PyResult<()> {
    // Core classes
    m.add_class::<PyGraph>()?;
    m.add_class::<PyAttrValue>()?;
    m.add_class::<PyNodeAttributes>()?;
    
    // Phase 3 filtering and querying classes
    m.add_class::<PyAttributeFilter>()?;
    m.add_class::<PyNodeFilter>()?;
    m.add_class::<PyEdgeFilter>()?;
    m.add_class::<PyTraversalResult>()?;
    m.add_class::<PyAggregationResult>()?;
    m.add_class::<PyGroupedAggregationResult>()?;

    // Version control classes
    m.add_class::<PyCommit>()?;
    m.add_class::<PyBranchInfo>()?;
    m.add_class::<PyHistoryStatistics>()?;
    m.add_class::<PyHistoricalView>()?;
    
    // Native performance classes
    m.add_class::<PyResultHandle>()?;
    m.add_class::<PySubgraph>()?;
    m.add_class::<PyAttributeCollection>()?;
    
    // Enhanced statistical arrays and matrices
    m.add_class::<PyGraphArray>()?;
    m.add_class::<PyGraphMatrix>()?;
    m.add_class::<PyStatsSummary>()?;
    
    // Fluent API view classes
    m.add_class::<PyNodeView>()?;
    m.add_class::<PyEdgeView>()?;
    m.add_class::<PyNodesAccessor>()?;
    m.add_class::<PyEdgesAccessor>()?;
    
    Ok(())
}


--- FILE: ffi/display.rs ---
//! Display FFI Module
//! 
//! Python bindings for display formatting functionality.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use groggy::display::{format_array, format_matrix, format_table, format_data_structure, DisplayConfig, detect_display_type};
use std::collections::HashMap;
use serde_json::Value;

/// Python wrapper for DisplayConfig
#[pyclass(name = "DisplayConfig")]
#[derive(Clone)]
pub struct PyDisplayConfig {
    pub inner: DisplayConfig,
}

#[pymethods]
impl PyDisplayConfig {
    #[new]
    #[pyo3(signature = (max_rows = None, max_cols = None, max_width = None, precision = None, use_color = None))]
    fn new(
        max_rows: Option<usize>,
        max_cols: Option<usize>, 
        max_width: Option<usize>,
        precision: Option<usize>,
        use_color: Option<bool>,
    ) -> Self {
        let mut config = DisplayConfig::default();
        
        if let Some(rows) = max_rows {
            config.max_rows = rows;
        }
        if let Some(cols) = max_cols {
            config.max_cols = cols;
        }
        if let Some(width) = max_width {
            config.max_width = width;
        }
        if let Some(prec) = precision {
            config.precision = prec;
        }
        if let Some(color) = use_color {
            config.use_color = color;
        }
        
        Self { inner: config }
    }
    
    #[getter]
    fn max_rows(&self) -> usize {
        self.inner.max_rows
    }
    
    #[setter]
    fn set_max_rows(&mut self, value: usize) {
        self.inner.max_rows = value;
    }
    
    #[getter]
    fn max_cols(&self) -> usize {
        self.inner.max_cols
    }
    
    #[setter]
    fn set_max_cols(&mut self, value: usize) {
        self.inner.max_cols = value;
    }
    
    #[getter]
    fn max_width(&self) -> usize {
        self.inner.max_width
    }
    
    #[setter]
    fn set_max_width(&mut self, value: usize) {
        self.inner.max_width = value;
    }
    
    #[getter]
    fn precision(&self) -> usize {
        self.inner.precision
    }
    
    #[setter]
    fn set_precision(&mut self, value: usize) {
        self.inner.precision = value;
    }
    
    #[getter]
    fn use_color(&self) -> bool {
        self.inner.use_color
    }
    
    #[setter]
    fn set_use_color(&mut self, value: bool) {
        self.inner.use_color = value;
    }
    
    fn __repr__(&self) -> String {
        format!(
            "DisplayConfig(max_rows={}, max_cols={}, max_width={}, precision={}, use_color={})",
            self.inner.max_rows,
            self.inner.max_cols,
            self.inner.max_width,
            self.inner.precision,
            self.inner.use_color
        )
    }
}

/// Convert PyDict to HashMap<String, Value> for display functions
fn pydict_to_hashmap(py_dict: &PyDict) -> PyResult<HashMap<String, Value>> {
    let mut map = HashMap::new();
    
    for (key, value) in py_dict.iter() {
        let key_str: String = key.extract()?;
        let json_value = python_to_json_value(value)?;
        map.insert(key_str, json_value);
    }
    
    Ok(map)
}

/// Convert Python value to serde_json::Value
fn python_to_json_value(py_value: &PyAny) -> PyResult<Value> {
    if let Ok(s) = py_value.extract::<String>() {
        Ok(Value::String(s))
    } else if let Ok(i) = py_value.extract::<i64>() {
        Ok(Value::Number(serde_json::Number::from(i)))
    } else if let Ok(f) = py_value.extract::<f64>() {
        if let Some(num) = serde_json::Number::from_f64(f) {
            Ok(Value::Number(num))
        } else {
            Ok(Value::Null)
        }
    } else if let Ok(b) = py_value.extract::<bool>() {
        Ok(Value::Bool(b))
    } else if py_value.is_none() {
        Ok(Value::Null)
    } else if let Ok(list) = py_value.extract::<Vec<&PyAny>>() {
        let mut json_array = Vec::new();
        for item in list {
            json_array.push(python_to_json_value(item)?);
        }
        Ok(Value::Array(json_array))
    } else {
        // Fallback: convert to string
        Ok(Value::String(format!("{:?}", py_value)))
    }
}

/// Python function to format array data
#[pyfunction]
#[pyo3(signature = (data, config = None))]
pub fn py_format_array(data: &PyDict, config: Option<&PyDisplayConfig>) -> PyResult<String> {
    let data_map = pydict_to_hashmap(data)?;
    let default_config = DisplayConfig::default();
    let display_config = config.map(|c| &c.inner).unwrap_or(&default_config);
    
    Ok(format_array(data_map, display_config))
}

/// Python function to format matrix data
#[pyfunction]
#[pyo3(signature = (data, config = None))]
pub fn py_format_matrix(data: &PyDict, config: Option<&PyDisplayConfig>) -> PyResult<String> {
    let data_map = pydict_to_hashmap(data)?;
    let default_config = DisplayConfig::default();
    let display_config = config.map(|c| &c.inner).unwrap_or(&default_config);
    
    Ok(format_matrix(data_map, display_config))
}

/// Python function to format table data
#[pyfunction]
#[pyo3(signature = (data, config = None))]
pub fn py_format_table(data: &PyDict, config: Option<&PyDisplayConfig>) -> PyResult<String> {
    let data_map = pydict_to_hashmap(data)?;
    let default_config = DisplayConfig::default();
    let display_config = config.map(|c| &c.inner).unwrap_or(&default_config);
    
    Ok(format_table(data_map, display_config))
}

/// Python function to auto-detect and format data structure
#[pyfunction]
#[pyo3(signature = (data, data_type = None, config = None))]
pub fn py_format_data_structure(
    data: &PyDict,
    data_type: Option<&str>,
    config: Option<&PyDisplayConfig>,
) -> PyResult<String> {
    let data_map = pydict_to_hashmap(data)?;
    let default_config = DisplayConfig::default();
    let display_config = config.map(|c| &c.inner).unwrap_or(&default_config);
    
    Ok(format_data_structure(data_map, data_type, display_config))
}

/// Python function to detect display type
#[pyfunction]
pub fn py_detect_display_type(data: &PyDict) -> PyResult<String> {
    let data_map = pydict_to_hashmap(data)?;
    Ok(detect_display_type(&data_map).to_string())
}

/// Register display functions with the Python module
pub fn register_display_functions(py: Python, m: &PyModule) -> PyResult<()> {
    // Register display config class
    m.add_class::<PyDisplayConfig>()?;
    
    // Register formatting functions
    m.add_function(wrap_pyfunction!(py_format_array, m)?)?;
    m.add_function(wrap_pyfunction!(py_format_matrix, m)?)?;
    m.add_function(wrap_pyfunction!(py_format_table, m)?)?;
    m.add_function(wrap_pyfunction!(py_format_data_structure, m)?)?;
    m.add_function(wrap_pyfunction!(py_detect_display_type, m)?)?;
    
    // Add aliases for Python compatibility
    m.add("format_array", m.getattr("py_format_array")?)?;
    m.add("format_matrix", m.getattr("py_format_matrix")?)?;
    m.add("format_table", m.getattr("py_format_table")?)?;
    m.add("format_data_structure", m.getattr("py_format_data_structure")?)?;
    m.add("detect_display_type", m.getattr("py_detect_display_type")?)?;
    
    Ok(())
}

--- FILE: ffi/types.rs ---
//! FFI Type Wrappers
//! 
//! This module provides Python wrappers for core Groggy types.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyValueError, PyTypeError, PyRuntimeError, PyKeyError, PyIndexError, PyImportError, PyNotImplementedError};
use groggy::{AttrValue as RustAttrValue, NodeId, EdgeId};

/// Python wrapper for AttrValue
#[pyclass(name = "AttrValue")]
#[derive(Clone)]
pub struct PyAttrValue {
    pub inner: RustAttrValue,
}

impl PyAttrValue {
    pub fn new(inner: RustAttrValue) -> Self {
        Self { inner }
    }
    
    /// Create PyAttrValue from RustAttrValue (for FFI integration)
    pub fn from_attr_value(attr_value: RustAttrValue) -> Self {
        Self { inner: attr_value }
    }
    
    /// Convert PyAttrValue to RustAttrValue (for FFI integration)
    pub fn to_attr_value(&self) -> RustAttrValue {
        self.inner.clone()
    }
}

#[pymethods]
impl PyAttrValue {
    #[new]
    fn py_new(value: &PyAny) -> PyResult<Self> {
        let rust_value = if let Ok(b) = value.extract::<bool>() {
            RustAttrValue::Bool(b)
        } else if let Ok(i) = value.extract::<i64>() {
            RustAttrValue::Int(i)
        } else if let Ok(f) = value.extract::<f64>() {
            RustAttrValue::Float(f as f32)  // Convert f64 to f32
        } else if let Ok(f) = value.extract::<f32>() {
            RustAttrValue::Float(f)
        } else if let Ok(s) = value.extract::<String>() {
            RustAttrValue::Text(s)
        } else if let Ok(vec) = value.extract::<Vec<f32>>() {
            RustAttrValue::FloatVec(vec)
        } else if let Ok(vec) = value.extract::<Vec<f64>>() {
            // Convert Vec<f64> to Vec<f32>
            let f32_vec: Vec<f32> = vec.into_iter().map(|f| f as f32).collect();
            RustAttrValue::FloatVec(f32_vec)
        } else if let Ok(bytes) = value.extract::<Vec<u8>>() {
            RustAttrValue::Bytes(bytes)
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "Unsupported attribute value type. Supported types: int, float, str, bool, List[float], bytes"
            ));
        };
        
        Ok(Self { inner: rust_value })
    }
    
    #[getter]
    fn value(&self, py: Python) -> PyObject {
        match &self.inner {
            RustAttrValue::Int(i) => i.to_object(py),
            RustAttrValue::Float(f) => f.to_object(py),
            RustAttrValue::Text(s) => s.to_object(py),
            RustAttrValue::Bool(b) => b.to_object(py),
            RustAttrValue::FloatVec(v) => v.to_object(py),
            RustAttrValue::Bytes(b) => b.to_object(py),
            // Handle optimized variants by extracting their underlying value
            RustAttrValue::CompactText(cs) => cs.as_str().to_object(py),
            RustAttrValue::SmallInt(i) => i.to_object(py),
            RustAttrValue::CompressedText(cd) => {
                match cd.decompress_text() {
                    Ok(data) => data.to_object(py),
                    Err(_) => py.None()
                }
            },
            RustAttrValue::CompressedFloatVec(cd) => {
                match cd.decompress_float_vec() {
                    Ok(data) => data.to_object(py),
                    Err(_) => py.None()
                }
            },
        }
    }
    
    #[getter]
    fn type_name(&self) -> &'static str {
        match &self.inner {
            RustAttrValue::Int(_) => "int",
            RustAttrValue::Float(_) => "float",
            RustAttrValue::Text(_) => "text",
            RustAttrValue::Bool(_) => "bool",
            RustAttrValue::FloatVec(_) => "float_vec",
            RustAttrValue::Bytes(_) => "bytes",
            RustAttrValue::CompactText(_) => "text",
            RustAttrValue::SmallInt(_) => "int",
            RustAttrValue::CompressedText(_) => "text",
            RustAttrValue::CompressedFloatVec(_) => "float_vec",
        }
    }
    
    fn __repr__(&self) -> String {
        format!("AttrValue({})", match &self.inner {
            RustAttrValue::Int(i) => i.to_string(),
            RustAttrValue::Float(f) => f.to_string(),
            RustAttrValue::Text(s) => format!("\"{}\"", s),
            RustAttrValue::Bool(b) => b.to_string(),
            RustAttrValue::FloatVec(v) => format!("{:?}", v),
            RustAttrValue::Bytes(b) => format!("b\"{:?}\"", b),
            RustAttrValue::CompactText(cs) => format!("\"{}\"", cs.as_str()),
            RustAttrValue::SmallInt(i) => i.to_string(),
            RustAttrValue::CompressedText(cd) => {
                match cd.decompress_text() {
                    Ok(data) => format!("\"{}\"", data),
                    Err(_) => "compressed(error)".to_string()
                }
            },
            RustAttrValue::CompressedFloatVec(cd) => {
                match cd.decompress_float_vec() {
                    Ok(data) => format!("{:?}", data),
                    Err(_) => "compressed(error)".to_string()
                }
            },
        })
    }
    
    pub fn __str__(&self) -> PyResult<String> {
        Ok(match &self.inner {
            RustAttrValue::Int(i) => i.to_string(),
            RustAttrValue::Float(f) => f.to_string(),
            RustAttrValue::Text(s) => s.clone(),
            RustAttrValue::Bool(b) => b.to_string(),
            RustAttrValue::FloatVec(v) => format!("{:?}", v),
            RustAttrValue::Bytes(b) => format!("{:?}", b),
            RustAttrValue::CompactText(cs) => cs.as_str().to_string(),
            RustAttrValue::SmallInt(i) => i.to_string(),
            RustAttrValue::CompressedText(cd) => {
                match cd.decompress_text() {
                    Ok(data) => data,
                    Err(_) => "compressed(error)".to_string()
                }
            },
            RustAttrValue::CompressedFloatVec(cd) => {
                match cd.decompress_float_vec() {
                    Ok(data) => format!("{:?}", data),
                    Err(_) => "compressed(error)".to_string()
                }
            },
        })
    }
    
    fn __eq__(&self, other: &PyAttrValue) -> bool {
        self.inner == other.inner
    }
    
    fn __hash__(&self) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        // Create a hash based on the variant and value
        match &self.inner {
            RustAttrValue::Int(i) => {
                0u8.hash(&mut hasher);
                i.hash(&mut hasher);
            },
            RustAttrValue::Float(f) => {
                1u8.hash(&mut hasher);
                f.to_bits().hash(&mut hasher);
            },
            RustAttrValue::Text(s) => {
                2u8.hash(&mut hasher);
                s.hash(&mut hasher);
            },
            RustAttrValue::Bool(b) => {
                3u8.hash(&mut hasher);
                b.hash(&mut hasher);
            },
            RustAttrValue::FloatVec(v) => {
                4u8.hash(&mut hasher);
                for f in v {
                    f.to_bits().hash(&mut hasher);
                }
            },
            RustAttrValue::Bytes(b) => {
                5u8.hash(&mut hasher);
                b.hash(&mut hasher);
            },
            RustAttrValue::CompactText(cs) => {
                6u8.hash(&mut hasher);
                cs.as_str().hash(&mut hasher);
            },
            RustAttrValue::SmallInt(i) => {
                7u8.hash(&mut hasher);
                i.hash(&mut hasher);
            },
            RustAttrValue::CompressedText(cd) => {
                8u8.hash(&mut hasher);
                if let Ok(text) = cd.decompress_text() {
                    text.hash(&mut hasher);
                }
            },
            RustAttrValue::CompressedFloatVec(cd) => {
                9u8.hash(&mut hasher);
                if let Ok(vec) = cd.decompress_float_vec() {
                    for f in vec {
                        f.to_bits().hash(&mut hasher);
                    }
                }
            },
        }
        hasher.finish()
    }
}

// ToPyObject implementation for PyAttrValue
impl pyo3::ToPyObject for PyAttrValue {
    fn to_object(&self, py: pyo3::Python<'_>) -> pyo3::PyObject {
        match &self.inner {
            RustAttrValue::Int(i) => i.to_object(py),
            RustAttrValue::Float(f) => f.to_object(py),
            RustAttrValue::Text(s) => s.to_object(py),
            RustAttrValue::Bool(b) => b.to_object(py),
            RustAttrValue::FloatVec(v) => v.to_object(py),
            RustAttrValue::Bytes(b) => b.to_object(py),
            RustAttrValue::CompactText(cs) => cs.as_str().to_object(py),
            RustAttrValue::SmallInt(i) => (*i as i64).to_object(py),
            RustAttrValue::CompressedText(cd) => {
                match cd.decompress_text() {
                    Ok(data) => data.to_object(py),
                    Err(_) => py.None()
                }
            },
            RustAttrValue::CompressedFloatVec(cd) => {
                match cd.decompress_float_vec() {
                    Ok(data) => data.to_object(py),
                    Err(_) => py.None()
                }
            },
        }
    }
}

/// Native result handle that keeps data in Rust
#[pyclass]
pub struct PyResultHandle {
    pub nodes: Vec<NodeId>,
    pub edges: Vec<EdgeId>,
    pub result_type: String,
}

#[pymethods]
impl PyResultHandle {
    #[getter]
    fn nodes(&self) -> Vec<NodeId> {
        self.nodes.clone()
    }
    
    #[getter]
    fn edges(&self) -> Vec<EdgeId> {
        self.edges.clone()
    }
    
    #[getter]
    fn result_type(&self) -> String {
        self.result_type.clone()
    }
    
    fn __repr__(&self) -> String {
        format!("ResultHandle(nodes={}, edges={}, type='{}')", 
                self.nodes.len(), self.edges.len(), self.result_type)
    }
}

/// Python wrapper for high-performance attribute collections
#[pyclass(unsendable)]
pub struct PyAttributeCollection {
    pub graph_ref: *const groggy::Graph, // Unsafe but controlled access
    pub node_ids: Vec<NodeId>,
    pub attr_name: String,
}

#[pymethods] 
impl PyAttributeCollection {
    /// Get count of attributes without converting
    fn len(&self) -> usize {
        self.node_ids.len()
    }
    
    /// Compute statistics directly in Rust
    fn compute_stats(&self, py: Python) -> PyResult<PyObject> {
        // Safe because we control the lifetime
        let graph = unsafe { &*self.graph_ref };
        
        let mut values = Vec::new();
        for &node_id in &self.node_ids {
            if let Ok(Some(attr)) = graph.get_node_attr(node_id, &self.attr_name) {
                values.push(attr);
            }
        }
        
        // Compute statistics in Rust
        {
            let dict = PyDict::new(py);
            
            // Count
            dict.set_item("count", values.len())?;
            
            // Type-specific statistics
            if !values.is_empty() {
                match &values[0] {
                    RustAttrValue::Int(_) => {
                        let int_values: Vec<i64> = values.iter()
                            .filter_map(|v| if let RustAttrValue::Int(i) = v { Some(*i) } else { None })
                            .collect();
                        
                        if !int_values.is_empty() {
                            let sum: i64 = int_values.iter().sum();
                            let avg = sum as f64 / int_values.len() as f64;
                            let min = *int_values.iter().min().unwrap();
                            let max = *int_values.iter().max().unwrap();
                            
                            dict.set_item("sum", sum)?;
                            dict.set_item("average", avg)?;
                            dict.set_item("min", min)?;
                            dict.set_item("max", max)?;
                        }
                    },
                    RustAttrValue::Float(_) => {
                        let float_values: Vec<f32> = values.iter()
                            .filter_map(|v| if let RustAttrValue::Float(f) = v { Some(*f) } else { None })
                            .collect();
                        
                        if !float_values.is_empty() {
                            let sum: f32 = float_values.iter().sum();
                            let avg = sum / float_values.len() as f32;
                            let min = float_values.iter().fold(f32::INFINITY, |a, &b| a.min(b));
                            let max = float_values.iter().fold(f32::NEG_INFINITY, |a, &b| a.max(b));
                            
                            dict.set_item("sum", sum)?;
                            dict.set_item("average", avg)?;
                            dict.set_item("min", min)?;
                            dict.set_item("max", max)?;
                        }
                    },
                    _ => {
                        // For other types, just provide count
                    }
                }
            }
            
            Ok(dict.to_object(py))
        }
    }
    
    /// Get sample values without converting all
    fn sample_values(&self, count: usize) -> PyResult<Vec<PyAttrValue>> {
        let graph = unsafe { &*self.graph_ref };
        let mut results = Vec::new();
        
        let step = if self.node_ids.len() <= count { 
            1 
        } else { 
            self.node_ids.len() / count 
        };
        
        for &node_id in self.node_ids.iter().step_by(step).take(count) {
            if let Ok(Some(attr)) = graph.get_node_attr(node_id, &self.attr_name) {
                results.push(PyAttrValue { inner: attr });
            }
        }
        
        Ok(results)
    }
}

// We'll add more types as needed during modularization


--- FILE: ffi/config.rs ---
//! FFI Configuration
//! 
//! This module provides Python bindings for Groggy configuration.

use pyo3::prelude::*;

// Placeholder for configuration FFI
// We'll implement this as needed during modularization


--- FILE: ffi/mod.rs ---
//! FFI Module Coordinator
//! 
//! This module coordinates all FFI submodules that provide Python bindings
//! for the Groggy graph library components.

// Core type wrappers and utilities
pub mod types;
pub mod config;
pub mod errors;

// Move existing utils here
pub mod utils;

// Core FFI bindings (mirror main project core/)
pub mod core;

// API FFI bindings (mirror main project api/)
pub mod api;

// Display FFI bindings (mirror main project display/)
pub mod display;

// Re-export commonly used FFI types
pub use types::*;
pub use errors::*;
pub use utils::*;


--- FILE: ffi/errors.rs ---
//! FFI Error Handling
//! 
//! This module provides error conversion between Rust and Python.

use pyo3::prelude::*;
use pyo3::exceptions::{PyValueError, PyRuntimeError, PyKeyError, PyIndexError, PyTypeError};
use groggy::GraphError;

/// Convert GraphError to Python exception
pub fn graph_error_to_py_err(error: GraphError) -> PyErr {
    // Use existing utility function
    crate::ffi::utils::graph_error_to_py_err(error)
}

// We'll add more error handling utilities as needed


--- FILE: ffi/utils.rs ---
use pyo3::prelude::*;
use pyo3::exceptions::{PyTypeError, PyValueError, PyRuntimeError};
use groggy::{AttrValue as RustAttrValue, GraphError};

/// Convert Python value to Rust AttrValue (reusing PyAttrValue conversion logic)
pub fn python_value_to_attr_value(value: &PyAny) -> PyResult<RustAttrValue> {
    // Fast path optimization: Check most common types first
    
    // Check booleans FIRST (Python bool is a subtype of int, so this must come before int check)
    if let Ok(b) = value.extract::<bool>() {
        return Ok(RustAttrValue::Bool(b));
    }
    
    // Check integers second (very common in benchmarks)
    if let Ok(i) = value.extract::<i64>() {
        return Ok(RustAttrValue::Int(i));
    }
    
    // Check strings third (also very common)
    if let Ok(s) = value.extract::<String>() {
        return Ok(RustAttrValue::Text(s));
    }
    
    // Check floats fourth
    if let Ok(f) = value.extract::<f64>() {
        return Ok(RustAttrValue::Float(f as f32));  // Convert f64 to f32
    }
    
    // Less common types
    if let Ok(f) = value.extract::<f32>() {
        return Ok(RustAttrValue::Float(f));
    } else if let Ok(vec) = value.extract::<Vec<f32>>() {
        return Ok(RustAttrValue::FloatVec(vec));
    } else if let Ok(vec) = value.extract::<Vec<f64>>() {
        // Convert Vec<f64> to Vec<f32>
        let f32_vec: Vec<f32> = vec.into_iter().map(|f| f as f32).collect();
        return Ok(RustAttrValue::FloatVec(f32_vec));
    } else if let Ok(bytes) = value.extract::<Vec<u8>>() {
        return Ok(RustAttrValue::Bytes(bytes))
    } else {
        Err(PyErr::new::<PyTypeError, _>(
            "Unsupported attribute value type"
        ))
    }
}

/// Convert Rust AttrValue to Python object
pub fn attr_value_to_python_value(py: Python, attr_value: &RustAttrValue) -> PyResult<PyObject> {
    let py_value = match attr_value {
        RustAttrValue::Int(i) => i.to_object(py),
        RustAttrValue::Float(f) => f.to_object(py),
        RustAttrValue::Text(s) => s.to_object(py),
        RustAttrValue::Bool(b) => b.to_object(py),
        RustAttrValue::FloatVec(vec) => vec.to_object(py),
        RustAttrValue::Bytes(bytes) => bytes.to_object(py),
        RustAttrValue::CompactText(compact_str) => compact_str.as_str().to_object(py),
        RustAttrValue::SmallInt(i) => i.to_object(py),
        RustAttrValue::CompressedText(_) => "compressed_text".to_object(py), // Placeholder
        RustAttrValue::CompressedFloatVec(_) => vec!["compressed_floats"].to_object(py), // Placeholder
    };
    Ok(py_value)
}

/// Convert Rust GraphError to Python exception
pub fn graph_error_to_py_err(error: GraphError) -> PyErr {
    match error {
        GraphError::NodeNotFound { node_id, operation, suggestion } => {
            PyErr::new::<PyValueError, _>(format!(
                "Node {} not found during {}. {}",
                node_id, operation, suggestion
            ))
        },
        GraphError::EdgeNotFound { edge_id, operation, suggestion } => {
            PyErr::new::<PyValueError, _>(format!(
                "Edge {} not found during {}. {}",
                edge_id, operation, suggestion
            ))
        },
        GraphError::InvalidInput(message) => {
            PyErr::new::<PyValueError, _>(message)
        },
        GraphError::NotImplemented { feature, tracking_issue } => {
            let mut message = format!("Feature '{}' is not yet implemented", feature);
            if let Some(issue) = tracking_issue {
                message.push_str(&format!(". See: {}", issue));
            }
            PyErr::new::<PyRuntimeError, _>(message)
        },
        _ => PyErr::new::<PyRuntimeError, _>(format!("Graph error: {}", error))
    }
}

--- FILE: ffi/core/traversal.rs ---
//! Traversal result types
//! 
//! Python bindings for traversal result structures.

use pyo3::prelude::*;
use groggy::{NodeId, EdgeId};

/// Result of a graph traversal operation
#[pyclass(name = "TraversalResult")]
pub struct PyTraversalResult {
    pub nodes: Vec<NodeId>,
    pub edges: Vec<EdgeId>,
    pub distances: Option<Vec<usize>>,
    pub traversal_type: String,
}

#[pymethods]
impl PyTraversalResult {
    #[getter]
    fn nodes(&self) -> Vec<NodeId> {
        self.nodes.clone()
    }
    
    #[getter] 
    fn edges(&self) -> Vec<EdgeId> {
        self.edges.clone()
    }
    
    #[getter]
    fn distances(&self) -> Option<Vec<usize>> {
        self.distances.clone()
    }
    
    #[getter]
    fn traversal_type(&self) -> String {
        self.traversal_type.clone()
    }
    
    fn __repr__(&self) -> String {
        format!("TraversalResult(nodes={}, edges={}, type='{}')", 
               self.nodes.len(), self.edges.len(), self.traversal_type)
    }
}

impl PyTraversalResult {
    pub fn new(nodes: Vec<NodeId>, edges: Vec<EdgeId>, distances: Option<Vec<usize>>, traversal_type: String) -> Self {
        Self {
            nodes,
            edges, 
            distances,
            traversal_type,
        }
    }
}

/// Result of an aggregation operation
#[pyclass(name = "AggregationResult")]
pub struct PyAggregationResult {
    pub value: f64,
    pub operation: String,
    pub attribute: String,
    pub count: usize,
}

#[pymethods]
impl PyAggregationResult {
    #[getter]
    fn value(&self) -> f64 {
        self.value
    }
    
    #[getter]
    fn operation(&self) -> String {
        self.operation.clone()
    }
    
    #[getter]
    fn attribute(&self) -> String {
        self.attribute.clone()
    }
    
    #[getter]
    fn count(&self) -> usize {
        self.count
    }
    
    fn __repr__(&self) -> String {
        format!("AggregationResult(value={}, operation='{}', attribute='{}')", 
               self.value, self.operation, self.attribute)
    }
}

impl PyAggregationResult {
    pub fn new(value: f64, operation: String, attribute: String, count: usize) -> Self {
        Self {
            value,
            operation,
            attribute,
            count,
        }
    }
}

/// Result of a grouped aggregation operation
#[pyclass(name = "GroupedAggregationResult")]
pub struct PyGroupedAggregationResult {
    pub groups: PyObject,
    pub operation: String,
    pub attribute: String,
}

#[pymethods]
impl PyGroupedAggregationResult {
    #[getter]
    fn groups(&self) -> PyObject {
        self.groups.clone()
    }
    
    #[getter]
    fn operation(&self) -> String {
        self.operation.clone()
    }
    
    #[getter]
    fn attribute(&self) -> String {
        self.attribute.clone()
    }
    
    fn __repr__(&self) -> String {
        format!("GroupedAggregationResult(operation='{}', attribute='{}')", 
               self.operation, self.attribute)
    }
}

impl PyGroupedAggregationResult {
    pub fn new(groups: PyObject, operation: String, attribute: String) -> Self {
        Self {
            groups,
            operation,
            attribute,
        }
    }
}

--- FILE: ffi/core/accessors.rs ---
//! Accessors FFI Bindings
//! 
//! Python bindings for smart indexing accessors.

use pyo3::prelude::*;
use pyo3::types::{PyDict, PySlice};
use pyo3::exceptions::{PyValueError, PyTypeError, PyRuntimeError, PyKeyError, PyIndexError, PyImportError, PyNotImplementedError};
use groggy::{NodeId, EdgeId};

// Import types from our FFI modules
use crate::ffi::api::graph::PyGraph;
use crate::ffi::core::subgraph::PySubgraph;

/// Wrapper for g.nodes that supports indexing syntax: g.nodes[id] -> NodeView
#[pyclass(name = "NodesAccessor")]
pub struct PyNodesAccessor {
    pub graph: Py<PyGraph>,
    /// Optional constraint: if Some, only these nodes are accessible
    pub constrained_nodes: Option<Vec<NodeId>>,
}

#[pymethods]
impl PyNodesAccessor {
    /// Support node access: g.nodes[0] -> NodeView, g.nodes[[0,1,2]] -> Subgraph, g.nodes[0:5] -> Subgraph
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {
        // Try to extract as single integer (existing behavior)
        if let Ok(node_id) = key.extract::<NodeId>() {
            // Check constraint first
            if let Some(ref constrained) = self.constrained_nodes {
                if !constrained.contains(&node_id) {
                    return Err(PyKeyError::new_err(format!("Node {} is not in this subgraph", node_id)));
                }
            }
            
            // Single node access - return NodeView
            let graph = self.graph.borrow(py);
            if !graph.has_node_internal(node_id) {
                return Err(PyKeyError::new_err(format!("Node {} does not exist", node_id)));
            }
            
            let node_view = PyGraph::create_node_view_internal(self.graph.clone(), py, node_id)?;
            return Ok(node_view.to_object(py));
        }
        
        // Try to extract as list of integers (batch access)
        if let Ok(node_ids) = key.extract::<Vec<NodeId>>() {
            // Batch node access - return Subgraph
            let mut graph = self.graph.borrow_mut(py);
            
            // Validate all nodes exist
            for &node_id in &node_ids {
                if !graph.has_node_internal(node_id) {
                    return Err(PyKeyError::new_err(format!("Node {} does not exist", node_id)));
                }
            }
            
            // 🚀 PERFORMANCE FIX: Use core columnar topology instead of O(E) FFI algorithm
            let node_set: std::collections::HashSet<NodeId> = node_ids.iter().copied().collect();
            let (edge_ids, sources, targets) = graph.inner.get_columnar_topology();
            let mut induced_edges = Vec::new();
            
            // O(k) where k = active edges, much better than O(E)
            for i in 0..edge_ids.len() {
                let edge_id = edge_ids[i];
                let source = sources[i];
                let target = targets[i];
                
                // O(1) HashSet lookups
                if node_set.contains(&source) && node_set.contains(&target) {
                    induced_edges.push(edge_id);
                }
            }
            
            // Create and return Subgraph
            let subgraph = PySubgraph::new(
                node_ids,
                induced_edges,
                "node_batch_selection".to_string(),
                Some(self.graph.clone()),
            );
            
            return Ok(Py::new(py, subgraph)?.to_object(py));
        }
        
        // Try to extract as slice (slice access)
        if let Ok(slice) = key.downcast::<PySlice>() {
            let mut graph = self.graph.borrow_mut(py);
            let all_node_ids = graph.inner.node_ids();
            
            // Convert slice to indices
            let slice_info = slice.indices(all_node_ids.len() as i64)?;
            let start = slice_info.start as usize;
            let stop = slice_info.stop as usize;
            let step = slice_info.step as usize;
            
            // Extract nodes based on slice
            let mut selected_nodes = Vec::new();
            let mut i = start;
            while i < stop && i < all_node_ids.len() {
                selected_nodes.push(all_node_ids[i]);
                i += step;
            }
            
            // 🚀 PERFORMANCE FIX: Use core columnar topology instead of O(E) FFI algorithm  
            let selected_node_set: std::collections::HashSet<NodeId> = selected_nodes.iter().copied().collect();
            let (edge_ids, sources, targets) = graph.inner.get_columnar_topology();
            let mut induced_edges = Vec::new();
            
            // O(k) where k = active edges, much better than O(E)
            for i in 0..edge_ids.len() {
                let edge_id = edge_ids[i];
                let source = sources[i];
                let target = targets[i];
                
                // O(1) HashSet lookups
                if selected_node_set.contains(&source) && selected_node_set.contains(&target) {
                    induced_edges.push(edge_id);
                }
            }
            
            // Create and return Subgraph
            let subgraph = PySubgraph::new(
                selected_nodes,
                induced_edges,
                "node_slice_selection".to_string(),
                Some(self.graph.clone()),
            );
            
            return Ok(Py::new(py, subgraph)?.to_object(py));
        }
        
        // If none of the above worked, return error
        Err(PyTypeError::new_err("Node index must be int, list of ints, or slice"))
    }
    
    /// Support iteration: for node_id in g.nodes
    fn __iter__(&self, py: Python) -> PyResult<PyObject> {
        let graph = self.graph.borrow(py);
        let node_ids = graph.get_node_ids_array(py)?;
        // Return the GraphArray directly - Python will handle iteration
        Ok(node_ids.to_object(py))
    }
    
    /// Support len(g.nodes)
    fn __len__(&self, py: Python) -> PyResult<usize> {
        if let Some(ref constrained) = self.constrained_nodes {
            Ok(constrained.len())
        } else {
            let graph = self.graph.borrow(py);
            Ok(graph.get_node_count())
        }
    }
    
    /// String representation
    fn __str__(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        let count = graph.get_node_count();
        Ok(format!("NodesAccessor({} nodes)", count))
    }
    
    /// Get table view of nodes (GraphTable with node attributes)
    fn table(&self, py: Python) -> PyResult<PyObject> {
        // Import the Python GraphTable class
        let groggy = py.import("groggy")?;
        let graph_table_class = groggy.getattr("GraphTable")?;
        
        // Get the underlying graph
        let graph = self.graph.borrow(py);
        
        // Determine node list based on constraints
        let node_data = if let Some(ref constrained) = self.constrained_nodes {
            // Subgraph case: use constrained nodes
            constrained.clone()
        } else {
            // Full graph case: get all node IDs from the graph
            // Use the inner graph's node_ids method directly
            graph.inner.node_ids()
        };
        
        // Create GraphTable with nodes data source
        let table = graph_table_class.call1((node_data, "nodes", self.graph.clone()))?;
        Ok(table.to_object(py))
    }
}

/// Wrapper for g.edges that supports indexing syntax: g.edges[id] -> EdgeView  
#[pyclass(name = "EdgesAccessor")]
pub struct PyEdgesAccessor {
    pub graph: Py<PyGraph>,
    /// Optional constraint: if Some, only these edges are accessible
    pub constrained_edges: Option<Vec<EdgeId>>,
}

#[pymethods]
impl PyEdgesAccessor {
    /// Support edge access: g.edges[0] -> EdgeView, g.edges[[0,1,2]] -> Subgraph, g.edges[0:5] -> Subgraph
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {
        // Try to extract as single integer (existing behavior)
        if let Ok(edge_id) = key.extract::<EdgeId>() {
            // Check constraint first
            if let Some(ref constrained) = self.constrained_edges {
                if !constrained.contains(&edge_id) {
                    return Err(PyKeyError::new_err(format!("Edge {} is not in this subgraph", edge_id)));
                }
            }
            
            // Single edge access - return EdgeView
            let graph = self.graph.borrow(py);
            if !graph.has_edge_internal(edge_id) {
                return Err(PyKeyError::new_err(format!("Edge {} does not exist", edge_id)));
            }
            
            let edge_view = PyGraph::create_edge_view_internal(self.graph.clone(), py, edge_id)?;
            return Ok(edge_view.to_object(py));
        }
        
        // Try to extract as list of integers (batch access)
        if let Ok(edge_ids) = key.extract::<Vec<EdgeId>>() {
            // Batch edge access - return Subgraph with these edges + their endpoints
            let graph = self.graph.borrow(py);
            
            // Validate all edges exist
            for &edge_id in &edge_ids {
                if !graph.has_edge_internal(edge_id) {
                    return Err(PyKeyError::new_err(format!("Edge {} does not exist", edge_id)));
                }
            }
            
            // Get all endpoint nodes from these edges
            let mut endpoint_nodes = std::collections::HashSet::new();
            for &edge_id in &edge_ids {
                if let Ok((source, target)) = graph.inner.edge_endpoints(edge_id) {
                    endpoint_nodes.insert(source);
                    endpoint_nodes.insert(target);
                }
            }
            
            // Create and return Subgraph
            let subgraph = PySubgraph::new(
                endpoint_nodes.into_iter().collect(),
                edge_ids,
                "edge_batch_selection".to_string(),
                Some(self.graph.clone()),
            );
            
            return Ok(Py::new(py, subgraph)?.to_object(py));
        }
        
        // Try to extract as slice (slice access)
        if let Ok(slice) = key.downcast::<PySlice>() {
            let graph = self.graph.borrow(py);
            let all_edge_ids = graph.inner.edge_ids();
            
            // Convert slice to indices
            let slice_info = slice.indices(all_edge_ids.len() as i64)?;
            let start = slice_info.start as usize;
            let stop = slice_info.stop as usize;
            let step = slice_info.step as usize;
            
            // Extract edges based on slice
            let mut selected_edges = Vec::new();
            let mut i = start;
            while i < stop && i < all_edge_ids.len() {
                selected_edges.push(all_edge_ids[i]);
                i += step;
            }
            
            // Get all endpoint nodes from selected edges
            let mut endpoint_nodes = std::collections::HashSet::new();
            for &edge_id in &selected_edges {
                if let Ok((source, target)) = graph.inner.edge_endpoints(edge_id) {
                    endpoint_nodes.insert(source);
                    endpoint_nodes.insert(target);
                }
            }
            
            // Create and return Subgraph
            let subgraph = PySubgraph::new(
                endpoint_nodes.into_iter().collect(),
                selected_edges,
                "edge_slice_selection".to_string(),
                Some(self.graph.clone()),
            );
            
            return Ok(Py::new(py, subgraph)?.to_object(py));
        }
        
        // If none of the above worked, return error
        Err(PyTypeError::new_err("Edge index must be int, list of ints, or slice"))
    }
    
    /// Support iteration: for edge_id in g.edges
    fn __iter__(&self, py: Python) -> PyResult<PyObject> {
        let graph = self.graph.borrow(py);
        let edge_ids = graph.get_edge_ids_array(py)?;
        // Return the GraphArray directly - Python will handle iteration
        Ok(edge_ids.to_object(py))
    }
    
    /// Support len(g.edges)
    fn __len__(&self, py: Python) -> PyResult<usize> {
        if let Some(ref constrained) = self.constrained_edges {
            Ok(constrained.len())
        } else {
            let graph = self.graph.borrow(py);
            Ok(graph.get_edge_count())
        }
    }
    
    /// String representation
    fn __str__(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        let count = graph.get_edge_count();
        Ok(format!("EdgesAccessor({} edges)", count))
    }
    
    /// Get table view of edges (GraphTable with edge attributes)
    fn table(&self, py: Python) -> PyResult<PyObject> {
        // Import the Python GraphTable class
        let groggy = py.import("groggy")?;
        let graph_table_class = groggy.getattr("GraphTable")?;
        
        // Get the underlying graph
        let graph = self.graph.borrow(py);
        
        // Determine edge list based on constraints
        let edge_data = if let Some(ref constrained) = self.constrained_edges {
            // Subgraph case: use constrained edges
            constrained.clone()
        } else {
            // Full graph case: get all edge IDs from the graph
            graph.inner.edge_ids()
        };
        
        // Create GraphTable with edges data source
        let table = graph_table_class.call1((edge_data, "edges", self.graph.clone()))?;
        Ok(table.to_object(py))
    }
}


--- FILE: ffi/core/attributes.rs ---
//! Attributes FFI Bindings
//! 
//! Python bindings for attribute access operations.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyValueError, PyRuntimeError};
use groggy::{NodeId, EdgeId, AttrName, AttrValue as RustAttrValue};
use crate::ffi::types::PyAttrValue;
use crate::ffi::utils::{graph_error_to_py_err, attr_value_to_python_value, python_value_to_attr_value};
use crate::ffi::core::array::PyGraphArray;

/// Attribute management utilities for graphs
pub struct AttributeManager;

impl AttributeManager {
    /// Set node attribute
    pub fn set_node_attribute(graph: &mut groggy::Graph, node: NodeId, attr: AttrName, value: &PyAttrValue) -> PyResult<()> {
        graph.set_node_attr(node, attr, value.inner.clone())
            .map_err(graph_error_to_py_err)
    }
    
    /// Set edge attribute
    pub fn set_edge_attribute(graph: &mut groggy::Graph, edge: EdgeId, attr: AttrName, value: &PyAttrValue) -> PyResult<()> {
        graph.set_edge_attr(edge, attr, value.inner.clone())
            .map_err(graph_error_to_py_err)
    }
    
    /// Get node attribute
    pub fn get_node_attribute(graph: &groggy::Graph, node: NodeId, attr: AttrName) -> PyResult<Option<PyAttrValue>> {
        match graph.get_node_attr(node, &attr) {
            Ok(Some(value)) => Ok(Some(PyAttrValue { inner: value })),
            Ok(None) => Ok(None),
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Get edge attribute
    pub fn get_edge_attribute(graph: &groggy::Graph, edge: EdgeId, attr: AttrName) -> PyResult<Option<PyAttrValue>> {
        match graph.get_edge_attr(edge, &attr) {
            Ok(Some(value)) => Ok(Some(PyAttrValue { inner: value })),
            Ok(None) => Ok(None),
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Get complete attribute column for ALL nodes (optimized for table() method)
    pub fn get_node_attribute_column(graph: &groggy::Graph, py: Python, attr_name: &str) -> PyResult<Py<PyGraphArray>> {
        match graph._get_node_attribute_column(&attr_name.to_string()) {
            Ok(values) => {
                // Convert Option<AttrValue> vector to AttrValue vector (convert None to appropriate AttrValue)
                let attr_values: Vec<RustAttrValue> = values.into_iter()
                    .map(|opt_val| opt_val.unwrap_or(RustAttrValue::Int(0))) // Use default for None values
                    .collect();
                
                // Create GraphArray from the attribute values
                let graph_array = groggy::core::array::GraphArray::from_vec(attr_values);
                
                // Wrap in Python GraphArray
                let py_graph_array = PyGraphArray { inner: graph_array };
                Ok(Py::new(py, py_graph_array)?)
            }
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Get complete attribute column for ALL edges (optimized for edge table() method)
    pub fn get_edge_attribute_column(graph: &groggy::Graph, py: Python, attr_name: &str) -> PyResult<Vec<PyObject>> {
        match graph._get_edge_attribute_column(&attr_name.to_string()) {
            Ok(values) => {
                let mut py_values = Vec::with_capacity(values.len());
                for value in values {
                    match value {
                        Some(attr_value) => py_values.push(attr_value_to_python_value(py, &attr_value)?),
                        None => py_values.push(py.None()),
                    }
                }
                Ok(py_values)
            }
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Get attribute column for specific nodes (optimized for subgraph tables)
    pub fn get_node_attributes_for_nodes(graph: &groggy::Graph, py: Python, node_ids: &[NodeId], attr_name: &str) -> PyResult<Vec<PyObject>> {
        match graph._get_node_attributes_for_nodes(node_ids, &attr_name.to_string()) {
            Ok(values) => {
                let mut py_values = Vec::with_capacity(values.len());
                for value in values {
                    match value {
                        Some(attr_value) => py_values.push(attr_value_to_python_value(py, &attr_value)?),
                        None => py_values.push(py.None()),
                    }
                }
                Ok(py_values)
            }
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Set node attributes from dictionary
    pub fn set_node_attributes_from_dict(graph: &mut groggy::Graph, node_id: NodeId, attrs: &PyDict) -> PyResult<()> {
        for (key, value) in attrs.iter() {
            let attr_name: String = key.extract()?;
            let attr_value = python_value_to_attr_value(value)?;
            graph.set_node_attr(node_id, attr_name, attr_value)
                .map_err(graph_error_to_py_err)?;
        }
        Ok(())
    }
    
    /// Set edge attributes from dictionary
    pub fn set_edge_attributes_from_dict(graph: &mut groggy::Graph, edge_id: EdgeId, attrs: &PyDict) -> PyResult<()> {
        for (key, value) in attrs.iter() {
            let attr_name: String = key.extract()?;
            let attr_value = python_value_to_attr_value(value)?;
            graph.set_edge_attr(edge_id, attr_name, attr_value)
                .map_err(graph_error_to_py_err)?;
        }
        Ok(())
    }
    
    /// Get all node attributes as dictionary
    pub fn get_node_attributes_dict(graph: &groggy::Graph, py: Python, node_id: NodeId) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        
        // Get all attributes for this node from the core graph
        match graph.get_node_attrs(node_id) {
            Ok(attrs) => {
                for (attr_name, attr_value) in attrs {
                    let py_value = attr_value_to_python_value(py, &attr_value)?;
                    dict.set_item(attr_name, py_value)?;
                }
            }
            Err(e) => return Err(graph_error_to_py_err(e)),
        }
        
        Ok(dict.to_object(py))
    }
    
    /// Get all edge attributes as dictionary
    pub fn get_edge_attributes_dict(graph: &groggy::Graph, py: Python, edge_id: EdgeId) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        
        // Get all attributes for this edge from the core graph
        match graph.get_edge_attrs(edge_id) {
            Ok(attrs) => {
                for (attr_name, attr_value) in attrs {
                    let py_value = attr_value_to_python_value(py, &attr_value)?;
                    dict.set_item(attr_name, py_value)?;
                }
            }
            Err(e) => return Err(graph_error_to_py_err(e)),
        }
        
        Ok(dict.to_object(py))
    }
    
    /// Set bulk node attributes (for performance optimization)
    pub fn set_node_attribute_bulk(graph: &mut groggy::Graph, attr_name: &str, attr_value: RustAttrValue, node_ids: &[NodeId]) -> PyResult<()> {
        for &node_id in node_ids {
            graph.set_node_attr(node_id, attr_name.to_string(), attr_value.clone())
                .map_err(graph_error_to_py_err)?;
        }
        Ok(())
    }
    
    /// Set bulk edge attributes (for performance optimization)
    pub fn set_edge_attribute_bulk(graph: &mut groggy::Graph, attr_name: &str, attr_value: RustAttrValue, edge_ids: &[EdgeId]) -> PyResult<()> {
        for &edge_id in edge_ids {
            graph.set_edge_attr(edge_id, attr_name.to_string(), attr_value.clone())
                .map_err(graph_error_to_py_err)?;
        }
        Ok(())
    }
}


--- FILE: ffi/core/query.rs ---
//! Query FFI Bindings
//! 
//! Python bindings for query and filter operations.

use pyo3::prelude::*;
use pyo3::exceptions::{PyValueError, PyTypeError, PyRuntimeError, PyKeyError, PyIndexError, PyImportError, PyNotImplementedError};
use groggy::{NodeId, EdgeId, AttrName};
use groggy::core::query::{AttributeFilter, NodeFilter, EdgeFilter};

// Import types from our FFI modules
use crate::ffi::types::PyAttrValue;

/// Python wrapper for AttributeFilter
#[pyclass(name = "AttributeFilter")]
#[derive(Clone)]
pub struct PyAttributeFilter {
    pub inner: AttributeFilter,
}

#[pymethods]
impl PyAttributeFilter {
    #[staticmethod]
    fn equals(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::Equals(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn greater_than(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::GreaterThan(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn less_than(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::LessThan(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn not_equals(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::NotEquals(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn greater_than_or_equal(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::GreaterThanOrEqual(value.inner.clone()) }
    }
    
    #[staticmethod]
    fn less_than_or_equal(value: &PyAttrValue) -> Self {
        Self { inner: AttributeFilter::LessThanOrEqual(value.inner.clone()) }
    }
}

/// Python wrapper for NodeFilter
#[pyclass(name = "NodeFilter")]
#[derive(Clone)]
pub struct PyNodeFilter {
    pub inner: NodeFilter,
}

#[pymethods]
impl PyNodeFilter {
    #[staticmethod]
    fn has_attribute(name: AttrName) -> Self {
        Self { inner: NodeFilter::HasAttribute { name } }
    }
    
    #[staticmethod]
    fn attribute_equals(name: AttrName, value: &PyAttrValue) -> Self {
        Self { 
            inner: NodeFilter::AttributeEquals { 
                name, 
                value: value.inner.clone() 
            } 
        }
    }
    
    #[staticmethod]
    fn attribute_filter(name: AttrName, filter: &PyAttributeFilter) -> Self {
        Self { 
            inner: NodeFilter::AttributeFilter { 
                name, 
                filter: filter.inner.clone() 
            } 
        }
    }
    
    #[staticmethod]
    fn and_filters(filters: Vec<PyRef<PyNodeFilter>>) -> Self {
        let rust_filters: Vec<NodeFilter> = filters.iter()
            .map(|f| f.inner.clone())
            .collect();
        Self { inner: NodeFilter::And(rust_filters) }
    }
    
    #[staticmethod]
    fn or_filters(filters: Vec<PyRef<PyNodeFilter>>) -> Self {
        let rust_filters: Vec<NodeFilter> = filters.iter()
            .map(|f| f.inner.clone())
            .collect();
        Self { inner: NodeFilter::Or(rust_filters) }
    }
    
    #[staticmethod]
    fn not_filter(filter: &PyNodeFilter) -> Self {
        Self { inner: NodeFilter::Not(Box::new(filter.inner.clone())) }
    }
}

/// Python wrapper for EdgeFilter
#[pyclass(name = "EdgeFilter")]
#[derive(Clone)]
pub struct PyEdgeFilter {
    pub inner: EdgeFilter,
}

#[pymethods]
impl PyEdgeFilter {
    #[staticmethod]
    fn has_attribute(name: AttrName) -> Self {
        Self { inner: EdgeFilter::HasAttribute { name } }
    }
    
    #[staticmethod]
    fn attribute_equals(name: AttrName, value: &PyAttrValue) -> Self {
        Self { 
            inner: EdgeFilter::AttributeEquals { 
                name, 
                value: value.inner.clone() 
            } 
        }
    }
    
    #[staticmethod]
    fn attribute_filter(name: AttrName, filter: &PyAttributeFilter) -> Self {
        Self { 
            inner: EdgeFilter::AttributeFilter { 
                name, 
                filter: filter.inner.clone() 
            } 
        }
    }
    
    #[staticmethod]
    fn and_filters(filters: Vec<PyRef<PyEdgeFilter>>) -> Self {
        let rust_filters: Vec<EdgeFilter> = filters.iter()
            .map(|f| f.inner.clone())
            .collect();
        Self { inner: EdgeFilter::And(rust_filters) }
    }
    
    #[staticmethod]
    fn or_filters(filters: Vec<PyRef<PyEdgeFilter>>) -> Self {
        let rust_filters: Vec<EdgeFilter> = filters.iter()
            .map(|f| f.inner.clone())
            .collect();
        Self { inner: EdgeFilter::Or(rust_filters) }
    }
    
    #[staticmethod]
    fn not_filter(filter: &PyEdgeFilter) -> Self {
        Self { inner: EdgeFilter::Not(Box::new(filter.inner.clone())) }
    }
}

/// Python wrapper for TraversalResult
#[pyclass(name = "TraversalResult")]
pub struct PyTraversalResult {
    pub nodes: Vec<NodeId>,
    pub edges: Vec<EdgeId>,
}

#[pymethods]
impl PyTraversalResult {
    #[getter]
    fn nodes(&self) -> Vec<NodeId> {
        self.nodes.clone()
    }
    
    #[getter]
    fn edges(&self) -> Vec<EdgeId> {
        self.edges.clone()  
    }
    
    #[getter]
    fn algorithm(&self) -> String {
        "NotImplemented".to_string()
    }
}

/// Python wrapper for AggregationResult
#[pyclass(name = "AggregationResult")]
pub struct PyAggregationResult {
    pub value: f64,
}

#[pymethods]
impl PyAggregationResult {
    #[getter]
    fn value(&self) -> f64 {
        self.value
    }
    
    fn __repr__(&self) -> String {
        format!("AggregationResult({})", self.value)
    }
}

/// Python wrapper for GroupedAggregationResult
#[pyclass(name = "GroupedAggregationResult")]
pub struct PyGroupedAggregationResult {
    pub value: PyObject,
}

#[pymethods]
impl PyGroupedAggregationResult {
    #[getter]
    fn value(&self) -> PyObject {
        self.value.clone()
    }
    
    fn __repr__(&self) -> String {
        "GroupedAggregationResult(...)".to_string()
    }
}


--- FILE: ffi/core/mod.rs ---
//! Core FFI Module Coordinator
//! 
//! This module coordinates FFI bindings for all core Groggy components.

// Core component FFI bindings
pub mod array;
pub mod subgraph;  
pub mod query;
pub mod history;
pub mod attributes;
pub mod accessors;
pub mod views;
pub mod traversal;

// Re-export core FFI types
pub use array::*;
pub use subgraph::*;
pub use query::*;
pub use history::*;
pub use attributes::*;
pub use accessors::*;
pub use views::*;
pub use traversal::*;


--- FILE: ffi/core/history.rs ---
//! History FFI Bindings
//! 
//! Python bindings for version control and history operations.

use pyo3::prelude::*;
use groggy::{NodeId, EdgeId, StateId};
use groggy::core::history::{Commit, HistoryStatistics};
use groggy::core::ref_manager::BranchInfo;

/// Python wrapper for Commit
#[pyclass(name = "Commit")]
#[derive(Clone)]
pub struct PyCommit {
    pub inner: std::sync::Arc<Commit>,
}

#[pymethods]
impl PyCommit {
    #[getter]
    fn id(&self) -> StateId {
        self.inner.id
    }
    
    #[getter]
    fn parents(&self) -> Vec<StateId> {
        self.inner.parents.clone()
    }
    
    #[getter]
    fn message(&self) -> String {
        self.inner.message.clone()
    }
    
    #[getter]
    fn author(&self) -> String {
        self.inner.author.clone()
    }
    
    #[getter]
    fn timestamp(&self) -> u64 {
        self.inner.timestamp
    }
    
    fn is_root(&self) -> bool {
        self.inner.is_root()
    }
    
    fn is_merge(&self) -> bool {
        self.inner.is_merge()
    }
    
    fn __repr__(&self) -> String {
        format!("Commit(id={}, message='{}', author='{}')", 
                self.inner.id, self.inner.message, self.inner.author)
    }
}

/// Python wrapper for BranchInfo
#[pyclass(name = "BranchInfo")]
#[derive(Clone)]
pub struct PyBranchInfo {
    pub inner: BranchInfo,
}

#[pymethods]
impl PyBranchInfo {
    #[getter]
    fn name(&self) -> String {
        self.inner.name.clone()
    }
    
    #[getter]
    fn head(&self) -> StateId {
        self.inner.head
    }
    
    #[getter]
    fn is_default(&self) -> bool {
        self.inner.is_default
    }
    
    #[getter]
    fn is_current(&self) -> bool {
        self.inner.is_current
    }
    
    fn __repr__(&self) -> String {
        format!("BranchInfo(name='{}', head={})", 
                self.inner.name, self.inner.head)
    }
}

/// Python wrapper for HistoryStatistics
#[pyclass(name = "HistoryStatistics")]
#[derive(Clone)]
pub struct PyHistoryStatistics {
    pub inner: HistoryStatistics,
}

#[pymethods]
impl PyHistoryStatistics {
    #[getter]
    fn total_commits(&self) -> usize {
        self.inner.total_commits
    }
    
    #[getter]
    fn total_branches(&self) -> usize {
        self.inner.total_branches
    }
    
    #[getter]
    fn total_tags(&self) -> usize {
        self.inner.total_tags
    }
    
    #[getter]
    fn storage_efficiency(&self) -> f64 {
        self.inner.storage_efficiency
    }
    
    #[getter]
    fn oldest_commit_age(&self) -> u64 {
        self.inner.oldest_commit_age
    }
    
    #[getter]
    fn newest_commit_age(&self) -> u64 {
        self.inner.newest_commit_age
    }
    
    fn __repr__(&self) -> String {
        format!("HistoryStatistics(commits={}, branches={}, efficiency={:.2})", 
                self.inner.total_commits, self.inner.total_branches, self.inner.storage_efficiency)
    }
}

/// Python wrapper for HistoricalView
#[pyclass(name = "HistoricalView")]
pub struct PyHistoricalView {
    // Store the state ID that this view represents
    pub state_id: StateId,
    // For actual graph operations, we'll need to call back to the graph
    // In a full implementation, this would contain a HistoricalView<'graph>
}

#[pymethods]
impl PyHistoricalView {
    #[getter]
    fn state_id(&self) -> StateId {
        self.state_id
    }
    
    /// Get nodes from this historical state
    /// Note: This is a simplified implementation. In practice, you'd need
    /// access to the graph to reconstruct the state.
    fn get_node_ids(&self) -> PyResult<Vec<NodeId>> {
        // Placeholder - in real implementation, would query graph state
        Ok(Vec::new())
    }
    
    /// Get edges from this historical state
    fn get_edge_ids(&self) -> PyResult<Vec<EdgeId>> {
        // Placeholder - in real implementation, would query graph state
        Ok(Vec::new())
    }
    
    fn __repr__(&self) -> String {
        format!("HistoricalView(state_id={})", self.state_id)
    }
}


--- FILE: ffi/core/views.rs ---
//! Views FFI Bindings
//! 
//! Python bindings for NodeView and EdgeView components.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyValueError, PyTypeError, PyRuntimeError, PyKeyError, PyIndexError, PyImportError, PyNotImplementedError};
use groggy::{NodeId, EdgeId, AttrValue};

// Import types from our FFI modules
use crate::ffi::api::graph::PyGraph;
use crate::ffi::types::PyAttrValue;

/// A view of a specific node with access to its attributes
#[pyclass(name = "NodeView")]
pub struct PyNodeView {
    pub graph: Py<PyGraph>,
    pub node_id: NodeId,
}

#[pymethods]
impl PyNodeView {
    /// Get node attribute value
    fn __getitem__(&self, py: Python, key: &str) -> PyResult<PyAttrValue> {
        let graph = self.graph.borrow(py);
        match graph.get_node_attribute(self.node_id, key.to_string())? {
            Some(value) => Ok(value),
            None => Err(PyKeyError::new_err(format!("Attribute '{}' not found on node {}", key, self.node_id))),
        }
    }
    
    /// Set node attribute value (chainable)
    fn __setitem__(&mut self, py: Python, key: &str, value: PyAttrValue) -> PyResult<()> {
        let mut graph = self.graph.borrow_mut(py);
        graph.set_node_attribute(self.node_id, key.to_string(), &value)?;
        Ok(())
    }
    
    /// Get node ID
    #[getter]
    fn id(&self) -> PyResult<NodeId> {
        Ok(self.node_id)
    }
    
    /// Check if attribute exists
    fn __contains__(&self, py: Python, key: &str) -> PyResult<bool> {
        let graph = self.graph.borrow(py);
        Ok(graph.has_node_attribute(self.node_id, key))
    }
    
    /// Get all attribute keys
    fn keys(&self, py: Python) -> PyResult<Vec<String>> {
        let graph = self.graph.borrow(py);
        Ok(graph.node_attribute_keys(self.node_id))
    }
    
    /// Get all attribute values
    fn values(&self, py: Python) -> PyResult<Vec<PyAttrValue>> {
        let graph = self.graph.borrow(py);
        // 🚀 PERFORMANCE FIX: Use batch attribute access instead of manual loops
        let node_attrs = graph.inner.get_node_attrs(self.node_id)
            .map_err(|e| PyRuntimeError::new_err(format!("Failed to get node attributes: {}", e)))?;
        
        let values = node_attrs.into_iter()
            .map(|(_, value)| PyAttrValue::from_attr_value(value))
            .collect();
        Ok(values)
    }
    
    /// Get neighbors of this node
    fn neighbors(&self, py: Python) -> PyResult<Vec<NodeId>> {
        let graph = self.graph.borrow(py);
        graph.inner.neighbors(self.node_id)
            .map_err(|e| pyo3::exceptions::PyRuntimeError::new_err(format!("Failed to get neighbors: {}", e)))
    }
    
    /// Get all attribute items as (key, value) pairs
    fn items(&self, py: Python) -> PyResult<Vec<(String, PyAttrValue)>> {
        let graph = self.graph.borrow(py);
        // 🚀 PERFORMANCE FIX: Use batch attribute access instead of manual loops
        let node_attrs = graph.inner.get_node_attrs(self.node_id)
            .map_err(|e| PyRuntimeError::new_err(format!("Failed to get node attributes: {}", e)))?;
        
        let items = node_attrs.into_iter()
            .map(|(key, value)| (key, PyAttrValue::from_attr_value(value)))
            .collect();
        Ok(items)
    }
    
    /// Update multiple attributes at once (chainable)
    fn update(&mut self, py: Python, attributes: &PyDict) -> PyResult<PyObject> {
        let mut graph = self.graph.borrow_mut(py);
        
        for (key, value) in attributes.iter() {
            let key_str = key.extract::<String>()?;
            let attr_value = PyAttrValue::extract(value)?.to_attr_value();
            graph.set_node_attribute(self.node_id, key_str, &PyAttrValue::from_attr_value(attr_value))?;
        }
        
        // Return self for chaining
        Ok(self.clone().into_py(py))
    }
    
    /// String representation
    fn __str__(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        let keys = graph.node_attribute_keys(self.node_id);
        
        if keys.is_empty() {
            Ok(format!("NodeView({})", self.node_id))
        } else {
            let mut attr_parts = Vec::new();
            for key in keys.iter().take(3) {  // Show first 3 attributes
                if let Ok(Some(value)) = graph.get_node_attribute(self.node_id, key.clone()) {
                    attr_parts.push(format!("{}={}", key, value.__str__()?));
                }
            }
            
            let attr_str = if keys.len() > 3 {
                format!("{}, ...", attr_parts.join(", "))
            } else {
                attr_parts.join(", ")
            };
            
            Ok(format!("NodeView({}, {})", self.node_id, attr_str))
        }
    }
    
    /// Get as dictionary
    fn to_dict(&self, py: Python) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        let graph = self.graph.borrow(py);
        let keys = graph.node_attribute_keys(self.node_id);
        
        for key in keys {
            if let Some(value) = graph.get_node_attribute(self.node_id, key.clone()).ok().flatten() {
                dict.set_item(key, value)?;
            }
        }
        
        Ok(dict.to_object(py))
    }
}

impl Clone for PyNodeView {
    fn clone(&self) -> Self {
        PyNodeView {
            graph: self.graph.clone(),
            node_id: self.node_id,
        }
    }
}

/// A view of a specific edge with access to its attributes and endpoints
#[pyclass(name = "EdgeView")]
pub struct PyEdgeView {
    pub graph: Py<PyGraph>,
    pub edge_id: EdgeId,
}

#[pymethods]
impl PyEdgeView {
    /// Get edge attribute value
    fn __getitem__(&self, py: Python, key: &str) -> PyResult<PyAttrValue> {
        let graph = self.graph.borrow(py);
        match graph.get_edge_attribute(self.edge_id, key.to_string())? {
            Some(value) => Ok(value),
            None => Err(PyKeyError::new_err(format!("Attribute '{}' not found on edge {}", key, self.edge_id))),
        }
    }
    
    /// Set edge attribute value (chainable)
    fn __setitem__(&mut self, py: Python, key: &str, value: PyAttrValue) -> PyResult<()> {
        let mut graph = self.graph.borrow_mut(py);
        graph.set_edge_attribute(self.edge_id, key.to_string(), &value)?;
        Ok(())
    }
    
    /// Get edge ID
    #[getter]
    fn id(&self) -> PyResult<EdgeId> {
        Ok(self.edge_id)
    }
    
    /// Get source node ID
    #[getter]
    fn source(&self, py: Python) -> PyResult<NodeId> {
        let graph = self.graph.borrow(py);
        let (source, _) = graph.inner.edge_endpoints(self.edge_id)
            .map_err(|e| PyRuntimeError::new_err(format!("Failed to get edge endpoints: {}", e)))?;
        Ok(source)
    }
    
    /// Get target node ID  
    #[getter]
    fn target(&self, py: Python) -> PyResult<NodeId> {
        let graph = self.graph.borrow(py);
        let (_, target) = graph.inner.edge_endpoints(self.edge_id)
            .map_err(|e| PyRuntimeError::new_err(format!("Failed to get edge endpoints: {}", e)))?;
        Ok(target)
    }
    
    /// Get both endpoints as (source, target) tuple
    fn endpoints(&self, py: Python) -> PyResult<(NodeId, NodeId)> {
        let graph = self.graph.borrow(py);
        let endpoints = graph.inner.edge_endpoints(self.edge_id)
            .map_err(|e| PyRuntimeError::new_err(format!("Failed to get edge endpoints: {}", e)))?;
        Ok(endpoints)
    }
    
    /// Check if attribute exists
    fn __contains__(&self, py: Python, key: &str) -> PyResult<bool> {
        let graph = self.graph.borrow(py);
        Ok(graph.has_edge_attribute(self.edge_id, key))
    }
    
    /// Get all attribute keys
    fn keys(&self, py: Python) -> PyResult<Vec<String>> {
        let graph = self.graph.borrow(py);
        Ok(graph.edge_attribute_keys(self.edge_id))
    }
    
    /// Get all attribute values
    fn values(&self, py: Python) -> PyResult<Vec<PyAttrValue>> {
        let graph = self.graph.borrow(py);
        // 🚀 PERFORMANCE FIX: Use batch attribute access instead of manual loops
        let edge_attrs = graph.inner.get_edge_attrs(self.edge_id)
            .map_err(|e| PyRuntimeError::new_err(format!("Failed to get edge attributes: {}", e)))?;
        
        let values = edge_attrs.into_iter()
            .map(|(_, value)| PyAttrValue::from_attr_value(value))
            .collect();
        Ok(values)
    }
    
    /// Get all attribute items as (key, value) pairs
    fn items(&self, py: Python) -> PyResult<Vec<(String, PyAttrValue)>> {
        let graph = self.graph.borrow(py);
        // 🚀 PERFORMANCE FIX: Use batch attribute access instead of manual loops
        let edge_attrs = graph.inner.get_edge_attrs(self.edge_id)
            .map_err(|e| PyRuntimeError::new_err(format!("Failed to get edge attributes: {}", e)))?;
        
        let items = edge_attrs.into_iter()
            .map(|(key, value)| (key, PyAttrValue::from_attr_value(value)))
            .collect();
        Ok(items)
    }
    
    /// Update multiple attributes at once (chainable)
    fn update(&mut self, py: Python, attributes: &PyDict) -> PyResult<PyObject> {
        let mut graph = self.graph.borrow_mut(py);
        
        for (key, value) in attributes.iter() {
            let key_str = key.extract::<String>()?;
            let attr_value = PyAttrValue::extract(value)?.to_attr_value();
            graph.set_edge_attribute(self.edge_id, key_str, &PyAttrValue::from_attr_value(attr_value))?;
        }
        
        // Return self for chaining
        Ok(self.clone().into_py(py))
    }
    
    /// String representation
    fn __str__(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        let keys = graph.edge_attribute_keys(self.edge_id);
        
        // Get endpoints for display
        let (source, target) = match graph.inner.edge_endpoints(self.edge_id) {
            Ok(endpoints) => endpoints,
            Err(_) => return Ok(format!("EdgeView({}) [invalid]", self.edge_id)),
        };
        
        if keys.is_empty() {
            Ok(format!("EdgeView({}: {} -> {})", self.edge_id, source, target))
        } else {
            let mut attr_parts = Vec::new();
            for key in keys.iter().take(3) {  // Show first 3 attributes
                if let Ok(Some(value)) = graph.get_edge_attribute(self.edge_id, key.clone()) {
                    attr_parts.push(format!("{}={}", key, value.__str__()?));
                }
            }
            
            let attr_str = if keys.len() > 3 {
                format!("{}, ...", attr_parts.join(", "))
            } else {
                attr_parts.join(", ")
            };
            
            Ok(format!("EdgeView({}: {} -> {}, {})", self.edge_id, source, target, attr_str))
        }
    }
    
    /// Get as dictionary
    fn to_dict(&self, py: Python) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        let graph = self.graph.borrow(py);
        let keys = graph.edge_attribute_keys(self.edge_id);
        
        for key in keys {
            if let Some(value) = graph.get_edge_attribute(self.edge_id, key.clone()).ok().flatten() {
                dict.set_item(key, value)?;
            }
        }
        
        Ok(dict.to_object(py))
    }
}

impl Clone for PyEdgeView {
    fn clone(&self) -> Self {
        PyEdgeView {
            graph: self.graph.clone(),
            edge_id: self.edge_id,
        }
    }
}


--- FILE: ffi/core/subgraph.rs ---
//! Subgraph FFI Bindings
//! 
//! Python bindings for PySubgraph - dual-mode architecture supporting both
//! core RustSubgraph integration and legacy compatibility.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyValueError, PyTypeError, PyRuntimeError, PyKeyError, PyIndexError, PyImportError, PyNotImplementedError};
use groggy::{NodeId, EdgeId, AttrValue};
use std::collections::{HashMap, HashSet};

// Import types from our FFI modules
use crate::ffi::api::graph::PyGraph;
use crate::ffi::types::PyAttrValue;
use crate::ffi::core::array::{PyGraphArray, PyGraphMatrix};
use crate::ffi::core::accessors::{PyNodesAccessor, PyEdgesAccessor};
use crate::ffi::core::query::PyNodeFilter;
use crate::ffi::utils::graph_error_to_py_err;

// Import the core Subgraph type
use groggy::core::subgraph::Subgraph as RustSubgraph;


/// Utility function to convert Python values to AttrValue
fn python_value_to_attr_value(value: &PyAny) -> PyResult<AttrValue> {
    if let Ok(int_val) = value.extract::<i64>() {
        Ok(AttrValue::Int(int_val))
    } else if let Ok(float_val) = value.extract::<f64>() {
        Ok(AttrValue::Float(float_val as f32))
    } else if let Ok(str_val) = value.extract::<String>() {
        Ok(AttrValue::Text(str_val))
    } else if let Ok(bool_val) = value.extract::<bool>() {
        Ok(AttrValue::Bool(bool_val))
    } else {
        Err(PyTypeError::new_err("Unsupported attribute value type"))
    }
}

/// Utility function to convert AttrValue to Python object
fn attr_value_to_python_value(py: Python, attr_value: &AttrValue) -> PyResult<PyObject> {
    match attr_value {
        AttrValue::Int(val) => Ok(val.to_object(py)),
        AttrValue::SmallInt(val) => Ok((*val as i64).to_object(py)),
        AttrValue::Float(val) => Ok(val.to_object(py)),
        AttrValue::Bool(val) => Ok(val.to_object(py)),
        AttrValue::Text(val) => Ok(val.to_object(py)),
        AttrValue::CompactText(val) => Ok(val.as_str().to_object(py)),
        _ => Ok(py.None()),
    }
}

/// Subgraph - represents a filtered view of the main graph with same interface
#[pyclass(name = "Subgraph", unsendable)]
pub struct PySubgraph {
    // Use the core Rust Subgraph with proper Rc<RefCell<Graph>> architecture
    inner: Option<RustSubgraph>,
    // Fallback data for legacy compatibility (when inner is None)
    nodes: Vec<NodeId>,
    edges: Vec<EdgeId>,
    subgraph_type: String,
    graph: Option<Py<PyGraph>>,
}

impl PySubgraph {
    /// Create a PySubgraph from a core RustSubgraph (with proper graph reference)
    pub fn from_core_subgraph(subgraph: RustSubgraph) -> Self {
        let nodes = subgraph.node_ids();
        let edges = subgraph.edge_ids();
        let subgraph_type = subgraph.subgraph_type().to_string();
        
        PySubgraph {
            inner: Some(subgraph),
            nodes,
            edges,
            subgraph_type,
            graph: None, // Not needed when we have inner
        }
    }
    
    /// Standard PySubgraph constructor
    pub fn new(nodes: Vec<NodeId>, edges: Vec<EdgeId>, subgraph_type: String, graph: Option<Py<PyGraph>>) -> Self {
        PySubgraph {
            inner: None,
            nodes,
            edges,
            subgraph_type,
            graph,
        }
    }
    
    /// Get nodes vector (for internal module access)
    pub fn get_nodes(&self) -> &Vec<NodeId> {
        &self.nodes
    }
    
    /// Get edges vector (for internal module access)  
    pub fn get_edges(&self) -> &Vec<EdgeId> {
        &self.edges
    }
    
    /// Set graph reference (for internal module access)
    pub fn set_graph_reference(&mut self, graph: Py<PyGraph>) {
        self.graph = Some(graph);
    }
}

#[pymethods]
impl PySubgraph {
    /// Get nodes as a property that supports indexing and attribute access
    #[getter]
    fn nodes(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyNodesAccessor>> {
        if let Some(graph_ref) = &self_.graph {
            Py::new(py, PyNodesAccessor {
                graph: graph_ref.clone(),
                constrained_nodes: Some(self_.nodes.clone()),
            })
        } else {
            Err(PyRuntimeError::new_err("No graph reference available"))
        }
    }
    
    /// Get edges as a property that supports indexing and attribute access
    #[getter] 
    fn edges(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyEdgesAccessor>> {
        if let Some(graph_ref) = &self_.graph {
            Py::new(py, PyEdgesAccessor {
                graph: graph_ref.clone(),
                constrained_edges: Some(self_.edges.clone()),
            })
        } else {
            Err(PyRuntimeError::new_err("No graph reference available"))
        }
    }
    
    /// Python len() support - returns number of nodes
    fn __len__(&self) -> usize {
        self.nodes.len()
    }
    
    /// Node count property
    fn node_count(&self) -> usize {
        self.nodes.len()
    }
    
    /// Edge count property
    fn edge_count(&self) -> usize {
        self.edges.len()
    }
    
    /// Get node IDs in this subgraph as GraphArray (lazy Rust view) - use .values for Python list
    #[getter]
    fn node_ids(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let attr_values: Vec<groggy::AttrValue> = self.nodes.iter()
            .map(|&id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }
    
    /// Get edge IDs in this subgraph as GraphArray (lazy Rust view) - use .values for Python list
    #[getter]
    fn edge_ids(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let attr_values: Vec<groggy::AttrValue> = self.edges.iter()
            .map(|&id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }
    
    /// Check if a node exists in this subgraph
    fn has_node(&self, node_id: NodeId) -> bool {
        self.nodes.contains(&node_id)
    }
    
    /// Check if an edge exists in this subgraph
    fn has_edge(&self, edge_id: EdgeId) -> bool {
        self.edges.contains(&edge_id)
    }
    
    /// String representation
    fn __repr__(&self) -> String {
        format!("Subgraph(nodes={}, edges={}, type={})", 
                self.nodes.len(), self.edges.len(), self.subgraph_type)
    }
    
    /// Filter edges within this subgraph (chainable)
    fn filter_edges(&self, _py: Python, _filter: &PyAny) -> PyResult<PySubgraph> {
        // Placeholder implementation
        Ok(PySubgraph::new(
            self.nodes.clone(),
            self.edges.clone(),
            format!("{}_edge_filtered", self.subgraph_type),
            self.graph.clone(),
        ))
    }
    
    /// Connected components within this subgraph
    fn connected_components(&self) -> PyResult<Vec<PySubgraph>> {
        // Use inner subgraph if available
        if let Some(ref inner_subgraph) = self.inner {
            let components = inner_subgraph.connected_components()
                .map_err(|e| PyErr::new::<PyRuntimeError, _>(format!("Failed to get connected components: {}", e)))?;
            
            let mut result = Vec::new();
            for (i, component) in components.iter().enumerate() {
                // STANDARDIZED: Use PySubgraph::new() like all other subgraph creation methods
                // This ensures consistent graph reference handling for .nodes/.edges accessors
                result.push(PySubgraph::new(
                    component.node_ids(),
                    component.edge_ids(),
                    format!("connected_component_{}", i),
                    self.graph.clone(),  // Pass the graph reference consistently
                ));
            }
            Ok(result)
        } else {
            // Fallback - return single component for now
            Ok(vec![PySubgraph::new(
                self.nodes.clone(),
                self.edges.clone(),
                "component".to_string(),
                self.graph.clone(),
            )])
        }
    }
    
    /// Set attributes on all nodes in this subgraph (batch operation)
    #[pyo3(signature = (**kwargs))]
    fn set(&mut self, py: Python, kwargs: Option<&PyDict>) -> PyResult<Py<PySubgraph>> {
        // Use inner Subgraph if available (preferred path)
        if let Some(ref inner_subgraph) = self.inner {
            if let Some(kwargs) = kwargs {
                for (key, value) in kwargs.iter() {
                    let attr_name: String = key.extract()?;
                    let attr_value = python_value_to_attr_value(value)?;
                    
                    // Use the core Subgraph's bulk set method
                    inner_subgraph.set_node_attribute_bulk(&attr_name, attr_value)
                        .map_err(|e| PyErr::new::<PyRuntimeError, _>(format!("Failed to set attribute: {}", e)))?;
                }
            }
            
            // Return self for chaining  
            let new_subgraph = if let Some(ref inner) = self.inner {
                PySubgraph::from_core_subgraph(inner.clone())
            } else {
                PySubgraph::new(
                    self.nodes.clone(),
                    self.edges.clone(), 
                    self.subgraph_type.clone(),
                    self.graph.clone(),
                )
            };
            Ok(Py::new(py, new_subgraph)?)
        }
        // Fallback to legacy implementation
        else if let Some(graph_ref) = &self.graph {
            if let Some(kwargs) = kwargs {
                let mut graph = graph_ref.borrow_mut(py);
                
                // Update all nodes in this subgraph
                for &node_id in &self.nodes {
                    for (key, value) in kwargs.iter() {
                        let attr_name: String = key.extract()?;
                        let attr_value = python_value_to_attr_value(value)?;
                        let py_attr_value = PyAttrValue::from_attr_value(attr_value);
                        
                        graph.set_node_attribute(node_id, attr_name, &py_attr_value)?;
                    }
                }
            }
            
            // Return self for chaining
            Ok(Py::new(py, PySubgraph::new(
                self.nodes.clone(),
                self.edges.clone(),
                self.subgraph_type.clone(),
                self.graph.clone(),
            ))?)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot set attributes on subgraph without graph reference. Use graph.filter_nodes() or similar methods."
            ))
        }
    }
    
    /// Update attributes on all nodes in this subgraph using dict syntax
    fn update(&mut self, py: Python, data: &PyDict) -> PyResult<Py<PySubgraph>> {
        if let Some(graph_ref) = &self.graph {
            let mut graph = graph_ref.borrow_mut(py);
            
            // Update all nodes in this subgraph
            for &node_id in &self.nodes {
                for (key, value) in data.iter() {
                    let attr_name: String = key.extract()?;
                    let attr_value = python_value_to_attr_value(value)?;
                    let py_attr_value = PyAttrValue::from_attr_value(attr_value);
                    
                    graph.set_node_attribute(node_id, attr_name, &py_attr_value)?;
                }
            }
            
            // Return self for chaining
            Ok(Py::new(py, PySubgraph::new(
                self.nodes.clone(),
                self.edges.clone(),
                self.subgraph_type.clone(),
                self.graph.clone(),
            ))?)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot update attributes on subgraph without graph reference. Use graph.filter_nodes() or similar methods."
            ))
        }
    }
    
    /// Column access: get all values for a node attribute within this subgraph
    /// This enables: subgraph['component_id'] -> GraphArray with statistical methods
    fn get_node_attribute_column(&self, py: Python, attr_name: &str) -> PyResult<Py<PyGraphArray>> {
        // Use inner Subgraph if available (preferred path)
        if let Some(ref inner_subgraph) = self.inner {
            let attr_values = inner_subgraph.get_node_attribute_column(&attr_name.to_string())
                .map_err(|e| PyErr::new::<PyRuntimeError, _>(format!("Failed to get attribute column: {}", e)))?;
            
            // Create GraphArray from the attribute values
            let graph_array = groggy::GraphArray::from_vec(attr_values);
            
            // Wrap in Python GraphArray
            let py_graph_array = PyGraphArray { inner: graph_array };
            Ok(Py::new(py, py_graph_array)?)
        }
        // Fallback to legacy implementation
        else if let Some(graph_ref) = &self.graph {
            let graph = graph_ref.borrow(py);
            let mut attr_values = Vec::new();
            
            for &node_id in &self.nodes {
                if let Ok(Some(attr_value)) = graph.inner.get_node_attr(node_id, &attr_name.to_string()) {
                    attr_values.push(attr_value);
                } else {
                    // Handle missing attributes with default value
                    attr_values.push(groggy::AttrValue::Int(0));
                }
            }
            
            // Create GraphArray from the attribute values
            let graph_array = groggy::GraphArray::from_vec(attr_values);
            
            // Wrap in Python GraphArray
            let py_graph_array = PyGraphArray { inner: graph_array };
            Ok(Py::new(py, py_graph_array)?)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot access attributes on subgraph without graph reference."
            ))
        }
    }
    
    /// Column access: get all values for an edge attribute within this subgraph
    fn get_edge_attribute_column(&self, py: Python, attr_name: &str) -> PyResult<Vec<PyObject>> {
        if let Some(graph_ref) = &self.graph {
            let graph = graph_ref.borrow(py);
            let mut values = Vec::new();
            
            for &edge_id in &self.edges {
                if let Ok(Some(attr_value)) = graph.inner.get_edge_attr(edge_id, &attr_name.to_string()) {
                    // Convert AttrValue to Python object
                    let py_value = attr_value_to_python_value(py, &attr_value)?;
                    values.push(py_value);
                } else {
                    // Handle missing attributes - use None
                    values.push(py.None());
                }
            }
            
            Ok(values)
        } else {
            Err(PyErr::new::<PyRuntimeError, _>(
                "Cannot access edge attributes on subgraph without graph reference."
            ))
        }
    }
    
    /// Python dict-like access with multi-column support
    /// - subgraph['attr_name'] -> single column (Vec<PyObject>)  
    /// - subgraph[['age', 'height']] -> multi-column 2D GraphArray of shape (2, n)
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {
        // Try single string first (existing behavior)
        if let Ok(attr_name) = key.extract::<String>() {
            // CRITICAL FIX: Route to edge attributes for edge subgraphs
            if self.subgraph_type == "edge_slice_selection" {
                // This is an edge subgraph - route to edge attributes
                if attr_name == "id" {
                    // Special case: edge IDs (the edges themselves)
                    let edge_ids = self.edges.iter().map(|&edge_id| {
                        groggy::AttrValue::Int(edge_id as i64)
                    }).collect();
                    let graph_array = groggy::GraphArray::from_vec(edge_ids);
                    let py_graph_array = PyGraphArray { inner: graph_array };
                    return Ok(Py::new(py, py_graph_array)?.to_object(py));
                } else {
                    // Regular edge attributes (strength, weight, etc.)
                    let edge_values = self.get_edge_attribute_column(py, &attr_name)?;
                    // Convert Vec<PyObject> to GraphArray for consistency
                    let mut attr_values = Vec::new();
                    for py_value in edge_values {
                        // Convert Python values back to AttrValue
                        if py_value.is_none(py) {
                            attr_values.push(groggy::AttrValue::Int(0)); // Default for missing
                        } else if let Ok(int_val) = py_value.extract::<i64>(py) {
                            attr_values.push(groggy::AttrValue::Int(int_val));
                        } else if let Ok(float_val) = py_value.extract::<f64>(py) {
                            attr_values.push(groggy::AttrValue::Float(float_val as f32));
                        } else if let Ok(str_val) = py_value.extract::<String>(py) {
                            attr_values.push(groggy::AttrValue::Text(str_val));
                        } else if let Ok(bool_val) = py_value.extract::<bool>(py) {
                            attr_values.push(groggy::AttrValue::Bool(bool_val));
                        } else {
                            attr_values.push(groggy::AttrValue::Int(0)); // Fallback
                        }
                    }
                    let graph_array = groggy::GraphArray::from_vec(attr_values);
                    let py_graph_array = PyGraphArray { inner: graph_array };
                    return Ok(Py::new(py, py_graph_array)?.to_object(py));
                }
            } else {
                // This is a node subgraph - route to node attributes (original behavior)
                let column = self.get_node_attribute_column(py, &attr_name)?;
                return Ok(column.to_object(py));
            }
        }
        
        // Try list of strings (multi-column access)
        if let Ok(attr_names) = key.extract::<Vec<String>>() {
            if attr_names.is_empty() {
                return Err(PyValueError::new_err("Empty attribute list"));
            }
            
            // Collect all columns as GraphArrays
            let mut columns = Vec::new();
            let mut num_rows = 0;
            
            // Type checking for mixed types
            let mut column_types = Vec::new();
            
            for attr_name in &attr_names {
                let column = self.get_node_attribute_column(py, attr_name)?;
                
                // Detect column type by borrowing temporarily
                let column_type = {
                    let graph_array = column.borrow(py);
                    
                    // Get the length and detect column type
                    num_rows = graph_array.inner.len();
                    
                    // Sample a few values to determine the predominant type
                    if num_rows > 0 {
                        let sample_size = std::cmp::min(num_rows, 3);
                        let mut type_counts = std::collections::HashMap::new();
                        
                        for i in 0..sample_size {
                            let type_name = match &graph_array.inner[i] {
                                groggy::AttrValue::Int(_) | groggy::AttrValue::SmallInt(_) => "int",
                                groggy::AttrValue::Float(_) => "float", 
                                groggy::AttrValue::Bool(_) => "bool",
                                groggy::AttrValue::Text(_) | groggy::AttrValue::CompactText(_) => "str",
                                _ => "mixed",
                            };
                            *type_counts.entry(type_name).or_insert(0) += 1;
                        }
                        
                        // Get the most common type
                        type_counts.into_iter()
                            .max_by_key(|(_, count)| *count)
                            .map(|(type_name, _)| type_name)
                            .unwrap_or("mixed")
                    } else {
                        "empty"
                    }
                }; // Borrow ends here
                
                column_types.push(column_type);
                columns.push(column);
            }
            
            // Check for mixed types (GraphMatrix constraint)  
            if attr_names.len() > 1 {
                let first_type = column_types[0];
                let has_mixed_types = column_types.iter().any(|&t| t != first_type && t != "empty");
                
                if has_mixed_types {
                    let detected_types: Vec<&str> = column_types.into_iter().collect();
                    return Err(PyTypeError::new_err(format!(
                        "Mixed types detected: [{}]. GraphMatrix requires homogeneous types.\n\
                        Use subgraph.nodes.table()[{:?}] for mixed-type data.",
                        detected_types.join(", "),
                        attr_names
                    )));
                }
            }
            
            // For single column in list form: [['age']] -> return GraphArray (same as 'age')
            if attr_names.len() == 1 {
                return Ok(columns[0].clone_ref(py).to_object(py));
            } else {
                // TODO: Implement proper multi-column access for attribute data
                // This needs a different approach than adjacency PyGraphMatrix
                return Err(PyNotImplementedError::new_err(
                    "Multi-column attribute access not yet implemented with new GraphMatrix architecture"
                ));
            }
        }
        
        Err(PyTypeError::new_err("Key must be a string or list of strings"))
    }
    
    /// Create GraphTable for DataFrame-like view of this subgraph nodes
    fn table(&self, py: Python) -> PyResult<PyObject> {
        // Import the Python GraphTable class
        let groggy = py.import("groggy")?;
        let graph_table_class = groggy.getattr("GraphTable")?;
        
        // Create GraphTable with nodes data source
        let table = graph_table_class.call1((self.nodes.clone(), "nodes", self.graph.clone()))?;
        Ok(table.to_object(py))
    }
    
    /// Create GraphTable for DataFrame-like view of this subgraph edges
    fn edges_table(&self, py: Python) -> PyResult<PyObject> {
        // Import the Python GraphTable class
        let groggy = py.import("groggy")?;
        let graph_table_class = groggy.getattr("GraphTable")?;
        
        // Create GraphTable with edges data source
        let table = graph_table_class.call1((self.edges.clone(), "edges", self.graph.clone()))?;
        Ok(table.to_object(py))
    }
    
    /// Python-level access to parent graph (if attached).
    #[getter]
    pub fn graph(&self) -> PyResult<Option<Py<PyGraph>>> {
        Ok(self.graph.clone())
    }
    
    /// Fast column accessor for node attributes on PySubgraph
    pub fn _get_node_attribute_column(&self, py: Python<'_>, name: &str) -> PyResult<Py<PyGraphArray>> {
        if let Some(ref inner) = self.inner {
            let attr_name = groggy::AttrName::from(name.to_string());
            let arr = inner.get_node_attribute_column(&attr_name)
                .map_err(|e| pyo3::exceptions::PyRuntimeError::new_err(format!("Failed to get node attribute column: {}", e)))?;
            let py_graph_array = PyGraphArray { inner: groggy::GraphArray::from_vec(arr) };
            return Py::new(py, py_graph_array);
        }
        Err(pyo3::exceptions::PyRuntimeError::new_err("Subgraph has no inner core; attach a graph-backed subgraph"))
    }

    /// Fast column accessor for edge attributes on PySubgraph  
    pub fn _get_edge_attribute_column(&self, py: Python<'_>, name: &str) -> PyResult<Py<PyGraphArray>> {
        if let Some(ref inner) = self.inner {
            let attr_name = groggy::AttrName::from(name.to_string());
            let arr = inner.get_edge_attribute_column(&attr_name)
                .map_err(|e| pyo3::exceptions::PyRuntimeError::new_err(format!("Failed to get edge attribute column: {}", e)))?;
            let py_graph_array = PyGraphArray { inner: groggy::GraphArray::from_vec(arr) };
            return Py::new(py, py_graph_array);
        }
        Err(pyo3::exceptions::PyRuntimeError::new_err("Subgraph has no inner core; attach a graph-backed subgraph"))
    }
    
    /// Filter nodes *within this subgraph* using a full NodeFilter or string expression.
    /// Returns a new PySubgraph with filtered nodes and induced edges (within this subgraph).
    pub fn filter_nodes(&self, py: Python<'_>, filter: &PyAny) -> PyResult<PySubgraph> {
        // 0) Must have a parent graph to evaluate attributes efficiently
        let Some(graph_ref) = &self.graph else {
            return Err(PyRuntimeError::new_err("Subgraph has no parent graph reference"));
        };

        // 1) Resolve a NodeFilter:
        //    - If caller passed a NodeFilter object -> use it
        //    - Else if they passed a string -> parse via groggy.query_parser.parse_node_query
        //    - Else optional dict[str, AttributeFilter] -> translate to NodeFilter::And(AttributeFilter...)
        let node_filter = if let Ok(py_nf) = filter.extract::<PyNodeFilter>() {
            py_nf.inner.clone()
        } else if let Ok(query_str) = filter.extract::<String>() {
            let qp = py.import("groggy.query_parser")?;
            let parse = qp.getattr("parse_node_query")?;
            let parsed: PyNodeFilter = parse.call1((query_str,))?.extract()?;
            parsed.inner.clone()
        } else if let Ok(dict) = filter.downcast::<pyo3::types::PyDict>() {
            // Optional: allow dict form {"age": AttributeFilter.greater_than(21), ...}
            use groggy::core::query::{NodeFilter as NF, AttributeFilter as AF};
            use groggy::AttrName;
            let mut clauses = Vec::new();
            for (k, v) in dict.iter() {
                let key: String = k.extract()?;
                // Expect v is a PyAttributeFilter (FFI), so call .inner on it from Python first if needed.
                // If your AttributeFilter is exposed as a Python class, try to extract it directly:
                let py_attr = v.extract::<crate::ffi::core::query::PyAttributeFilter>()?;
                clauses.push(NF::AttributeFilter { name: AttrName::from(key), filter: py_attr.inner.clone() });
            }
            groggy::core::query::NodeFilter::And(clauses)
        } else {
            return Err(PyTypeError::new_err(
                "filter must be NodeFilter | str | dict[str, AttributeFilter]"
            ));
        };

        // 2) Evaluate filter on the *current subgraph nodes* using the core API
        let mut g = graph_ref.borrow_mut(py);
        
        // Get all nodes that match the filter from the entire graph
        let all_filtered_nodes: Vec<groggy::NodeId> = g.inner
            .find_nodes(node_filter)
            .map_err(graph_error_to_py_err)?;
        
        // Intersect with current subgraph's nodes to get nodes that are both:
        // 1) In this subgraph, and 2) Match the filter
        let subgraph_node_set: HashSet<groggy::NodeId> = self.nodes.iter().copied().collect();
        let filtered_nodes: Vec<groggy::NodeId> = all_filtered_nodes
            .into_iter()
            .filter(|node_id| subgraph_node_set.contains(node_id))
            .collect();

        // 3) Induce edges *within this subgraph* only
        let node_set: HashSet<groggy::NodeId> = filtered_nodes.iter().copied().collect();
        let mut induced_edges = Vec::with_capacity(self.edges.len() / 2);
        for &eid in &self.edges {
            if let Ok((s, t)) = g.inner.edge_endpoints(eid) {
                if node_set.contains(&s) && node_set.contains(&t) {
                    induced_edges.push(eid);
                }
            }
        }

        // 4) Return a new subgraph; preserve graph reference for downstream ops/tables
        let mut out = PySubgraph::new(
            filtered_nodes,
            induced_edges,
            format!("{}_filtered", self.subgraph_type),
            None, // we'll set the graph next
        );
        out.set_graph_reference(graph_ref.clone());
        Ok(out)
    }
}


--- FILE: ffi/core/array.rs ---
//! Array FFI Bindings
//! 
//! Python bindings for statistical arrays and matrices.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyValueError, PyTypeError, PyRuntimeError, PyKeyError, PyIndexError, PyImportError, PyNotImplementedError};
use groggy::core::array::{GraphArray, StatsSummary};
use groggy::AttrValue as RustAttrValue;

// Use utility functions from utils module
use crate::ffi::utils::{python_value_to_attr_value, attr_value_to_python_value, graph_error_to_py_err};

/// Native performance-oriented GraphArray for statistical operations
#[pyclass(name = "GraphArray")]
pub struct PyGraphArray {
    pub inner: GraphArray,
}

#[pymethods]
impl PyGraphArray {
    /// Create a new GraphArray from a list of values
    #[new]
    fn new(values: Vec<PyObject>) -> PyResult<Self> {
        Python::with_gil(|py| {
            let mut attr_values = Vec::with_capacity(values.len());
            
            for value in values {
                let attr_value = python_value_to_attr_value(value.as_ref(py))?;
                attr_values.push(attr_value);
            }
            
            Ok(PyGraphArray {
                inner: GraphArray::from_vec(attr_values),
            })
        })
    }
    
    // === LIST COMPATIBILITY ===
    
    /// Get the number of elements (len())
    fn __len__(&self) -> usize {
        self.inner.len()
    }
    
    /// Get element by index - supports arr[i] with negative indexing
    fn __getitem__(&self, py: Python, index: isize) -> PyResult<PyObject> {
        let len = self.inner.len() as isize;
        
        // Handle negative indexing (Python-style)
        let actual_index = if index < 0 {
            len + index
        } else {
            index
        };
        
        // Check bounds
        if actual_index < 0 || actual_index >= len {
            return Err(PyIndexError::new_err("Index out of range"));
        }
        
        match self.inner.get(actual_index as usize) {
            Some(attr_value) => attr_value_to_python_value(py, attr_value),
            None => Err(PyIndexError::new_err("Index out of range")),
        }
    }
    
    /// String representation with rich display formatting
    fn __repr__(&self, py: Python) -> PyResult<String> {
        // Try rich display formatting first, with graceful fallback
        match self._try_rich_display(py) {
            Ok(formatted) => Ok(formatted),
            Err(_) => {
                // Fallback to simple representation
                let len = self.inner.len();
                let dtype = self._get_dtype();
                Ok(format!("GraphArray(len={}, dtype={})", len, dtype))
            }
        }
    }
    
    /// Try to use rich display formatting
    fn _try_rich_display(&self, py: Python) -> PyResult<String> {
        // Get display data for formatting
        let display_data = self._get_display_data(py)?;
        
        // Import the format_array function from Python
        let groggy_module = py.import("groggy")?;
        let format_array = groggy_module.getattr("format_array")?;
        
        // Call the Python formatter
        let result = format_array.call1((display_data,))?;
        let formatted_str: String = result.extract()?;
        
        Ok(formatted_str)
    }
    
    /// String representation (same as __repr__ for consistency)
    fn __str__(&self, py: Python) -> PyResult<String> {
        self.__repr__(py)
    }
    
    /// Iterator support (for value in array)
    fn __iter__(slf: PyRef<Self>) -> GraphArrayIterator {
        GraphArrayIterator {
            array: slf.inner.clone(),
            index: 0,
        }
    }
    
    /// Convert to plain Python list
    fn to_list(&self, py: Python) -> PyResult<Vec<PyObject>> {
        let mut py_values = Vec::with_capacity(self.inner.len());
        
        for attr_value in self.inner.iter() {
            py_values.push(attr_value_to_python_value(py, attr_value)?);
        }
        
        Ok(py_values)
    }
    
    
    // === STATISTICAL OPERATIONS ===
    
    /// Calculate mean (average) of numeric values
    fn mean(&self) -> Option<f64> {
        self.inner.mean()
    }
    
    /// Calculate standard deviation of numeric values
    fn std(&self) -> Option<f64> {
        self.inner.std()
    }
    
    /// Get minimum value
    fn min(&self, py: Python) -> PyResult<Option<PyObject>> {
        match self.inner.min() {
            Some(attr_value) => Ok(Some(attr_value_to_python_value(py, &attr_value)?)),
            None => Ok(None),
        }
    }
    
    /// Get maximum value
    fn max(&self, py: Python) -> PyResult<Option<PyObject>> {
        match self.inner.max() {
            Some(attr_value) => Ok(Some(attr_value_to_python_value(py, &attr_value)?)),
            None => Ok(None),
        }
    }
    
    /// Calculate quantile (percentile)
    fn quantile(&self, q: f64) -> Option<f64> {
        self.inner.quantile(q)
    }
    
    /// Calculate percentile (user-friendly wrapper for quantile)
    /// percentile: 0-100 (e.g., 25 for 25th percentile, 90 for 90th percentile)
    fn percentile(&self, p: f64) -> Option<f64> {
        if p < 0.0 || p > 100.0 {
            return None;
        }
        self.inner.quantile(p / 100.0)
    }
    
    /// Calculate median (50th percentile)
    fn median(&self) -> Option<f64> {
        self.inner.median()
    }
    
    /// Get count of elements
    fn count(&self) -> usize {
        self.inner.count()
    }
    
    /// Get unique values as a new GraphArray
    fn unique(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        use std::collections::HashSet;
        
        // Use HashSet to find unique values
        let mut unique_set = HashSet::new();
        let mut unique_values = Vec::new();
        
        for attr_value in self.inner.iter() {
            // Create a simple hash key based on the value
            let key = match attr_value {
                RustAttrValue::Int(i) => format!("i:{}", i),
                RustAttrValue::SmallInt(i) => format!("si:{}", i),
                RustAttrValue::Float(f) => format!("f:{}", f),
                RustAttrValue::Text(s) => format!("t:{}", s),
                RustAttrValue::CompactText(s) => format!("ct:{}", s.as_str()),
                RustAttrValue::Bool(b) => format!("b:{}", b),
                RustAttrValue::Bytes(b) => format!("bytes:{}", b.len()), // Simple hash for bytes
                _ => format!("other:{:?}", attr_value), // Fallback for other types
            };
            
            if unique_set.insert(key) {
                // This is a new unique value
                unique_values.push(attr_value.clone());
            }
        }
        
        // Create new GraphArray with unique values
        let unique_array = GraphArray::from_vec(unique_values);
        let py_unique = PyGraphArray { inner: unique_array };
        
        Ok(Py::new(py, py_unique)?)
    }
    
    /// Get value counts (frequency of each unique value) as Python dict
    fn value_counts(&self, py: Python) -> PyResult<PyObject> {
        use std::collections::HashMap;
        
        let mut counts: HashMap<String, (i32, RustAttrValue)> = HashMap::new();
        
        for attr_value in self.inner.iter() {
            // Create a string representation for HashMap key
            let key_str = match attr_value {
                RustAttrValue::Int(i) => format!("i:{}", i),
                RustAttrValue::SmallInt(i) => format!("si:{}", i),
                RustAttrValue::Float(f) => format!("f:{}", f),
                RustAttrValue::Text(s) => format!("t:{}", s),
                RustAttrValue::CompactText(s) => format!("ct:{}", s.as_str()),
                RustAttrValue::Bool(b) => format!("b:{}", b),
                RustAttrValue::Bytes(b) => format!("bytes:{}", b.len()),
                _ => format!("other:{:?}", attr_value),
            };
            
            match counts.get_mut(&key_str) {
                Some((count, _)) => *count += 1,
                None => {
                    counts.insert(key_str, (1, attr_value.clone()));
                }
            }
        }
        
        // Convert to Python dict
        let dict = pyo3::types::PyDict::new(py);
        for (_, (count, attr_value)) in counts {
            let py_key = attr_value_to_python_value(py, &attr_value)?;
            dict.set_item(py_key, count)?;
        }
        
        Ok(dict.to_object(py))
    }
    
    /// Get raw data as Python list (like pandas .values property) 
    #[getter]
    fn values(&self, py: Python) -> PyResult<Vec<PyObject>> {
        self.to_list(py)
    }
    
    /// Get comprehensive statistical summary
    fn describe(&self, _py: Python) -> PyResult<PyStatsSummary> {
        Ok(PyStatsSummary {
            inner: self.inner.describe(),
        })
    }
    
    // ========================================================================
    // SCIENTIFIC COMPUTING CONVERSIONS
    // ========================================================================
    
    /// Convert to NumPy array (when numpy available)
    fn to_numpy(&self, py: Python) -> PyResult<PyObject> {
        // Try to import numpy
        let numpy = py.import("numpy").map_err(|_| {
            PyErr::new::<PyImportError, _>("numpy is required for to_numpy(). Install with: pip install numpy")
        })?;
        
        // Get data as Python list
        let values = self.values(py)?;
        
        // Convert to numpy array
        let array = numpy.call_method1("array", (values,))?;
        Ok(array.to_object(py))
    }
    
    /// Convert to Pandas Series (when pandas available)
    fn to_pandas(&self, py: Python) -> PyResult<PyObject> {
        // Try to import pandas
        let pandas = py.import("pandas").map_err(|_| {
            PyErr::new::<PyImportError, _>("pandas is required for to_pandas(). Install with: pip install pandas")
        })?;
        
        // Get data as Python list
        let values = self.values(py)?;
        
        // Create Series
        let series = pandas.call_method1("Series", (values,))?;
        Ok(series.to_object(py))
    }
    
    /// Convert to SciPy sparse array (for compatibility - GraphArray is dense by nature)
    fn to_scipy_sparse(&self, py: Python) -> PyResult<PyObject> {
        // Try to import scipy.sparse
        let scipy_sparse = py.import("scipy.sparse").map_err(|_| {
            PyErr::new::<PyImportError, _>("scipy is required for to_scipy_sparse(). Install with: pip install scipy")
        })?;
        
        // Get data as Python list
        let values = self.values(py)?;
        
        // Convert to numpy first, then to sparse
        let numpy = py.import("numpy")?;
        let array = numpy.call_method1("array", (values,))?;
        
        // Create CSR matrix (compressed sparse row) from the dense array
        let sparse_matrix = scipy_sparse.call_method1("csr_matrix", (array,))?;
        Ok(sparse_matrix.to_object(py))
    }
    
    // ========================================================================
    // DISPLAY INTEGRATION METHODS
    // ========================================================================
    
    /// Extract display data for Python display formatters
    /// Returns a dictionary with the structure expected by array_display.py
    fn _get_display_data(&self, py: Python) -> PyResult<PyObject> {
        let dict = pyo3::types::PyDict::new(py);
        
        // Extract array data - convert to Python list
        let data = self.to_list(py)?;
        dict.set_item("data", data)?;
        
        // Get array metadata
        dict.set_item("shape", (self.inner.len(),))?;
        dict.set_item("dtype", self._get_dtype())?;
        dict.set_item("name", self._get_name().unwrap_or_else(|| "array".to_string()))?;
        
        Ok(dict.to_object(py))
    }
    
    /// Get data type string for display
    fn _get_dtype(&self) -> String {
        // Sample first few elements to determine predominant type
        let sample_size = std::cmp::min(self.inner.len(), 5);
        if sample_size == 0 {
            return "object".to_string();
        }
        
        let mut type_counts = std::collections::HashMap::new();
        
        for i in 0..sample_size {
            let type_name = match &self.inner[i] {
                RustAttrValue::Int(_) | RustAttrValue::SmallInt(_) => "int64",
                RustAttrValue::Float(_) => "f32",
                RustAttrValue::Bool(_) => "bool",
                RustAttrValue::Text(_) | RustAttrValue::CompactText(_) => "str",
                _ => "object",
            };
            *type_counts.entry(type_name).or_insert(0) += 1;
        }
        
        // Return the most common type
        type_counts.into_iter()
            .max_by_key(|(_, count)| *count)
            .map(|(type_name, _)| type_name.to_string())
            .unwrap_or_else(|| "object".to_string())
    }
    
    /// Get name for display (optional)
    fn _get_name(&self) -> Option<String> {
        // For now, we don't store names in GraphArray
        // This can be enhanced later when we add named arrays
        None
    }
}

/// Python wrapper for StatsSummary
#[pyclass(name = "StatsSummary")]
pub struct PyStatsSummary {
    pub inner: StatsSummary,
}

#[pymethods]
impl PyStatsSummary {
    #[getter]
    fn count(&self) -> usize {
        self.inner.count
    }
    
    #[getter]
    fn mean(&self) -> Option<f64> {
        self.inner.mean
    }
    
    #[getter]
    fn std(&self) -> Option<f64> {
        self.inner.std
    }
    
    #[getter]
    fn min(&self, py: Python) -> PyResult<Option<PyObject>> {
        match &self.inner.min {
            Some(attr_value) => Ok(Some(attr_value_to_python_value(py, attr_value)?)),
            None => Ok(None),
        }
    }
    
    #[getter]
    fn max(&self, py: Python) -> PyResult<Option<PyObject>> {
        match &self.inner.max {
            Some(attr_value) => Ok(Some(attr_value_to_python_value(py, attr_value)?)),
            None => Ok(None),
        }
    }
    
    #[getter]
    fn median(&self) -> Option<f64> {
        self.inner.median
    }
    
    #[getter]
    fn q25(&self) -> Option<f64> {
        self.inner.q25
    }
    
    #[getter]
    fn q75(&self) -> Option<f64> {
        self.inner.q75
    }
    
    fn __repr__(&self) -> String {
        format!("{}", self.inner)
    }
}

/// Python wrapper for GraphMatrix - wraps core GraphMatrix
/// This is the return type for adjacency matrices and other matrix operations
#[pyclass(name = "GraphMatrix")]
pub struct PyGraphMatrix {
    /// Core GraphMatrix
    pub inner: groggy::core::adjacency::GraphMatrix,
}

#[pymethods]
impl PyGraphMatrix {
    /// Get matrix dimensions as (rows, columns) tuple
    #[getter]
    fn shape(&self) -> (usize, usize) {
        (self.inner.size, self.inner.size)
    }
    
    /// Get number of rows (same as columns for square matrices)
    fn row_count(&self) -> usize {
        self.inner.size
    }
    
    /// Get number of columns (same as rows for square matrices)
    fn column_count(&self) -> usize {
        self.inner.size
    }
    
    /// Multi-index access for matrix elements: matrix[row, col] -> value
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {
        // Multi-index access (row, col) -> single cell value
        if let Ok(indices) = key.extract::<(usize, usize)>() {
            let (row, col) = indices;
            return self.get_cell(py, row, col);
        }
        
        // Single integer -> row access
        if let Ok(row_index) = key.extract::<usize>() {
            return self.get_row(py, row_index);
        }
        
        Err(PyTypeError::new_err(
            "Key must be: int (row index) or (row, col) tuple for multi-index access"
        ))
    }
    
    /// Get single cell value at (row, col) (FFI wrapper around core GraphMatrix)
    fn get_cell(&self, py: Python, row: usize, col: usize) -> PyResult<PyObject> {
        match self.inner.get(row, col) {
            Some(attr_value) => attr_value_to_python_value(py, attr_value),
            None => Err(PyIndexError::new_err(format!(
                "Index ({}, {}) out of range for {}x{} matrix", 
                row, col, self.inner.size, self.inner.size
            )))
        }
    }
    
    /// Get entire row as list (FFI wrapper around core GraphMatrix)
    fn get_row(&self, py: Python, row: usize) -> PyResult<PyObject> {
        match self.inner.get_row(row) {
            Some(row_values) => {
                let py_list = pyo3::types::PyList::empty(py);
                for value in row_values {
                    let py_value = attr_value_to_python_value(py, &value)?;
                    py_list.append(py_value)?;
                }
                Ok(py_list.to_object(py))
            },
            None => Err(PyIndexError::new_err(format!(
                "Row index {} out of range for {}x{} matrix", 
                row, self.inner.size, self.inner.size
            )))
        }
    }
    
    /// Get entire column as list (FFI wrapper around core GraphMatrix)
    fn get_column(&self, py: Python, col: usize) -> PyResult<PyObject> {
        match self.inner.get_column(col) {
            Some(col_values) => {
                let py_list = pyo3::types::PyList::empty(py);
                for value in col_values {
                    let py_value = attr_value_to_python_value(py, &value)?;
                    py_list.append(py_value)?;
                }
                Ok(py_list.to_object(py))
            },
            None => Err(PyIndexError::new_err(format!(
                "Column index {} out of range for {}x{} matrix", 
                col, self.inner.size, self.inner.size
            )))
        }
    }
    
    fn __repr__(&self) -> String {
        format!("GraphMatrix({}x{} adjacency matrix)", 
                self.inner.size, self.inner.size)
    }
}

/// Iterator for GraphArray
#[pyclass]
pub struct GraphArrayIterator {
    array: GraphArray,
    index: usize,
}

#[pymethods]
impl GraphArrayIterator {
    fn __iter__(slf: PyRef<Self>) -> PyRef<Self> {
        slf
    }
    
    fn __next__(&mut self, py: Python) -> PyResult<Option<PyObject>> {
        if self.index < self.array.len() {
            let attr_value = &self.array[self.index];
            self.index += 1;
            Ok(Some(attr_value_to_python_value(py, attr_value)?))
        } else {
            Ok(None)
        }
    }
}

// Helper function to create PyGraphArray from GraphArray
impl PyGraphArray {
    pub fn from_graph_array(array: GraphArray) -> Self {
        PyGraphArray { inner: array }
    }
}


--- FILE: ffi/api/graph_version.rs ---
//! Graph Version Control Module
//! 
//! Python bindings for graph versioning and history operations.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyValueError, PyRuntimeError};
use groggy::{StateId, AttrValue as RustAttrValue};
use crate::ffi::utils::graph_error_to_py_err;

/// Version control operations for graphs
#[pyclass(name = "GraphVersion")]
pub struct PyGraphVersion {
    /// Reference to the parent graph
    pub graph: Py<crate::ffi::api::graph::PyGraph>,
}

/// Python wrapper for commit information
#[pyclass(name = "Commit")]
#[derive(Clone)]
pub struct PyCommit {
    inner: std::sync::Arc<groggy::core::history::Commit>,
}

impl PyCommit {
    /// Create a PyCommit from a core Commit
    pub fn from_core_commit(commit: std::sync::Arc<groggy::core::history::Commit>) -> Self {
        Self { inner: commit }
    }
    
    /// Create a PyCommit from a CommitInfo (simplified info)
    pub fn from_commit_info(info: groggy::api::graph::CommitInfo) -> Self {
        // Create a simplified Commit from CommitInfo
        // Note: This is a temporary bridge until we have full core integration
        let parents = match info.parent {
            Some(p) => vec![p],
            None => vec![],
        };
        
        let fake_delta = std::sync::Arc::new(groggy::core::history::Delta {
            content_hash: [0u8; 32],
            nodes_added: Vec::new(),
            nodes_removed: Vec::new(),
            edges_added: Vec::new(),
            edges_removed: Vec::new(),
            node_attr_changes: Vec::new(),
            edge_attr_changes: Vec::new(),
        });
        
        let commit = groggy::core::history::Commit::new(
            info.id,
            parents,
            fake_delta,
            info.message,
            info.author
        );
        
        Self { inner: std::sync::Arc::new(commit) }
    }
}

#[pymethods]
impl PyCommit {
    
    #[getter]
    fn id(&self) -> StateId {
        self.inner.id
    }
    
    #[getter]
    fn parents(&self) -> Vec<StateId> {
        self.inner.parents.clone()
    }
    
    #[getter]
    fn message(&self) -> String {
        self.inner.message.clone()
    }
    
    #[getter]
    fn author(&self) -> String {
        self.inner.author.clone()
    }
    
    #[getter]
    fn timestamp(&self) -> u64 {
        self.inner.timestamp
    }
    
    fn __repr__(&self) -> String {
        format!("Commit(id={}, message='{}', author='{}')", 
                self.inner.id, self.inner.message, self.inner.author)
    }
}

/// Python wrapper for branch information
#[pyclass(name = "BranchInfo")]
#[derive(Clone)]
pub struct PyBranchInfo {
    inner: groggy::core::ref_manager::BranchInfo,
}

impl PyBranchInfo {
    /// Create a new PyBranchInfo from core BranchInfo
    pub fn new(inner: groggy::core::ref_manager::BranchInfo) -> Self {
        Self { inner }
    }
}

#[pymethods]
impl PyBranchInfo {
    #[getter]
    fn name(&self) -> String {
        self.inner.name.clone()
    }
    
    #[getter]
    fn head(&self) -> StateId {
        self.inner.head
    }
    
    #[getter]
    fn is_current(&self) -> bool {
        self.inner.is_current
    }
    
    fn __repr__(&self) -> String {
        format!("BranchInfo(name='{}', head={}, current={})", 
                self.inner.name, self.inner.head, self.inner.is_current)
    }
}

/// Python wrapper for historical view
#[pyclass(name = "HistoricalView")]
pub struct PyHistoricalView {
    pub state_id: StateId,
}

#[pymethods]
impl PyHistoricalView {
    #[getter]
    fn state_id(&self) -> StateId {
        self.state_id
    }
    
    fn __repr__(&self) -> String {
        format!("HistoricalView(state_id={})", self.state_id)
    }
}

#[pymethods]
impl PyGraphVersion {
    /// Commit current changes to version control
    fn commit(&self, py: Python, message: String, author: String) -> PyResult<StateId> {
        let mut graph = self.graph.borrow_mut(py);
        graph.inner.commit(message, author)
            .map_err(graph_error_to_py_err)
    }
    
    /// Create a new branch
    fn create_branch(&self, py: Python, branch_name: String) -> PyResult<()> {
        let mut graph = self.graph.borrow_mut(py);
        graph.inner.create_branch(branch_name)
            .map_err(graph_error_to_py_err)
    }
    
    /// Switch to a different branch
    fn checkout_branch(&self, py: Python, branch_name: String) -> PyResult<()> {
        let mut graph = self.graph.borrow_mut(py);
        graph.inner.checkout_branch(branch_name)
            .map_err(graph_error_to_py_err)
    }
    
    /// List all branches
    fn branches(&self, py: Python) -> Vec<PyBranchInfo> {
        let graph = self.graph.borrow(py);
        graph.inner.list_branches()
            .into_iter()
            .map(|branch_info| PyBranchInfo { inner: branch_info })
            .collect()
    }
    
    /// Get commit history
    fn commit_history(&self, py: Python) -> Vec<PyCommit> {
        let graph = self.graph.borrow(py);
        // Note: This is a simplified implementation
        // In the full implementation, you'd convert from CommitInfo to Commit
        Vec::new()
    }
    
    /// Get historical view at a specific commit
    fn historical_view(&self, py: Python, commit_id: StateId) -> PyResult<PyHistoricalView> {
        let graph = self.graph.borrow(py);
        match graph.inner.view_at_commit(commit_id) {
            Ok(_view) => Ok(PyHistoricalView {
                state_id: commit_id,
            }),
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    /// Check if there are uncommitted changes
    fn has_uncommitted_changes(&self, py: Python) -> bool {
        let graph = self.graph.borrow(py);
        graph.inner.has_uncommitted_changes()
    }
    
    /// Create a snapshot of the current graph state
    fn create_snapshot(&self, py: Python, name: Option<&str>) -> PyResult<PyObject> {
        let snapshot_name = name.unwrap_or("snapshot");
        let author = "system".to_string();
        let message = format!("Snapshot: {}", snapshot_name);
        
        let state_id = self.commit(py, message, author)?;
        
        // Return snapshot info as a dictionary
        let dict = PyDict::new(py);
        dict.set_item("state_id", state_id)?;
        dict.set_item("name", snapshot_name)?;
        dict.set_item("type", "snapshot")?;
        
        Ok(dict.to_object(py))
    }
    
    /// Restore graph to a previous snapshot
    fn restore_snapshot(&self, py: Python, snapshot_id: &str) -> PyResult<bool> {
        // Parse snapshot_id as StateId
        match snapshot_id.parse::<StateId>() {
            Ok(state_id) => {
                match self.historical_view(py, state_id) {
                    Ok(_) => {
                        // In a full implementation, you'd actually restore the state
                        // For now, just indicate success if the snapshot exists
                        Ok(true)
                    },
                    Err(_) => Ok(false),
                }
            },
            Err(_) => {
                Err(PyValueError::new_err(format!("Invalid snapshot ID: {}", snapshot_id)))
            }
        }
    }
    
    /// Get version history
    fn get_history(&self, py: Python) -> PyResult<PyObject> {
        let graph = self.graph.borrow(py);
        
        // Create a summary of version history
        let dict = PyDict::new(py);
        
        // Get branch information
        let branches = self.branches(py);
        let branch_list: Vec<PyObject> = branches.into_iter()
            .map(|branch| Py::new(py, branch).unwrap().to_object(py))
            .collect();
        dict.set_item("branches", branch_list)?;
        
        // Get commit count (simplified)
        dict.set_item("total_commits", 0)?; // Would be implemented with actual history
        dict.set_item("has_uncommitted_changes", graph.inner.has_uncommitted_changes())?;
        
        // Get current state info
        let node_count = graph.get_node_count();
        let edge_count = graph.get_edge_count();
        dict.set_item("current_state", format!("{} nodes, {} edges", node_count, edge_count))?;
        
        Ok(dict.to_object(py))
    }
    
    /// Get node mapping for a specific attribute
    fn get_node_mapping(&self, py: Python, uid_key: String) -> PyResult<PyObject> {
        let graph = self.graph.borrow(py);
        let dict = PyDict::new(py);
        let node_ids = graph.inner.node_ids();
        
        // Scan all nodes for the specified uid_key attribute
        for node_id in node_ids {
            if let Ok(Some(attr_value)) = graph.inner.get_node_attr(node_id, &uid_key) {
                // Convert attribute value to appropriate Python type
                let key_value = match attr_value {
                    RustAttrValue::Text(s) => s.to_object(py),
                    RustAttrValue::CompactText(s) => s.as_str().to_object(py),
                    RustAttrValue::Int(i) => i.to_object(py),
                    RustAttrValue::SmallInt(i) => i.to_object(py), 
                    RustAttrValue::Float(f) => f.to_object(py),
                    RustAttrValue::Bool(b) => b.to_object(py),
                    _ => continue, // Skip unsupported types
                };
                
                dict.set_item(key_value, node_id)?;
            }
        }
        
        Ok(dict.to_object(py))
    }
    
    /// Get version info
    fn get_info(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        let node_count = graph.get_node_count();
        let edge_count = graph.get_edge_count();
        let has_changes = graph.inner.has_uncommitted_changes();
        
        Ok(format!("Version Control: {} nodes, {} edges, uncommitted changes: {}", 
                  node_count, edge_count, has_changes))
    }
}


--- FILE: ffi/api/graph.rs ---
//! Graph FFI Coordinator
//! 
//! Main Python bindings for the Graph API.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyKeyError, PyTypeError};
use groggy::{Graph as RustGraph, NodeId, EdgeId, AttrValue as RustAttrValue, AttrName, StateId};

// Import all graph modules
use crate::ffi::types::PyAttrValue;
use crate::ffi::core::accessors::{PyNodesAccessor, PyEdgesAccessor};
use crate::ffi::core::views::{PyNodeView, PyEdgeView};
use crate::ffi::core::array::{PyGraphArray, PyGraphMatrix};
use crate::ffi::core::subgraph::PySubgraph;
use crate::ffi::core::query::{PyNodeFilter, PyEdgeFilter};
use crate::ffi::core::traversal::PyGroupedAggregationResult;
use crate::ffi::utils::{graph_error_to_py_err, python_value_to_attr_value, attr_value_to_python_value};

// Import version control types
use crate::ffi::api::graph_version::{PyCommit, PyBranchInfo, PyHistoricalView};
use crate::ffi::api::graph_query::PyGraphQuery;

// Placeholder imports for missing types - these need to be implemented
struct PyAttributes {
    graph: *const RustGraph,
}

/// Python wrapper for AggregationResult
#[pyclass(name = "AggregationResult")]
pub struct PyAggregationResult {
    pub value: f64,
}

#[pymethods]
impl PyAggregationResult {
    #[getter]
    fn value(&self) -> f64 {
        self.value
    }
    
    fn __repr__(&self) -> String {
        format!("AggregationResult({})", self.value)
    }
}


// Helper function to extract GraphMatrix from AdjacencyMatrix and wrap in PyGraphMatrix
fn adjacency_matrix_to_py_graph_matrix(py: Python, matrix: groggy::AdjacencyMatrix) -> PyResult<Py<PyGraphMatrix>> {
    match matrix {
        groggy::AdjacencyMatrix::Dense(graph_matrix) => {
            // Directly wrap the core GraphMatrix in PyGraphMatrix
            let py_graph_matrix = PyGraphMatrix { inner: graph_matrix };
            Ok(Py::new(py, py_graph_matrix)?)
        },
        groggy::AdjacencyMatrix::Sparse(_sparse_matrix) => {
            // For now, convert sparse to dense - TODO: implement PyGraphMatrix for sparse
            Err(pyo3::exceptions::PyNotImplementedError::new_err(
                "Sparse adjacency matrices not yet supported in Python interface"
            ))
        }
    }
}

/// Python wrapper for the main Graph
#[pyclass(name = "Graph", unsendable)]
pub struct PyGraph {
    pub inner: RustGraph,
}

#[pymethods]
impl PyGraph {
    #[new]
    #[pyo3(signature = (directed = false, _config = None))]
    fn new(directed: bool, _config: Option<&PyDict>) -> PyResult<Self> {
        // Create graph with specified directionality
        let rust_graph = if directed {
            RustGraph::new_directed()
        } else {
            RustGraph::new_undirected()
        };
        Ok(Self { inner: rust_graph })
    }
    
    /// Check if this graph is directed
    #[getter]
    fn is_directed(&self) -> bool {
        self.inner.is_directed()
    }
    
    /// Check if this graph is undirected
    #[getter]
    fn is_undirected(&self) -> bool {
        self.inner.is_undirected()
    }
    
    // === CORE GRAPH OPERATIONS ===
    
    #[pyo3(signature = (**kwargs))]
    fn add_node(&mut self, kwargs: Option<&PyDict>) -> PyResult<NodeId> {
        let node_id = self.inner.add_node();
        
        // Fast path: if no kwargs, just return the node_id
        if let Some(attrs) = kwargs {
            if !attrs.is_empty() {
                // Only do attribute setting if we actually have attributes
                for (key, value) in attrs.iter() {
                    let attr_name: String = key.extract()?;
                    let attr_value = python_value_to_attr_value(value)?;
                    
                    self.inner.set_node_attr(node_id, attr_name, attr_value)
                        .map_err(graph_error_to_py_err)?;
                }
            }
        }
        
        Ok(node_id)
    }
    
    #[pyo3(signature = (data, uid_key = None))]
    fn add_nodes(&mut self, data: &PyAny, uid_key: Option<String>) -> PyResult<PyObject> {
        // Fast path optimization: Check for integer first (most common case)
        if let Ok(count) = data.extract::<usize>() {
            // Old API: add_nodes(5) -> [0, 1, 2, 3, 4] - fastest path
            let node_ids = self.inner.add_nodes(count);
            return Python::with_gil(|py| Ok(node_ids.to_object(py)));
        }
        
        // Only use Python::with_gil for complex operations
        Python::with_gil(|py| {
            if let Ok(node_data_list) = data.extract::<Vec<&PyDict>>() {
                // New API: add_nodes([{"id": "alice", "age": 30}, ...], id_key="id")
                let mut id_mapping = std::collections::HashMap::new();
                
                // Create all nodes first
                let node_ids = self.inner.add_nodes(node_data_list.len());
                
                // OPTIMIZATION: Collect attributes by name for bulk operations instead of individual calls
                // This changes complexity from O(N × A × log N) to O(N × A)
                let mut attrs_by_name: std::collections::HashMap<String, Vec<(NodeId, RustAttrValue)>> = std::collections::HashMap::new();
                
                // Process each node's data
                for (i, node_dict) in node_data_list.iter().enumerate() {
                    let node_id = node_ids[i];
                    
                    // Extract the ID if id_key is provided
                    if let Some(ref key) = uid_key {
                        match node_dict.get_item(key) {
                            Ok(Some(id_value)) => {
                                if let Ok(user_id) = id_value.extract::<String>() {
                                    id_mapping.insert(user_id, node_id);
                                }
                            }
                            Ok(None) => {
                                return Err(PyErr::new::<PyKeyError, _>(format!("Missing key: {}", key)));
                            }
                            Err(e) => return Err(e),
                        }
                    }
                    
                    // Collect all attributes for bulk setting
                    for (attr_key, attr_value) in node_dict.iter() {
                        let attr_name: String = attr_key.extract()?;
                        let attr_val = python_value_to_attr_value(attr_value)?;
                        
                        // Store all attributes including the id_key for later uid_key lookups
                        attrs_by_name.entry(attr_name).or_insert_with(Vec::new).push((node_id, attr_val));
                    }
                }
                
                // OPTIMIZATION: Use bulk attribute setting - O(A) operations instead of O(N × A)
                if !attrs_by_name.is_empty() {
                    self.inner.set_node_attrs(attrs_by_name)
                        .map_err(graph_error_to_py_err)?;
                }
                
                // Return the mapping if id_key was provided, otherwise return node IDs
                if uid_key.is_some() {
                    Ok(id_mapping.to_object(py))
                } else {
                    Ok(node_ids.to_object(py))
                }
            } else {
                Err(PyErr::new::<PyTypeError, _>(
                    "add_nodes expects either an integer count or a list of dictionaries"
                ))
            }
        })
    }
    
    /// Helper method to resolve string ID to NodeId using uid_key attribute
    fn resolve_string_id_to_node(&self, string_id: &str, uid_key: &str) -> PyResult<NodeId> {
        let node_ids = self.inner.node_ids();
        
        for node_id in node_ids {
            if let Ok(Some(attr_value)) = self.inner.get_node_attr(node_id, &uid_key.to_string()) {
                match attr_value {
                    RustAttrValue::Text(s) => {
                        if s == string_id {
                            return Ok(node_id);
                        }
                    },
                    RustAttrValue::CompactText(s) => {
                        if s.as_str() == string_id {
                            return Ok(node_id);
                        }
                    },
                    _ => continue, // Skip non-text attributes
                }
            }
        }
        
        Err(PyErr::new::<PyKeyError, _>(format!("No node found with {}='{}'", uid_key, string_id)))
    }
    
    /// String representation
    fn __repr__(&self) -> String {
        format!("Graph(nodes={}, edges={})", self.node_count(), self.edge_count())
    }
    
    /// Python len() support - returns number of nodes
    fn __len__(&self) -> usize {
        self.inner.node_ids().len()
    }
    
    /// Check if a node exists in the graph
    fn has_node(&self, node_id: NodeId) -> bool {
        self.inner.contains_node(node_id)
    }
    
    /// Check if an edge exists in the graph
    fn has_edge(&self, edge_id: EdgeId) -> bool {
        self.inner.contains_edge(edge_id)
    }
    
    /// Get the number of nodes in the graph
    fn node_count(&self) -> usize {
        self.inner.node_ids().len()
    }
    
    /// Get the number of edges in the graph
    fn edge_count(&self) -> usize {
        self.inner.edge_ids().len()
    }
    
    // === ATTRIBUTE OPERATIONS ===
    
    pub fn set_node_attribute(&mut self, node: NodeId, attr: AttrName, value: &PyAttrValue) -> PyResult<()> {
        self.inner.set_node_attr(node, attr, value.inner.clone())
            .map_err(graph_error_to_py_err)
    }
    
    pub fn set_edge_attribute(&mut self, edge: EdgeId, attr: AttrName, value: &PyAttrValue) -> PyResult<()> {
        self.inner.set_edge_attr(edge, attr, value.inner.clone())
            .map_err(graph_error_to_py_err)
    }
    
    pub fn get_node_attribute(&self, node: NodeId, attr: AttrName) -> PyResult<Option<PyAttrValue>> {
        match self.inner.get_node_attr(node, &attr) {
            Ok(Some(value)) => Ok(Some(PyAttrValue { inner: value })),
            Ok(None) => Ok(None),
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    pub fn get_edge_attribute(&self, edge: EdgeId, attr: AttrName) -> PyResult<Option<PyAttrValue>> {
        match self.inner.get_edge_attr(edge, &attr) {
            Ok(Some(value)) => Ok(Some(PyAttrValue { inner: value })),
            Ok(None) => Ok(None),
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }

    fn get_edge_attributes(&self, edge: EdgeId, py: Python) -> PyResult<PyObject> {
        let attrs = self.inner.get_edge_attrs(edge)
            .map_err(graph_error_to_py_err)?;
        
        // Convert HashMap to Python dict
        let dict = PyDict::new(py);
        for (attr_name, attr_value) in attrs {
            let py_value = Py::new(py, PyAttrValue { inner: attr_value })?;
            dict.set_item(attr_name, py_value)?;
        }
        Ok(dict.to_object(py))
    }
    
    // === TOPOLOGY OPERATIONS ===
    
    fn contains_node(&self, node: NodeId) -> bool {
        self.inner.contains_node(node) 
    }
    
    fn contains_edge(&self, edge: EdgeId) -> bool {
        self.inner.contains_edge(edge)
    }
    
    fn edge_endpoints(&self, edge: EdgeId) -> PyResult<(NodeId, NodeId)> {
        self.inner.edge_endpoints(edge)
            .map_err(graph_error_to_py_err)
    }

    /// Get all active node IDs as GraphArray (lazy Rust view) - use .values for Python list
    #[getter]
    fn node_ids(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let node_ids = self.inner.node_ids();
        let attr_values: Vec<groggy::AttrValue> = node_ids.into_iter()
            .map(|id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }
    
    /// Get all active edge IDs as GraphArray (lazy Rust view) - use .values for Python list
    #[getter]
    fn edge_ids(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let edge_ids = self.inner.edge_ids();
        let attr_values: Vec<groggy::AttrValue> = edge_ids.into_iter()
            .map(|id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }
    
    /// Get nodes accessor for fluent API (g.nodes property) 
    #[getter]
    fn nodes(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyNodesAccessor>> {
        let graph_ref = self_.into();
        PyGraph::create_nodes_accessor_internal(graph_ref, py)
    }
    
    /// Get edges accessor for fluent API (g.edges property)
    #[getter]
    fn edges(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyEdgesAccessor>> {
        let graph_ref = self_.into();
        PyGraph::create_edges_accessor_internal(graph_ref, py)
    }
    
    // === BULK OPERATIONS FOR BENCHMARK COMPATIBILITY ===
    
    /// Set bulk node attributes using the format expected by benchmark
    fn set_node_attributes(&mut self, _py: Python, attrs_dict: &PyDict) -> PyResult<()> {
        use groggy::AttrValue as RustAttrValue;
        use pyo3::exceptions::{PyKeyError, PyValueError};
        
        // HYPER-OPTIMIZED bulk API - minimize PyO3 overhead and allocations
        let mut attrs_values = std::collections::HashMap::with_capacity(attrs_dict.len());
        
        for (attr_name, attr_data) in attrs_dict {
            let attr: AttrName = attr_name.extract()?;
            let data_dict: &PyDict = attr_data.downcast()?;
            
            // OPTIMIZATION: Extract all fields at once to reduce PyO3 calls
            let (nodes, values_obj, value_type): (Vec<NodeId>, &pyo3::PyAny, String) = {
                let nodes_item = data_dict.get_item("nodes")?.ok_or_else(|| 
                    PyErr::new::<PyKeyError, _>("Missing 'nodes' key"))?;
                let values_item = data_dict.get_item("values")?.ok_or_else(|| 
                    PyErr::new::<PyKeyError, _>("Missing 'values' key"))?;
                let type_item = data_dict.get_item("value_type")?.ok_or_else(|| 
                    PyErr::new::<PyKeyError, _>("Missing 'value_type' key"))?;
                    
                (nodes_item.extract()?, values_item, type_item.extract()?)
            };
            
            let len = nodes.len();
            
            // OPTIMIZATION: Pre-allocate result vector and use direct indexing
            let mut pairs = Vec::with_capacity(len);
            
            // OPTIMIZATION: Match on str slice to avoid repeated string comparisons
            match value_type.as_str() {
                "text" => {
                    let values: Vec<String> = values_obj.extract()?;
                    if values.len() != len {
                        return Err(PyErr::new::<PyValueError, _>("Length mismatch"));
                    }
                    
                    // OPTIMIZATION: Direct loop instead of iterator chain
                    for i in 0..len {
                        pairs.push((nodes[i], RustAttrValue::Text(values[i].clone())));
                    }
                },
                "int" => {
                    let values: Vec<i64> = values_obj.extract()?;
                    if values.len() != len {
                        return Err(PyErr::new::<PyValueError, _>("Length mismatch"));
                    }
                    
                    for i in 0..len {
                        pairs.push((nodes[i], RustAttrValue::Int(values[i])));
                    }
                },
                "float" => {
                    let values: Vec<f64> = values_obj.extract()?;
                    if values.len() != len {
                        return Err(PyErr::new::<PyValueError, _>("Length mismatch"));
                    }
                    
                    for i in 0..len {
                        pairs.push((nodes[i], RustAttrValue::Float(values[i] as f32)));
                    }
                },
                "bool" => {
                    let values: Vec<bool> = values_obj.extract()?;
                    if values.len() != len {
                        return Err(PyErr::new::<PyValueError, _>("Length mismatch"));
                    }
                    
                    for i in 0..len {
                        pairs.push((nodes[i], RustAttrValue::Bool(values[i])));
                    }
                },
                _ => return Err(PyErr::new::<PyValueError, _>("Unsupported type"))
            };
            
            attrs_values.insert(attr, pairs);
        }
        
        self.inner.set_node_attrs(attrs_values)
            .map_err(graph_error_to_py_err)
    }
    
    /// Set bulk edge attributes using the format expected by benchmark
    fn set_edge_attributes(&mut self, _py: Python, attrs_dict: &PyDict) -> PyResult<()> {
        use groggy::AttrValue as RustAttrValue;
        use pyo3::exceptions::{PyKeyError, PyValueError};
        
        // New efficient columnar API for edges - zero PyAttrValue objects created!
        let mut attrs_values = std::collections::HashMap::new();
        
        for (attr_name, attr_data) in attrs_dict {
            let attr: AttrName = attr_name.extract()?;
            let data_dict: &PyDict = attr_data.downcast()?;
            
            // Extract components in bulk using the same pattern as node attributes
            let edges: Vec<EdgeId> = if let Ok(Some(item)) = data_dict.get_item("edges") {
                item.extract()?
            } else {
                return Err(PyErr::new::<PyKeyError, _>("Missing 'edges' key in attribute data"));
            };
            let value_type: String = if let Ok(Some(item)) = data_dict.get_item("value_type") {
                item.extract()?
            } else {
                return Err(PyErr::new::<PyKeyError, _>("Missing 'value_type' key in attribute data"));
            };
            
            // Batch convert based on known type - no individual type detection!
            let pairs = match value_type.as_str() {
                "text" => {
                    let values: Vec<String> = if let Ok(Some(item)) = data_dict.get_item("values") {
                        item.extract()?
                    } else {
                        return Err(PyErr::new::<PyKeyError, _>("Missing 'values' key in attribute data"));
                    };
                    
                    if values.len() != edges.len() {
                        return Err(PyErr::new::<PyValueError, _>(
                            format!("Mismatched lengths: {} edges vs {} values", edges.len(), values.len())
                        ));
                    }
                    
                    edges.into_iter()
                        .zip(values.into_iter())
                        .map(|(edge, val)| (edge, RustAttrValue::Text(val)))
                        .collect()
                },
                "int" => {
                    let values: Vec<i64> = if let Ok(Some(item)) = data_dict.get_item("values") {
                        item.extract()?
                    } else {
                        return Err(PyErr::new::<PyKeyError, _>("Missing 'values' key in attribute data"));
                    };
                    
                    if values.len() != edges.len() {
                        return Err(PyErr::new::<PyValueError, _>(
                            format!("Mismatched lengths: {} edges vs {} values", edges.len(), values.len())
                        ));
                    }
                    
                    edges.into_iter()
                        .zip(values.into_iter())
                        .map(|(edge, val)| (edge, RustAttrValue::Int(val)))
                        .collect()
                },
                "float" => {
                    let values: Vec<f64> = if let Ok(Some(item)) = data_dict.get_item("values") {
                        item.extract()?
                    } else {
                        return Err(PyErr::new::<PyKeyError, _>("Missing 'values' key in attribute data"));
                    };
                    
                    if values.len() != edges.len() {
                        return Err(PyErr::new::<PyValueError, _>(
                            format!("Mismatched lengths: {} edges vs {} values", edges.len(), values.len())
                        ));
                    }
                    
                    edges.into_iter()
                        .zip(values.into_iter())
                        .map(|(edge, val)| (edge, RustAttrValue::Float(val as f32)))
                        .collect()
                },
                "bool" => {
                    let values: Vec<bool> = if let Ok(Some(item)) = data_dict.get_item("values") {
                        item.extract()?
                    } else {
                        return Err(PyErr::new::<PyKeyError, _>("Missing 'values' key in attribute data"));
                    };
                    
                    if values.len() != edges.len() {
                        return Err(PyErr::new::<PyValueError, _>(
                            format!("Mismatched lengths: {} edges vs {} values", edges.len(), values.len())
                        ));
                    }
                    
                    edges.into_iter()
                        .zip(values.into_iter())
                        .map(|(edge, val)| (edge, RustAttrValue::Bool(val)))
                        .collect()
                },
                _ => {
                    return Err(PyErr::new::<PyValueError, _>(
                        format!("Unsupported value_type: {}", value_type)
                    ));
                }
            };
            
            attrs_values.insert(attr, pairs);
        }
        
        self.inner.set_edge_attrs(attrs_values)
            .map_err(graph_error_to_py_err)
    }
    
    /// Add multiple edges at once
    fn add_edges(&mut self, edges: &PyAny, node_mapping: Option<std::collections::HashMap<String, NodeId>>, _uid_key: Option<String>) -> PyResult<Vec<EdgeId>> {
        // Format 1: List of (source, target) tuples - most common case for benchmarks
        if let Ok(edge_pairs) = edges.extract::<Vec<(NodeId, NodeId)>>() {
            return Ok(self.inner.add_edges(&edge_pairs));
        }
        
        // Format 2: List of (source, target, attrs_dict) tuples  
        else if let Ok(edge_tuples) = edges.extract::<Vec<(&PyAny, &PyAny, Option<&PyDict>)>>() {
            let mut edge_ids = Vec::new();
            let mut edges_with_attrs = Vec::new();
            
            // First pass: create all edges and collect attribute data
            for (src_any, tgt_any, attrs_opt) in edge_tuples {
                let source: NodeId = src_any.extract()?;
                let target: NodeId = tgt_any.extract()?;
                
                let edge_id = self.inner.add_edge(source, target)
                    .map_err(graph_error_to_py_err)?;
                edge_ids.push(edge_id);
                
                // Store edge attributes for bulk processing
                if let Some(attrs) = attrs_opt {
                    edges_with_attrs.push((edge_id, attrs));
                }
            }
            
            // OPTIMIZATION: Use bulk attribute setting instead of individual calls
            if !edges_with_attrs.is_empty() {
                let mut attrs_by_name: std::collections::HashMap<String, Vec<(EdgeId, RustAttrValue)>> = std::collections::HashMap::new();
                
                for (edge_id, attrs) in edges_with_attrs {
                    for (key, value) in attrs.iter() {
                        let attr_name: String = key.extract()?;
                        let attr_value = python_value_to_attr_value(value)?;
                        
                        attrs_by_name.entry(attr_name).or_insert_with(Vec::new).push((edge_id, attr_value));
                    }
                }
                
                self.inner.set_edge_attrs(attrs_by_name)
                    .map_err(graph_error_to_py_err)?;
            }
            
            return Ok(edge_ids);
        }
        
        // Format 3: List of dictionaries with node mapping
        else if let Ok(edge_dicts) = edges.extract::<Vec<&PyDict>>() {
            let mut edge_ids = Vec::new();
            let mut edges_with_attrs = Vec::new();
            
            // First pass: create all edges and collect attribute data
            for edge_dict in edge_dicts {
                // Extract source and target
                let source = if let Some(mapping) = &node_mapping {
                    let source_str: String = edge_dict.get_item("source")?.unwrap().extract()?;
                    *mapping.get(&source_str).ok_or_else(|| 
                        pyo3::exceptions::PyKeyError::new_err(format!("Node {} not found in mapping", source_str)))?
                } else {
                    edge_dict.get_item("source")?.unwrap().extract()?
                };
                
                let target = if let Some(mapping) = &node_mapping {
                    let target_str: String = edge_dict.get_item("target")?.unwrap().extract()?;
                    *mapping.get(&target_str).ok_or_else(|| 
                        pyo3::exceptions::PyKeyError::new_err(format!("Node {} not found in mapping", target_str)))?
                } else {
                    edge_dict.get_item("target")?.unwrap().extract()?
                };
                
                // Add the edge
                let edge_id = self.inner.add_edge(source, target)
                    .map_err(graph_error_to_py_err)?;
                edge_ids.push(edge_id);
                
                // Store edge and its attributes for bulk processing
                edges_with_attrs.push((edge_id, edge_dict));
            }
            
            // OPTIMIZATION: Use bulk attribute setting instead of individual calls
            if !edges_with_attrs.is_empty() {
                let mut attrs_by_name: std::collections::HashMap<String, Vec<(EdgeId, RustAttrValue)>> = std::collections::HashMap::new();
                
                for (edge_id, edge_dict) in edges_with_attrs {
                    for (key, value) in edge_dict.iter() {
                        let key_str: String = key.extract()?;
                        if key_str != "source" && key_str != "target" {
                            let attr_value = python_value_to_attr_value(value)?;
                            attrs_by_name.entry(key_str).or_insert_with(Vec::new).push((edge_id, attr_value));
                        }
                    }
                }
                
                if !attrs_by_name.is_empty() {
                    self.inner.set_edge_attrs(attrs_by_name)
                        .map_err(graph_error_to_py_err)?;
                }
            }
            
            return Ok(edge_ids);
        }
        
        // If none of the formats matched, return error
        Err(PyErr::new::<pyo3::exceptions::PyTypeError, _>(
            "add_edges expects a list of (source, target) tuples, (source, target, attrs) tuples, or dictionaries with node_mapping"
        ))
    }
    
    /// Filter nodes using NodeFilter object or string query
    fn filter_nodes(mut slf: PyRefMut<Self>, py: Python, filter: &PyAny) -> PyResult<PySubgraph> {
        // Fast path optimization: Check for NodeFilter object first (most common case)
        let node_filter = if let Ok(filter_obj) = filter.extract::<PyNodeFilter>() {
            // Direct NodeFilter object - fastest path
            filter_obj.inner.clone()
        } else if let Ok(query_str) = filter.extract::<String>() {
            // String query - parse it using our query parser
            let query_parser = py.import("groggy.query_parser")?;
            let parse_func = query_parser.getattr("parse_node_query")?;
            let parsed_filter: PyNodeFilter = parse_func.call1((query_str,))?.extract()?;
            parsed_filter.inner.clone()
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "filter must be a NodeFilter object or a string query (e.g., 'salary > 120000')"
            ));
        };
        
        let start = std::time::Instant::now();
        let filtered_nodes = slf.inner.find_nodes(node_filter)
            .map_err(graph_error_to_py_err)?;

        let elapsed = start.elapsed();
        
        let start = std::time::Instant::now();
        // O(k) Calculate induced edges using optimized core subgraph method
        use std::collections::HashSet;
        let node_set: HashSet<NodeId> = filtered_nodes.iter().copied().collect();
        
        // Get columnar topology vectors (edge_ids, sources, targets) - O(1) if cached
        let (edge_ids, sources, targets) = slf.inner.get_columnar_topology();
        let mut induced_edges = Vec::new();
        
        // Iterate through parallel vectors - O(k) where k = active edges
        for i in 0..edge_ids.len() {
            let edge_id = edge_ids[i];
            let source = sources[i];
            let target = targets[i];
            
            // O(1) HashSet lookups instead of O(n) Vec::contains
            if node_set.contains(&source) && node_set.contains(&target) {
                induced_edges.push(edge_id);
            }
        }
        
        let elapsed = start.elapsed();
        
        Ok(PySubgraph::new(
            filtered_nodes,
            induced_edges,
            "filtered_nodes".to_string(),
            Some(slf.into()),
        ))
    }
    
    /// Filter edges using EdgeFilter object or string query
    fn filter_edges(mut slf: PyRefMut<Self>, py: Python, filter: &PyAny) -> PyResult<PySubgraph> {
        // Fast path optimization: Check for EdgeFilter object first (most common case)
        let edge_filter = if let Ok(filter_obj) = filter.extract::<PyEdgeFilter>() {
            // Direct EdgeFilter object - fastest path
            filter_obj.inner.clone()
        } else if let Ok(query_str) = filter.extract::<String>() {
            // String query - parse it using our query parser
            let query_parser = py.import("groggy.query_parser")?;
            let parse_func = query_parser.getattr("parse_edge_query")?;
            let parsed_filter: PyEdgeFilter = parse_func.call1((query_str,))?.extract()?;
            parsed_filter.inner.clone()
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "filter must be an EdgeFilter object or a string query"
            ));
        };
        
        let filtered_edges = slf.inner.find_edges(edge_filter)
            .map_err(graph_error_to_py_err)?;
        
        // Calculate nodes that are connected by the filtered edges
        use std::collections::HashSet;
        let mut nodes = HashSet::new();
        for &edge_id in &filtered_edges {
            if let Ok((source, target)) = slf.inner.edge_endpoints(edge_id) {
                nodes.insert(source);
                nodes.insert(target);
            }
        }
        
        let node_vec: Vec<NodeId> = nodes.into_iter().collect();
        
        Ok(PySubgraph::new(
            node_vec,
            filtered_edges,
            "filtered_edges".to_string(),
            Some(slf.into()),
        ))
    }
    
    /// Get analytics module for this graph
    #[getter]
    fn analytics(slf: PyRef<Self>, py: Python) -> PyResult<Py<crate::ffi::api::graph_analytics::PyGraphAnalytics>> {
        use crate::ffi::api::graph_analytics::PyGraphAnalytics;
        let graph_ref: Py<PyGraph> = slf.into_py(py).extract(py)?;
        let analytics = PyGraphAnalytics { graph: graph_ref };
        Py::new(py, analytics)
    }
    
    /// Group nodes by attribute value and compute aggregates for each group
    pub fn group_nodes_by_attribute(&self, attribute: AttrName, aggregation_attr: AttrName, operation: String) -> PyResult<PyGroupedAggregationResult> {
        let results = self.inner.group_nodes_by_attribute(&attribute, &aggregation_attr, &operation)
            .map_err(graph_error_to_py_err)?;
        
        Python::with_gil(|py| {
            // Convert HashMap to Python dict
            let dict = PyDict::new(py);
            for (attr_value, agg_result) in results {
                let py_attr_value = PyAttrValue { inner: attr_value };
                let py_agg_result = PyAggregationResult { value: agg_result.value };
                dict.set_item(Py::new(py, py_attr_value)?, Py::new(py, py_agg_result)?)?;
            }
            
            Ok(PyGroupedAggregationResult {
                groups: dict.to_object(py),
                operation: operation.clone(),
                attribute: attribute.clone(),
            })
        })
    }
    
    /// Group nodes by attribute value and compute aggregates (public method for benchmarks)
    pub fn group_by(&self, attribute: AttrName, aggregation_attr: AttrName, operation: String) -> PyResult<PyGroupedAggregationResult> {
        self.group_nodes_by_attribute_internal(attribute, aggregation_attr, operation)
    }
    
    // === REMOVAL OPERATIONS ===
    
    /// Remove a single node from the graph
    fn remove_node(&mut self, node: NodeId) -> PyResult<()> {
        self.inner.remove_node(node)
            .map_err(graph_error_to_py_err)
    }
    
    /// Remove a single edge from the graph
    fn remove_edge(&mut self, edge: EdgeId) -> PyResult<()> {
        self.inner.remove_edge(edge)
            .map_err(graph_error_to_py_err)
    }
    
    /// Remove multiple nodes from the graph
    fn remove_nodes(&mut self, nodes: Vec<NodeId>) -> PyResult<()> {
        self.inner.remove_nodes(&nodes)
            .map_err(graph_error_to_py_err)
    }
    
    /// Remove multiple edges from the graph
    fn remove_edges(&mut self, edges: Vec<EdgeId>) -> PyResult<()> {
        self.inner.remove_edges(&edges)
            .map_err(graph_error_to_py_err)
    }
    
    // === SINGLE EDGE ADDITION ===
    
    /// Add a single edge to the graph with support for string IDs and attributes
    #[pyo3(signature = (source, target, uid_key = None, **kwargs))]
    fn add_edge(&mut self, py: Python, source: &PyAny, target: &PyAny, uid_key: Option<String>, kwargs: Option<&PyDict>) -> PyResult<EdgeId> {
        // Try to extract as NodeId first (most common case)
        let source_id = if let Ok(node_id) = source.extract::<NodeId>() {
            node_id
        } else if let Ok(string_id) = source.extract::<String>() {
            if let Some(ref key) = uid_key {
                self.resolve_string_id_to_node(&string_id, key)?
            } else {
                return Err(PyErr::new::<PyTypeError, _>("String node IDs require uid_key parameter"));
            }
        } else {
            return Err(PyErr::new::<PyTypeError, _>("Source must be NodeId or string"));
        };
        
        let target_id = if let Ok(node_id) = target.extract::<NodeId>() {
            node_id
        } else if let Ok(string_id) = target.extract::<String>() {
            if let Some(ref key) = uid_key {
                self.resolve_string_id_to_node(&string_id, key)?
            } else {
                return Err(PyErr::new::<PyTypeError, _>("String node IDs require uid_key parameter"));
            }
        } else {
            return Err(PyErr::new::<PyTypeError, _>("Target must be NodeId or string"));
        };
        
        // Add the edge
        let edge_id = self.inner.add_edge(source_id, target_id)
            .map_err(graph_error_to_py_err)?;
        
        // Set attributes if provided
        if let Some(attrs) = kwargs {
            if !attrs.is_empty() {
                for (key, value) in attrs.iter() {
                    let attr_name: String = key.extract()?;
                    let attr_value = python_value_to_attr_value(value)?;
                    self.inner.set_edge_attr(edge_id, attr_name, attr_value)
                        .map_err(graph_error_to_py_err)?;
                }
            }
        }
        
        Ok(edge_id)
    }
    
    // === ALGORITHM OPERATIONS ===
    
    /// Find shortest path between two nodes (DEPRECATED - use graph.analytics.shortest_path() instead)
    #[pyo3(signature = (source, target, weight_attribute = None, inplace = None, attr_name = None))]
    fn shortest_path(slf: PyRef<Self>, py: Python, source: NodeId, target: NodeId, weight_attribute: Option<AttrName>, 
                    inplace: Option<bool>, attr_name: Option<String>) -> PyResult<Option<PySubgraph>> {
        
        // Delegate to analytics module which has proper graph reference handling
        let analytics = PyGraph::analytics(slf, py)?;
        let result = analytics.borrow(py).shortest_path(py, source, target, weight_attribute, inplace, attr_name);
        result
    }
    
    /// Aggregate attribute values across nodes or edges
    #[pyo3(signature = (attribute, operation, target = None, node_ids = None))]
    fn aggregate(&self, py: Python, attribute: AttrName, operation: String, target: Option<String>, node_ids: Option<Vec<NodeId>>) -> PyResult<PyObject> {
        let target = target.unwrap_or_else(|| "nodes".to_string());
        
        match target.as_str() {
            "nodes" => {
                // TODO: Core doesn't have aggregate_nodes_custom, implement if needed
                let result = self.inner.aggregate_node_attribute(&attribute, &operation);
                match result {
                    Ok(agg_result) => {
                        let py_result = PyAggregationResult { value: agg_result.value };
                        Ok(Py::new(py, py_result)?.to_object(py))
                    },
                    Err(e) => Err(graph_error_to_py_err(e)),
                }
            },
            "edges" => {
                let result = self.inner.aggregate_edge_attribute(&attribute, &operation);
                match result {
                    Ok(agg_result) => {
                        let py_result = PyAggregationResult { value: agg_result.value };
                        Ok(Py::new(py, py_result)?.to_object(py))
                    },
                    Err(e) => Err(graph_error_to_py_err(e)),
                }
            },
            _ => Err(PyErr::new::<PyTypeError, _>("Target must be 'nodes' or 'edges'")),
        }
    }
    
    // === VERSION CONTROL OPERATIONS ===
    
    /// Commit current state of the graph (FFI wrapper around core history system)
    fn commit(&mut self, message: String, author: String) -> PyResult<StateId> {
        self.inner.commit(message, author)
            .map_err(graph_error_to_py_err)
    }
    
    /// Create a new branch (FFI wrapper around core history system)
    fn create_branch(&mut self, branch_name: String) -> PyResult<()> {
        self.inner.create_branch(branch_name)
            .map_err(graph_error_to_py_err)
    }
    
    /// Checkout a branch (FFI wrapper around core history system)
    fn checkout_branch(&mut self, branch_name: String) -> PyResult<()> {
        self.inner.checkout_branch(branch_name)
            .map_err(graph_error_to_py_err)
    }
    
    /// List all branches (FFI wrapper around core history system)
    fn branches(&self) -> Vec<PyBranchInfo> {
        self.inner.list_branches()
            .into_iter()
            .map(|branch_info| PyBranchInfo::new(branch_info))
            .collect()
    }
    
    /// Get commit history (FFI wrapper around core history system)
    fn commit_history(&self) -> Vec<PyCommit> {
        // Delegate to core history system
        self.inner.commit_history()
            .into_iter()
            .map(|commit_info| PyCommit::from_commit_info(commit_info))
            .collect()
    }
    
    /// Get historical view at specific commit (FFI wrapper around core history system)
    fn historical_view(&self, commit_id: StateId) -> PyResult<PyHistoricalView> {
        // Delegate to core history system
        match self.inner.view_at_commit(commit_id) {
            Ok(_historical_view) => {
                Ok(PyHistoricalView {
                    state_id: commit_id,
                })
            },
            Err(e) => Err(graph_error_to_py_err(e)),
        }
    }
    
    // === STATE METHODS ===
    
    /// Check if there are uncommitted changes (FFI wrapper around core history system)
    fn has_uncommitted_changes(&self) -> bool {
        self.inner.has_uncommitted_changes()
    }
    
    /// Get node mapping for a specific attribute (FFI wrapper around core operations)
    fn get_node_mapping(&self, py: Python, uid_key: String) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        
        // Delegate to core for node IDs and attributes
        let node_ids = self.inner.node_ids();
        
        // Use core attribute access for each node
        for node_id in node_ids {
            if let Ok(Some(attr_value)) = self.inner.get_node_attr(node_id, &uid_key) {
                // Convert attribute value to appropriate Python type
                let key_value = match attr_value {
                    RustAttrValue::Text(s) => s.to_object(py),
                    RustAttrValue::CompactText(s) => s.as_str().to_object(py),
                    RustAttrValue::Int(i) => i.to_object(py),
                    RustAttrValue::SmallInt(i) => i.to_object(py), 
                    RustAttrValue::Float(f) => f.to_object(py),
                    RustAttrValue::Bool(b) => b.to_object(py),
                    _ => continue, // Skip unsupported types
                };
                
                dict.set_item(key_value, node_id)?;
            }
        }
        
        Ok(dict.to_object(py))
    }
    
    // === ADJACENCY MATRIX OPERATIONS ===
    
    /// Generate adjacency matrix for the entire graph (FFI wrapper around core matrix operations)
    /// Returns: GraphMatrix with multi-index access (matrix[0, 1])
    fn adjacency_matrix(&mut self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.adjacency_matrix() {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(graph_error_to_py_err(e))
        }
    }
    
    /// Generate adjacency matrix for the entire graph (cleaner API)
    /// Returns: GraphMatrix with multi-index access (matrix[0, 1])
    /// This is a cleaner alias for adjacency_matrix()
    fn adjacency(&mut self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        self.adjacency_matrix(py)
    }
    
    /// Generate weighted adjacency matrix using specified edge attribute (FFI wrapper around core matrix operations)
    fn weighted_adjacency_matrix(&mut self, py: Python, weight_attr: &str) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.weighted_adjacency_matrix(weight_attr) {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(graph_error_to_py_err(e))
        }
    }
    
    /// Generate dense adjacency matrix (FFI wrapper around core matrix operations)
    fn dense_adjacency_matrix(&mut self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.dense_adjacency_matrix() {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(graph_error_to_py_err(e))
        }
    }
    
    /// Generate sparse adjacency matrix (FFI wrapper around core matrix operations)
    fn sparse_adjacency_matrix(&mut self, py: Python) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.sparse_adjacency_matrix() {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(graph_error_to_py_err(e))
        }
    }
    
    /// Generate Laplacian matrix (FFI wrapper around core matrix operations)
    fn laplacian_matrix(&mut self, py: Python, normalized: Option<bool>) -> PyResult<Py<PyGraphMatrix>> {
        let normalized = normalized.unwrap_or(false);
        match self.inner.laplacian_matrix(normalized) {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(graph_error_to_py_err(e))
        }
    }
    
    /// Generate adjacency matrix for a subgraph with specific nodes (FFI wrapper around core matrix operations)
    fn subgraph_adjacency_matrix(&mut self, py: Python, node_ids: Vec<NodeId>) -> PyResult<Py<PyGraphMatrix>> {
        match self.inner.subgraph_adjacency_matrix(&node_ids) {
            Ok(matrix) => {
                adjacency_matrix_to_py_graph_matrix(py, matrix)
            },
            Err(e) => Err(graph_error_to_py_err(e))
        }
    }
    
    // === DISPLAY/TABLE METHODS ===
    
    /// Get all neighbors of a node
    fn neighbors(&mut self, node: NodeId) -> PyResult<Vec<NodeId>> {
        self.inner.neighbors(node)
            .map_err(graph_error_to_py_err)
    }
    
    /// Return a full-view Subgraph (whole graph as a subgraph).
    /// Downstream code can always resolve parent graph from this object.
    pub fn view(self_: PyRef<Self>, py: Python<'_>) -> PyResult<Py<PySubgraph>> {
        // Pull ids via existing accessors
        let nodes: Vec<NodeId> = self_.inner.node_ids();
        let edges: Vec<EdgeId> = self_.inner.edge_ids();

        let mut sg = PySubgraph::new(nodes, edges, "full".to_string(), None);
        let this_graph: Py<PyGraph> = self_.into();
        sg.set_graph_reference(this_graph);
        Py::new(py, sg)
    }
    
    /// Create GraphTable for DataFrame-like view of this graph's nodes
    /// Forwards to the subgraph implementation to maintain consistency
    pub fn table(self_: PyRef<Self>, py: Python<'_>) -> PyResult<PyObject> {
        let sg = Self::view(self_, py)?;
        let t = sg.call_method0(py, "table")?;
        Ok(t.to_object(py))
    }
    
    /// Create GraphTable for DataFrame-like view of this graph's edges  
    /// Forwards to the subgraph implementation to maintain consistency
    pub fn edges_table(self_: PyRef<Self>, py: Python<'_>) -> PyResult<PyObject> {
        let sg = Self::view(self_, py)?;
        let t = sg.call_method0(py, "edges_table")?;
        Ok(t.to_object(py))
    }
    
}

// Internal methods for FFI integration (not exposed to Python)
impl PyGraph {
    /// Internal helper methods for accessors/views
    pub fn create_node_view_internal(graph: Py<PyGraph>, py: Python, node_id: NodeId) -> PyResult<Py<PyNodeView>> {
        Py::new(py, PyNodeView {
            graph,
            node_id,
        })
    }
    
    pub fn create_edge_view_internal(graph: Py<PyGraph>, py: Python, edge_id: EdgeId) -> PyResult<Py<PyEdgeView>> {
        Py::new(py, PyEdgeView {
            graph,
            edge_id,
        })
    }

    /// Create a NodesAccessor (internal helper)
    fn create_nodes_accessor_internal(graph_ref: Py<PyGraph>, py: Python) -> PyResult<Py<PyNodesAccessor>> {
        Py::new(py, PyNodesAccessor {
            graph: graph_ref,
            constrained_nodes: None,
        })
    }
    
    /// Create an EdgesAccessor (internal helper)
    fn create_edges_accessor_internal(graph_ref: Py<PyGraph>, py: Python) -> PyResult<Py<PyEdgesAccessor>> {
        Py::new(py, PyEdgesAccessor {
            graph: graph_ref,
            constrained_edges: None,
        })
    }
    
    pub fn node_attribute_keys(&self, node_id: NodeId) -> Vec<String> {
        match self.inner.get_node_attrs(node_id) {
            Ok(attrs) => attrs.keys().cloned().collect(),
            Err(_) => Vec::new(),
        }
    }
    
    pub fn edge_attribute_keys(&self, edge_id: EdgeId) -> Vec<String> {
        match self.inner.get_edge_attrs(edge_id) {
            Ok(attrs) => attrs.keys().cloned().collect(),
            Err(_) => Vec::new(),
        }
    }
    
    // === HELPER METHODS FOR OTHER MODULES ===
    
    pub fn has_node_attribute(&self, node_id: NodeId, attr_name: &str) -> bool {
        match self.inner.get_node_attr(node_id, &attr_name.to_string()) {
            Ok(Some(_)) => true,
            _ => false,
        }
    }
    
    pub fn has_edge_attribute(&self, edge_id: EdgeId, attr_name: &str) -> bool {
        match self.inner.get_edge_attr(edge_id, &attr_name.to_string()) {
            Ok(Some(_)) => true,
            _ => false,
        }
    }
    
    
    pub fn get_edge_endpoints(&self, edge_id: EdgeId) -> Result<(NodeId, NodeId), String> {
        self.inner.edge_endpoints(edge_id).map_err(|e| e.to_string())
    }
    
    
    pub fn get_node_ids(&self) -> PyResult<Vec<NodeId>> {
        Ok(self.inner.node_ids())
    }
    
    pub fn get_edge_ids(&self) -> PyResult<Vec<EdgeId>> {
        Ok(self.inner.edge_ids())
    }
    
    // Additional public methods for internal module access
    pub fn has_node_internal(&self, node_id: NodeId) -> bool {
        self.inner.contains_node(node_id)
    }
    
    pub fn has_edge_internal(&self, edge_id: EdgeId) -> bool {
        self.inner.contains_edge(edge_id)
    }
    
    pub fn get_node_count(&self) -> usize {
        self.inner.node_ids().len()
    }
    
    pub fn get_edge_count(&self) -> usize {
        self.inner.edge_ids().len()
    }
    
    pub fn node_ids_vec(&self) -> Vec<NodeId> {
        self.inner.node_ids()
    }
    
    pub fn edge_ids_vec(&self) -> Vec<EdgeId> {
        self.inner.edge_ids()
    }
    
    pub fn get_node_ids_array(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let node_ids = self.inner.node_ids();
        let attr_values: Vec<groggy::AttrValue> = node_ids.into_iter()
            .map(|id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::core::array::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }

    pub fn get_edge_ids_array(&self, py: Python) -> PyResult<Py<PyGraphArray>> {
        let edge_ids = self.inner.edge_ids();
        let attr_values: Vec<groggy::AttrValue> = edge_ids.into_iter()
            .map(|id| groggy::AttrValue::Int(id as i64))
            .collect();
        let graph_array = groggy::core::array::GraphArray::from_vec(attr_values);
        let py_graph_array = PyGraphArray { inner: graph_array };
        Ok(Py::new(py, py_graph_array)?)
    }
    
    /// Group nodes by attribute value and compute aggregates for each group (internal method)
    pub fn group_nodes_by_attribute_internal(&self, attribute: AttrName, aggregation_attr: AttrName, operation: String) -> PyResult<PyGroupedAggregationResult> {
        let results = self.inner.group_nodes_by_attribute(&attribute, &aggregation_attr, &operation)
            .map_err(graph_error_to_py_err)?;
        
        Python::with_gil(|py| {
            // Convert HashMap to Python dict
            let dict = PyDict::new(py);
            for (attr_value, agg_result) in results {
                let py_attr_value = PyAttrValue { inner: attr_value };
                let py_agg_result = PyAggregationResult { value: agg_result.value };
                dict.set_item(Py::new(py, py_attr_value)?, Py::new(py, py_agg_result)?)?;
            }
            
            Ok(PyGroupedAggregationResult {
                groups: dict.to_object(py),
                operation: operation.clone(),
                attribute: attribute.clone(),
            })
        })
    }

    /// Get complete attribute column for ALL nodes (optimized for table() method)
    /// Returns GraphArray for enhanced analytics and proper integration with table columns
    fn _get_node_attribute_column(&self, py: Python, attr_name: &str) -> PyResult<Py<PyGraphArray>> {
        match self.inner._get_node_attribute_column(&attr_name.to_string()) {
            Ok(values) => {
                // Convert Option<AttrValue> vector to AttrValue vector (convert None to appropriate AttrValue)
                let attr_values: Vec<groggy::AttrValue> = values.into_iter()
                    .map(|opt_val| opt_val.unwrap_or(groggy::AttrValue::Int(0))) // Use default for None values
                    .collect();
                
                // Create GraphArray and convert to PyGraphArray
                let graph_array = groggy::core::array::GraphArray::from_vec(attr_values);
                let py_graph_array = PyGraphArray::from_graph_array(graph_array);
                
                Py::new(py, py_graph_array)
            },
            Err(e) => Err(graph_error_to_py_err(e))
        }
    }
}

--- FILE: ffi/api/mod.rs ---
//! API FFI Module Coordinator
//! 
//! This module coordinates FFI bindings for all API components.

// Graph API FFI bindings
pub mod graph_query;
pub mod graph_analytics;
pub mod graph_version;
pub mod graph;

// Re-export API FFI types
pub use graph_query::*;
pub use graph_analytics::*;
pub use graph_version::*;
pub use graph::*;


--- FILE: ffi/api/graph_query.rs ---
//! Graph Query Module
//! 
//! Python bindings for advanced query operations on graphs.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyValueError, PyTypeError, PyRuntimeError};
use groggy::{NodeId, EdgeId, AttrName};
use crate::ffi::types::PyAttrValue;
use crate::ffi::utils::{graph_error_to_py_err, attr_value_to_python_value};
use crate::ffi::core::subgraph::PySubgraph;
use crate::ffi::core::query::{PyNodeFilter, PyEdgeFilter};
use std::collections::HashSet;

/// Query operations for graphs
#[pyclass(name = "GraphQuery")]
pub struct PyGraphQuery {
    /// Reference to the parent graph
    pub graph: Py<crate::ffi::api::graph::PyGraph>,
}

#[pymethods]
impl PyGraphQuery {
    /// Filter nodes by criteria
    pub fn filter_nodes(&self, py: Python, filter: &PyAny) -> PyResult<PySubgraph> {
        let mut graph = self.graph.borrow_mut(py);
        
        // Fast path optimization: Check for NodeFilter object first (most common case)
        let node_filter = if let Ok(filter_obj) = filter.extract::<PyNodeFilter>() {
            // Direct NodeFilter object - fastest path
            filter_obj.inner.clone()
        } else if let Ok(query_str) = filter.extract::<String>() {
            // String query - parse it using our query parser
            let query_parser = py.import("groggy.query_parser")?;
            let parse_func = query_parser.getattr("parse_node_query")?;
            let parsed_filter: PyNodeFilter = parse_func.call1((query_str,))?.extract()?;
            parsed_filter.inner.clone()
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "filter must be a NodeFilter object or a string query (e.g., 'salary > 120000')"
            ));
        };
        
        let filtered_nodes = graph.inner.find_nodes(node_filter)
            .map_err(graph_error_to_py_err)?;
        
        // O(k) Calculate induced edges using optimized core subgraph method
        let node_set: HashSet<NodeId> = filtered_nodes.iter().copied().collect();
        
        // Get columnar topology vectors (edge_ids, sources, targets) - O(1) if cached
        let (edge_ids, sources, targets) = graph.inner.get_columnar_topology();
        let mut induced_edges = Vec::new();
        
        // Iterate through parallel vectors - O(k) where k = active edges
        for i in 0..edge_ids.len() {
            let edge_id = edge_ids[i];
            let source = sources[i];
            let target = targets[i];
            
            // O(1) HashSet lookups instead of O(n) Vec::contains
            if node_set.contains(&source) && node_set.contains(&target) {
                induced_edges.push(edge_id);
            }
        }
        
        Ok(PySubgraph::new(
            filtered_nodes,
            induced_edges,
            "filtered_nodes".to_string(),
            Some(self.graph.clone()),
        ))
    }
    
    /// Filter edges by criteria
    pub fn filter_edges(&self, py: Python, filter: &PyAny) -> PyResult<PySubgraph> {
        let mut graph = self.graph.borrow_mut(py);
        
        // Similar pattern to filter_nodes but for edges
        let edge_filter = if let Ok(filter_obj) = filter.extract::<PyEdgeFilter>() {
            filter_obj.inner.clone()
        } else if let Ok(query_str) = filter.extract::<String>() {
            let query_parser = py.import("groggy.query_parser")?;
            let parse_func = query_parser.getattr("parse_edge_query")?;
            let parsed_filter: PyEdgeFilter = parse_func.call1((query_str,))?.extract()?;
            parsed_filter.inner.clone()
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "filter must be an EdgeFilter object or a string query"
            ));
        };
        
        let filtered_edges = graph.inner.find_edges(edge_filter)
            .map_err(graph_error_to_py_err)?;
        
        // Calculate nodes that are connected by the filtered edges
        let mut nodes = HashSet::new();
        for &edge_id in &filtered_edges {
            if let Ok((source, target)) = graph.inner.edge_endpoints(edge_id) {
                nodes.insert(source);
                nodes.insert(target);
            }
        }
        
        let node_vec: Vec<NodeId> = nodes.into_iter().collect();
        
        Ok(PySubgraph::new(
            node_vec,
            filtered_edges,
            "filtered_edges".to_string(),
            Some(self.graph.clone()),
        ))
    }
    
    /// Filter nodes within a subgraph
    fn filter_subgraph_nodes(&self, py: Python, subgraph: &PySubgraph, filter: &PyAny) -> PyResult<PySubgraph> {
        let mut graph = self.graph.borrow_mut(py);
        
        // Parse filter same way as filter_nodes
        let node_filter = if let Ok(filter_obj) = filter.extract::<PyNodeFilter>() {
            filter_obj.inner.clone()
        } else if let Ok(query_str) = filter.extract::<String>() {
            let query_parser = py.import("groggy.query_parser")?;
            let parse_func = query_parser.getattr("parse_node_query")?;
            let parsed_filter: PyNodeFilter = parse_func.call1((query_str,))?.extract()?;
            parsed_filter.inner.clone()
        } else {
            return Err(PyErr::new::<PyTypeError, _>(
                "filter must be a NodeFilter object or a string query"
            ));
        };
        
        // Apply filter only to nodes in the subgraph
        let subgraph_node_set: HashSet<NodeId> = subgraph.get_nodes().iter().copied().collect();
        let all_filtered_nodes = graph.inner.find_nodes(node_filter)
            .map_err(graph_error_to_py_err)?;
        
        // Intersect with subgraph nodes
        let filtered_nodes: Vec<NodeId> = all_filtered_nodes.into_iter()
            .filter(|node_id| subgraph_node_set.contains(node_id))
            .collect();
        
        // Calculate induced edges within the filtered nodes
        let filtered_node_set: HashSet<NodeId> = filtered_nodes.iter().copied().collect();
        let filtered_edges: Vec<EdgeId> = subgraph.get_edges().iter()
            .filter(|&&edge_id| {
                if let Ok((source, target)) = graph.inner.edge_endpoints(edge_id) {
                    filtered_node_set.contains(&source) && filtered_node_set.contains(&target)
                } else {
                    false
                }
            })
            .copied()
            .collect();
        
        Ok(PySubgraph::new(
            filtered_nodes,
            filtered_edges,
            "filtered_subgraph".to_string(),
            Some(self.graph.clone()),
        ))
    }
    
    /// Aggregate attribute values
    #[pyo3(signature = (attribute, operation, target = None, node_ids = None))]
    fn aggregate(&self, py: Python, attribute: AttrName, operation: String, 
                target: Option<String>, node_ids: Option<Vec<NodeId>>) -> PyResult<PyObject> {
        let graph = self.graph.borrow(py);
        let target = target.unwrap_or_else(|| "nodes".to_string());
        
        match target.as_str() {
            "nodes" => {
                if let Some(node_list) = node_ids {
                    // Custom node list aggregation
                    self.aggregate_custom_nodes(py, &graph, node_list, attribute)
                } else {
                    // All nodes aggregation
                    let result = graph.inner.aggregate_node_attribute(&attribute, &operation)
                        .map_err(graph_error_to_py_err)?;
                    
                    let dict = PyDict::new(py);
                    dict.set_item("value", result.value)?;
                    dict.set_item("operation", &operation)?;
                    dict.set_item("attribute", &attribute)?;
                    dict.set_item("target", "nodes")?;
                    Ok(dict.to_object(py))
                }
            },
            "edges" => {
                // Edge aggregation
                let result = graph.inner.aggregate_edge_attribute(&attribute, &operation)
                    .map_err(graph_error_to_py_err)?;
                
                let dict = PyDict::new(py);
                dict.set_item("value", result.value)?;
                dict.set_item("operation", &operation)?;
                dict.set_item("attribute", &attribute)?;
                dict.set_item("target", "edges")?;
                Ok(dict.to_object(py))
            },
            _ => {
                Err(PyValueError::new_err(format!("Invalid target '{}'. Use 'nodes' or 'edges'", target)))
            }
        }
    }
    
    /// Execute a graph query with filters
    #[pyo3(signature = (query, **kwargs))]
    fn execute(&self, py: Python, query: &str, kwargs: Option<&pyo3::types::PyDict>) -> PyResult<PyObject> {
        // Parse and execute complex graph queries
        let graph = self.graph.borrow(py);
        
        // For now, support basic query patterns
        if query.starts_with("nodes where ") {
            let filter_str = &query[12..]; // Remove "nodes where "
            let filter_py_str = filter_str.to_string().into_py(py);
            self.filter_nodes(py, filter_py_str.as_ref(py))
                .map(|subgraph| Py::new(py, subgraph).unwrap().to_object(py))
        } else if query.starts_with("edges where ") {
            let filter_str = &query[12..]; // Remove "edges where "
            let filter_py_str = filter_str.to_string().into_py(py);
            self.filter_edges(py, filter_py_str.as_ref(py))
                .map(|subgraph| Py::new(py, subgraph).unwrap().to_object(py))
        } else {
            Err(PyValueError::new_err(format!("Unsupported query pattern: {}", query)))
        }
    }
    
    /// Get query statistics
    fn get_stats(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        let node_count = graph.get_node_count();
        let edge_count = graph.get_edge_count();
        
        Ok(format!("Query module ready: {} nodes, {} edges available", node_count, edge_count))
    }
}

impl PyGraphQuery {
    /// Helper method for custom node list aggregation
    fn aggregate_custom_nodes(&self, py: Python, graph: &crate::ffi::api::graph::PyGraph, 
                             node_ids: Vec<NodeId>, attribute: AttrName) -> PyResult<PyObject> {
        // Use bulk attribute retrieval for much better performance
        let bulk_attributes = graph.inner._get_node_attributes_for_nodes(&node_ids, &attribute)
            .map_err(graph_error_to_py_err)?;
        let mut values = Vec::new();
        
        // Extract values from bulk result
        for attr_value in bulk_attributes {
            if let Some(value) = attr_value {
                values.push(value);
            }
        }
        
        // Compute statistics
        let dict = PyDict::new(py);
        dict.set_item("count", values.len())?;
        
        if !values.is_empty() {
            // Convert first value to determine type for aggregation
            if let Some(first_val) = values.first() {
                match first_val {
                    groggy::AttrValue::Int(_) | groggy::AttrValue::SmallInt(_) => {
                        let int_values: Vec<i64> = values.iter().filter_map(|v| match v {
                            groggy::AttrValue::Int(i) => Some(*i),
                            groggy::AttrValue::SmallInt(i) => Some(*i as i64),
                            _ => None,
                        }).collect();
                        
                        if !int_values.is_empty() {
                            dict.set_item("sum", int_values.iter().sum::<i64>())?;
                            dict.set_item("min", *int_values.iter().min().unwrap())?;
                            dict.set_item("max", *int_values.iter().max().unwrap())?;
                            dict.set_item("mean", int_values.iter().sum::<i64>() as f64 / int_values.len() as f64)?;
                        }
                    },
                    groggy::AttrValue::Float(_) => {
                        let float_values: Vec<f64> = values.iter().filter_map(|v| match v {
                            groggy::AttrValue::Float(f) => Some(*f as f64),
                            _ => None,
                        }).collect();
                        
                        if !float_values.is_empty() {
                            dict.set_item("sum", float_values.iter().sum::<f64>())?;
                            dict.set_item("min", float_values.iter().fold(f64::INFINITY, |a, &b| a.min(b)))?;
                            dict.set_item("max", float_values.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b)))?;
                            dict.set_item("mean", float_values.iter().sum::<f64>() / float_values.len() as f64)?;
                        }
                    },
                    _ => {
                        // For non-numeric types, just provide count
                    }
                }
            }
        }
        
        Ok(dict.to_object(py))
    }
}


--- FILE: ffi/api/graph_analytics.rs ---
//! Graph Analytics Module
//! 
//! Python bindings for graph analytics and algorithms.

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::exceptions::{PyValueError, PyTypeError, PyRuntimeError};
use groggy::{NodeId, EdgeId, AttrName};
use groggy::core::traversal::{TraversalOptions, PathFindingOptions};
use crate::ffi::types::PyAttrValue;
use crate::ffi::utils::{graph_error_to_py_err, attr_value_to_python_value};
use crate::ffi::core::subgraph::PySubgraph;
use std::collections::HashSet;

/// Analytics operations for graphs
#[pyclass(name = "GraphAnalytics")]
pub struct PyGraphAnalytics {
    /// Reference to the parent graph
    pub graph: Py<crate::ffi::api::graph::PyGraph>,
}

#[pymethods]
impl PyGraphAnalytics {
    /// Calculate connected components with optional in-place attribute setting
    #[pyo3(signature = (inplace = false, attr_name = None))]
    pub fn connected_components(&self, py: Python, inplace: Option<bool>, attr_name: Option<String>) -> PyResult<Vec<PySubgraph>> {
        let inplace = inplace.unwrap_or(false);
        let mut graph = self.graph.borrow_mut(py);
        
        // Delegate to core algorithm - THIN WRAPPER
        let options = TraversalOptions::default();
        let result = graph.inner.connected_components(options)
            .map_err(graph_error_to_py_err)?;
        
        let mut subgraphs = Vec::new();
        
        // Handle bulk attribute setting if requested
        if inplace {
            if let Some(ref attr_name) = attr_name {
                let mut attrs_values = std::collections::HashMap::new();
                let node_value_pairs: Vec<(NodeId, groggy::AttrValue)> = result.components.iter().enumerate()
                    .flat_map(|(i, component)| {
                        component.nodes.iter().map(move |&node_id| (node_id, groggy::AttrValue::Int(i as i64)))
                    })
                    .collect();
                attrs_values.insert(attr_name.clone(), node_value_pairs);
                
                graph.inner.set_node_attrs(attrs_values)
                    .map_err(graph_error_to_py_err)?;
            }
        }
        
        // Convert core results to FFI wrappers - ZERO-COPY: just use pre-computed edges!
        for (i, component) in result.components.into_iter().enumerate() {
            // 🚀 PERFORMANCE: Use edges already computed by Rust core - no recomputation needed!
            let subgraph = PySubgraph::new(
                component.nodes,
                component.edges, // Use pre-computed induced edges from Rust core
                format!("connected_component_{}", i),
                Some(self.graph.clone()),
            );
            subgraphs.push(subgraph);
        }
        
        Ok(subgraphs)
    }
    
    /// Perform breadth-first search traversal
    #[pyo3(signature = (start_node, max_depth = None, inplace = false, attr_name = None))]
    pub fn bfs(&self, py: Python, start_node: NodeId, max_depth: Option<usize>, 
           inplace: Option<bool>, attr_name: Option<String>) -> PyResult<PySubgraph> {
        let inplace = inplace.unwrap_or(false);
        let mut graph = self.graph.borrow_mut(py);
        
        // Create traversal options
        let mut options = TraversalOptions::default();
        if let Some(depth) = max_depth {
            options.max_depth = Some(depth);
        }
        
        // Perform BFS traversal
        let result = graph.inner.bfs(start_node, options)
            .map_err(graph_error_to_py_err)?;
        
        // If inplace=True, set distance/order attributes on nodes
        if inplace {
            let attr_name = attr_name.unwrap_or_else(|| "bfs_distance".to_string());
            
            // Use bulk attribute setting for performance
            let mut attrs_values = std::collections::HashMap::new();
            let node_value_pairs: Vec<(NodeId, groggy::AttrValue)> = result.nodes.iter().enumerate()
                .map(|(order, &node_id)| (node_id, groggy::AttrValue::Int(order as i64)))
                .collect();
            attrs_values.insert(attr_name, node_value_pairs);
            
            graph.inner.set_node_attrs(attrs_values)
                .map_err(graph_error_to_py_err)?;
        }
        
        Ok(PySubgraph::new(
            result.nodes,
            result.edges,
            "bfs_traversal".to_string(),
            Some(self.graph.clone()),
        ))
    }
    
    /// Perform depth-first search traversal
    #[pyo3(signature = (start_node, max_depth = None, inplace = false, attr_name = None))]
    pub fn dfs(&self, py: Python, start_node: NodeId, max_depth: Option<usize>,
           inplace: Option<bool>, attr_name: Option<String>) -> PyResult<PySubgraph> {
        let inplace = inplace.unwrap_or(false);
        let mut graph = self.graph.borrow_mut(py);
        
        // Create traversal options
        let mut options = TraversalOptions::default();
        if let Some(depth) = max_depth {
            options.max_depth = Some(depth);
        }
        
        // Perform DFS traversal
        let result = graph.inner.dfs(start_node, options)
            .map_err(graph_error_to_py_err)?;
        
        // If inplace=True, set distance/order attributes on nodes
        if inplace {
            let attr_name = attr_name.unwrap_or_else(|| "dfs_order".to_string());
            
            // Use bulk attribute setting for performance
            let mut attrs_values = std::collections::HashMap::new();
            let node_value_pairs: Vec<(NodeId, groggy::AttrValue)> = result.nodes.iter().enumerate()
                .map(|(order, &node_id)| (node_id, groggy::AttrValue::Int(order as i64)))
                .collect();
            attrs_values.insert(attr_name, node_value_pairs);
            
            graph.inner.set_node_attrs(attrs_values)
                .map_err(graph_error_to_py_err)?;
        }
        
        Ok(PySubgraph::new(
            result.nodes,
            result.edges,
            "dfs_traversal".to_string(),
            Some(self.graph.clone()),
        ))
    }
    
    /// Find shortest path between two nodes
    #[pyo3(signature = (source, target, weight_attribute = None, inplace = false, attr_name = None))]
    pub fn shortest_path(&self, py: Python, source: NodeId, target: NodeId, 
                    weight_attribute: Option<AttrName>, inplace: Option<bool>, 
                    attr_name: Option<String>) -> PyResult<Option<PySubgraph>> {
        let inplace = inplace.unwrap_or(false);
        let mut graph = self.graph.borrow_mut(py);
        
        let options = PathFindingOptions {
            weight_attribute,
            max_path_length: None,
            heuristic: None,
        };
        
        let result = graph.inner.shortest_path(source, target, options)
            .map_err(graph_error_to_py_err)?;
            
        match result {
            Some(path) => {
                if inplace {
                    if let Some(attr_name) = attr_name {
                        // Use bulk attribute setting for performance
                        let mut attrs_values = std::collections::HashMap::new();
                        let node_value_pairs: Vec<(NodeId, groggy::AttrValue)> = path.nodes.iter().enumerate()
                            .map(|(distance, &node_id)| (node_id, groggy::AttrValue::Int(distance as i64)))
                            .collect();
                        attrs_values.insert(attr_name, node_value_pairs);
                        
                        graph.inner.set_node_attrs(attrs_values)
                            .map_err(graph_error_to_py_err)?;
                    }
                }
                
                Ok(Some(PySubgraph::new(
                    path.nodes,
                    path.edges,
                    "shortest_path".to_string(),
                    Some(self.graph.clone()),
                )))
            },
            None => Ok(None),
        }
    }
    
    /// Get node degree
    fn degree(&self, py: Python, node: NodeId) -> PyResult<usize> {
        let graph = self.graph.borrow(py);
        graph.inner.degree(node)
            .map_err(graph_error_to_py_err)
    }
    
    /// Get memory statistics
    fn memory_statistics(&self, py: Python) -> PyResult<PyObject> {
        let graph = self.graph.borrow(py);
        let stats = graph.inner.memory_statistics();
        
        // Convert MemoryStatistics to Python dict
        let dict = PyDict::new(py);
        dict.set_item("pool_memory_bytes", stats.pool_memory_bytes)?;
        dict.set_item("space_memory_bytes", stats.space_memory_bytes)?;
        dict.set_item("history_memory_bytes", stats.history_memory_bytes)?;
        dict.set_item("change_tracker_memory_bytes", stats.change_tracker_memory_bytes)?;
        dict.set_item("total_memory_bytes", stats.total_memory_bytes)?;
        dict.set_item("total_memory_mb", stats.total_memory_mb)?;
        
        // Add memory efficiency stats
        let efficiency_dict = PyDict::new(py);
        efficiency_dict.set_item("bytes_per_node", stats.memory_efficiency.bytes_per_node)?;
        efficiency_dict.set_item("bytes_per_edge", stats.memory_efficiency.bytes_per_edge)?;
        efficiency_dict.set_item("bytes_per_entity", stats.memory_efficiency.bytes_per_entity)?;
        efficiency_dict.set_item("overhead_ratio", stats.memory_efficiency.overhead_ratio)?;
        efficiency_dict.set_item("cache_efficiency", stats.memory_efficiency.cache_efficiency)?;
        dict.set_item("memory_efficiency", efficiency_dict)?;
        
        Ok(dict.to_object(py))
    }
    
    /// Get analytics summary
    fn get_summary(&self, py: Python) -> PyResult<String> {
        let graph = self.graph.borrow(py);
        let node_count = graph.get_node_count();
        let edge_count = graph.get_edge_count();
        
        Ok(format!("Graph Analytics: {} nodes, {} edges", node_count, edge_count))
    }
}

use pyo3::prelude::*;

// Placeholder - will extract analytics operations from lib_old.rs


