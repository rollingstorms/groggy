CODE STRUCTURE ANALYSIS
Directory: ../groggy/src
Generated: rust_outline.txt
============================================================

============================================================
FILE: types.rs
============================================================

ğŸ”¢ ENUM: AttrValue (line 43)
   ğŸ·ï¸  #derive(Debug, Clone, PartialEq)

ğŸ”§ IMPL: Hash for AttrValue (line 61)

ğŸ”§ IMPL: AttrValue (line 66)
   â””â”€â”€ âš™ï¸  type_name() (line 68)
       ğŸ’¬ Get runtime type information as string
   â””â”€â”€ âš™ï¸  as_float() (line 73)
       ğŸ’¬ Try to convert to specific type with error handling
   â””â”€â”€ âš™ï¸  as_int() (line 77)
   â””â”€â”€ âš™ï¸  as_text() (line 81)
   â””â”€â”€ âš™ï¸  as_float_vec() (line 85)
   â””â”€â”€ âš™ï¸  as_bool() (line 89)

============================================================
FILE: util.rs
============================================================

âš™ï¸  FUNCTION: content_hash() (line 51)
   ğŸ“ Generate a 256-bit content hash for deduplication and verification ALGORITHM: 1. Use DefaultHasher to generate u64 hash of input data 2. Expand to 256-bit by repeating the 64-bit hash 3. This provides good distribution while being fast PERFORMANCE: O(size of data), very fast hashing COLLISION RESISTANCE: Good for practical purposes, not cryptographic

âš™ï¸  FUNCTION: attr_value_hash() (line 74)
   ğŸ“ Fast hash function optimized specifically for attribute values OPTIMIZATION: This can be faster than generic hashing because we know the structure of AttrValue and can optimize accordingly

âš™ï¸  FUNCTION: merge_sorted_indices() (line 116)
   ğŸ“ Merge two sorted vectors while maintaining order and removing duplicates ALGORITHM: 1. Two-pointer technique to merge in O(n + m) time 2. Skip duplicates during merge to ensure uniqueness 3. Pre-allocate result vector for efficiency PERFORMANCE: O(n + m) time, O(n + m) space USE CASES: Merging index lists, combining sorted query results

âš™ï¸  FUNCTION: binary_search_insert_point() (line 149)
   ğŸ“ Find insertion point in sorted vector using binary search RETURNS: Index where value should be inserted to maintain sorted order If value already exists, returns the index of the existing element

âš™ï¸  FUNCTION: validate_attr_compatibility() (line 162)
   ğŸ“ Check if two attribute values are type-compatible USAGE: Before updating an attribute, check if the new value is compatible with the existing type

âš™ï¸  FUNCTION: timestamp_now() (line 173)
   ğŸ“ Generate a Unix timestamp for the current time PRECISION: Seconds since Unix epoch FALLBACK: Returns 0 if system time is unavailable

âš™ï¸  FUNCTION: test_merge_sorted_indices() (line 187)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_merge_with_duplicates() (line 195)
   ğŸ·ï¸  #test

============================================================
FILE: config.rs
============================================================

ğŸ—ï¸  STRUCT: GraphConfig (line 47)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: ConfigError (line 395)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: GraphConfig (line 182)
   â””â”€â”€ âš™ï¸  new() (line 184)
       ğŸ’¬ Create a new configuration with reasonable defaults
   â””â”€â”€ âš™ï¸  memory_optimized() (line 226)
       ğŸ’¬ Create a configuration optimized for low memory usage USE CASE: Embedded systems, resource-constrained environments OPTIMIZATIONS: - Index-based deltas (minimal memory overhead) - Aggressive garbage collection - Minimal caching - High compression - Frequent snapshots to keep delta chains short
   â””â”€â”€ âš™ï¸  performance_optimized() (line 243)
       ğŸ’¬ Create a configuration optimized for maximum performance USE CASE: High-performance computing, real-time applications OPTIMIZATIONS: - Index-based deltas (fastest commits) - Large memory buffers - Extensive caching - No compression - Parallel processing - Minimal garbage collection
   â””â”€â”€ âš™ï¸  development_optimized() (line 259)
       ğŸ’¬ Create a configuration optimized for development/debugging USE CASE: Development, testing, debugging FEATURES: - Extensive validation - Debug logging - Crash recovery - Metrics collection - Conservative resource usage
   â””â”€â”€ âš™ï¸  production_optimized() (line 280)
       ğŸ’¬ Create a configuration for production deployment USE CASE: Production systems, stable deployments FEATURES: - Index-based deltas (proven and stable) - Balanced performance and reliability - Automatic backup and recovery - Moderate resource usage - Error handling without debug overhead
   â””â”€â”€ âš™ï¸  validate() (line 293)
       ğŸ’¬ Validate the configuration and return errors if invalid
   â””â”€â”€ âš™ï¸  effective_worker_threads() (line 306)
       ğŸ’¬ Get the effective number of worker threads (resolves 0 to actual CPU count)
   â””â”€â”€ âš™ï¸  memory_cleanup_threshold() (line 316)
       ğŸ’¬ Calculate the memory threshold for triggering cleanup
   â””â”€â”€ âš™ï¸  with_memory_limit() (line 327)
       ğŸ’¬ Create a new configuration with updated memory limit
   â””â”€â”€ âš™ï¸  with_cache_settings() (line 332)
       ğŸ’¬ Create a new configuration with updated cache settings
   â””â”€â”€ âš™ï¸  with_worker_threads() (line 337)
       ğŸ’¬ Create a new configuration with updated worker thread count
   â””â”€â”€ âš™ï¸  with_storage_strategy() (line 342)
       ğŸ’¬ Create a new configuration with specific temporal storage strategy
   â””â”€â”€ âš™ï¸  from_environment() (line 359)
       ğŸ’¬ Load configuration overrides from environment variables SUPPORTED VARIABLES: - GROGGY_MAX_MEMORY: Maximum memory usage in bytes - GROGGY_WORKER_THREADS: Number of worker threads - GROGGY_ENABLE_DEBUG: Enable debug logging (true/false) - GROGGY_COMPRESSION_LEVEL: Compression level (1-9)
   â””â”€â”€ âš™ï¸  to_environment() (line 381)
       ğŸ’¬ Save current configuration to environment variables

ğŸ”§ IMPL: Default for GraphConfig (line 387)
   â””â”€â”€ âš™ï¸  default() (line 388)

âš™ï¸  FUNCTION: fmt() (line 413)

============================================================
FILE: lib.rs
============================================================

ğŸ—ï¸  STRUCT: LibraryInfo (line 173)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: LibraryInfo (line 179)
   â””â”€â”€ âš™ï¸  banner() (line 181)
       ğŸ’¬ Get a formatted string representation

âš™ï¸  FUNCTION: info() (line 163)
   ğŸ“ Get library information

âš™ï¸  FUNCTION: test_library_info() (line 191)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_basic_integration() (line 199)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_error_handling() (line 251)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_configuration() (line 266)
   ğŸ·ï¸  #test

============================================================
FILE: errors.rs
============================================================

ğŸ”¢ ENUM: GraphError (line 35)
   ğŸ·ï¸  #derive(Debug, Clone, PartialEq)

ğŸ”¢ ENUM: ErrorCategory (line 546)
   ğŸ·ï¸  #derive(Debug, Clone, PartialEq, Eq)

ğŸ”¢ ENUM: EntityType (line 561)
   ğŸ·ï¸  #derive(Debug, Clone, PartialEq, Eq)

ğŸ”§ IMPL: GraphError (line 302)
   â””â”€â”€ âš™ï¸  node_not_found() (line 309)
       ğŸ’¬ Create a NodeNotFound error with helpful context
   â””â”€â”€ âš™ï¸  edge_not_found() (line 318)
       ğŸ’¬ Create an EdgeNotFound error with helpful context
   â””â”€â”€ âš™ï¸  state_not_found() (line 327)
       ğŸ’¬ Create a StateNotFound error with available alternatives
   â””â”€â”€ âš™ï¸  branch_not_found() (line 336)
       ğŸ’¬ Create a BranchNotFound error with available alternatives
   â””â”€â”€ âš™ï¸  uncommitted_changes() (line 345)
       ğŸ’¬ Create an UncommittedChanges error with helpful context
   â””â”€â”€ âš™ï¸  attribute_not_found() (line 354)
       ğŸ’¬ Create an AttributeNotFound error with available alternatives
   â””â”€â”€ âš™ï¸  internal() (line 369)
       ğŸ’¬ Create an InternalError for unexpected conditions
   â””â”€â”€ âš™ï¸  internal_with_context() (line 378)
       ğŸ’¬ Create an InternalError with additional context
   â””â”€â”€ âš™ï¸  is_user_error() (line 396)
       ğŸ’¬ Check if this error indicates a user mistake (vs system problem)
   â””â”€â”€ âš™ï¸  is_recoverable() (line 428)
       ğŸ’¬ Check if this error might be recoverable
   â””â”€â”€ âš™ï¸  category() (line 449)
       ğŸ’¬ Get the error category for grouping similar errors
   â””â”€â”€ âš™ï¸  short_description() (line 493)
       ğŸ’¬ Get a short description suitable for logging
   â””â”€â”€ âš™ï¸  suggestions() (line 509)
       ğŸ’¬ Get actionable suggestions for resolving this error

âš™ï¸  FUNCTION: fmt() (line 570)

âš™ï¸  FUNCTION: source() (line 655)

âš™ï¸  FUNCTION: io_error_to_graph_error() (line 666)
   ğŸ“ Convert a standard I/O error to a GraphError

============================================================
FILE: core/strategies.rs
============================================================

ğŸ—ï¸  STRUCT: IndexDeltaStrategy (line 215)
   ğŸ·ï¸  #derive(Debug)

ğŸ”¢ ENUM: StorageStrategyType (line 144)
   ğŸ·ï¸  #derive(Debug, Clone, Copy, PartialEq, Eq)

ğŸ­ TRAIT: TemporalStorageStrategy (line 38)
   ğŸ“ Core trait for temporal storage strategies DESIGN: Each strategy implements a different approach to storing and reconstructing temporal graph states. The trait provides a common interface that ChangeTracker and History systems can work with regardless of the underlying storage strategy.

ğŸ”§ IMPL: StorageStrategyType (line 160)
   â””â”€â”€ âš™ï¸  name() (line 162)
       ğŸ’¬ Get a human-readable name for this strategy
   â””â”€â”€ âš™ï¸  description() (line 169)
       ğŸ’¬ Get a description of this strategy

ğŸ”§ IMPL: Default for StorageStrategyType (line 177)
   â””â”€â”€ âš™ï¸  default() (line 178)

ğŸ”§ IMPL: IndexDeltaStrategy (line 245)
   â””â”€â”€ âš™ï¸  new() (line 247)
       ğŸ’¬ Create a new empty index delta strategy
   â””â”€â”€ âš™ï¸  record_node_attr_index_change() (line 262)
       ğŸ’¬ Record node attribute change with indices (strategy-specific API) This is the index-specific version that stores column indices
   â””â”€â”€ âš™ï¸  record_edge_attr_index_change() (line 283)
       ğŸ’¬ Record edge attribute change with indices (strategy-specific API)
   â””â”€â”€ âš™ï¸  update_change_metadata() (line 302)
       ğŸ’¬ Helper method to update change metadata
   â””â”€â”€ âš™ï¸  current_timestamp() (line 310)
       ğŸ’¬ Get current timestamp (placeholder - would use actual time in real implementation)

ğŸ”§ IMPL: TemporalStorageStrategy for IndexDeltaStrategy (line 315)
   â””â”€â”€ âš™ï¸  record_node_addition() (line 316)
   â””â”€â”€ âš™ï¸  record_node_removal() (line 321)
   â””â”€â”€ âš™ï¸  record_edge_addition() (line 328)
   â””â”€â”€ âš™ï¸  record_edge_removal() (line 333)
   â””â”€â”€ âš™ï¸  record_node_attr_change() (line 340)
   â””â”€â”€ âš™ï¸  record_edge_attr_change() (line 351)
   â””â”€â”€ âš™ï¸  create_delta() (line 362)
   â””â”€â”€ âš™ï¸  has_changes() (line 393)
   â””â”€â”€ âš™ï¸  change_count() (line 402)
   â””â”€â”€ âš™ï¸  clear_changes() (line 406)
   â””â”€â”€ âš™ï¸  strategy_name() (line 417)
   â””â”€â”€ âš™ï¸  storage_characteristics() (line 421)
   â””â”€â”€ âš™ï¸  as_any() (line 433)

ğŸ”§ IMPL: Default for IndexDeltaStrategy (line 438)
   â””â”€â”€ âš™ï¸  default() (line 439)

âš™ï¸  FUNCTION: record_node_addition() (line 45)
   ğŸ“ Record that a node was added to the graph

âš™ï¸  FUNCTION: record_node_removal() (line 48)
   ğŸ“ Record that a node was removed from the graph

âš™ï¸  FUNCTION: record_edge_addition() (line 51)
   ğŸ“ Record that an edge was added to the graph

âš™ï¸  FUNCTION: record_edge_removal() (line 54)
   ğŸ“ Record that an edge was removed from the graph

âš™ï¸  FUNCTION: record_node_attr_change() (line 58)
   ğŸ“ Record that a node attribute changed (index-based) All strategies now work with indices for consistency and efficiency

âš™ï¸  FUNCTION: record_edge_attr_change() (line 67)
   ğŸ“ Record that an edge attribute changed (index-based)

âš™ï¸  FUNCTION: create_delta() (line 82)
   ğŸ“ Create a delta object representing all current changes This is used when committing to history

âš™ï¸  FUNCTION: has_changes() (line 90)
   ğŸ“ Check if there are any uncommitted changes

âš™ï¸  FUNCTION: change_count() (line 93)
   ğŸ“ Get the total number of changes recorded

âš™ï¸  FUNCTION: clear_changes() (line 96)
   ğŸ“ Clear all recorded changes (after successful commit)

âš™ï¸  FUNCTION: strategy_name() (line 104)
   ğŸ“ Get the name of this strategy

âš™ï¸  FUNCTION: create_strategy() (line 187)
   ğŸ“ Factory function to create a strategy instance DESIGN: This factory pattern allows the system to create strategy instances based on configuration without tight coupling to specific implementations.

============================================================
FILE: core/query.rs
============================================================

ğŸ—ï¸  STRUCT: QueryEngine (line 49)
   ğŸ·ï¸  #derive(Debug)

ğŸ—ï¸  STRUCT: QueryConfig (line 308)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: DegreeFilter (line 431)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: NodePattern (line 439)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: NeighborPattern (line 452)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: StructureMatch (line 510)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: GraphQuery (line 523)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: AggregateOperation (line 569)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: OrderBy (line 625)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: GroupBy (line 638)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: AggregationResult (line 675)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: AggregationMetadata (line 692)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: DegreeDistribution (line 710)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: CachedQueryResult (line 724)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: AttributeStatistics (line 733)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: QueryPerformance (line 744)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: CacheStatistics (line 753)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: QueryPlan (line 770)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: AttributeFilter (line 333)
   ğŸ·ï¸  #derive(Debug, Clone, PartialEq)

ğŸ”¢ ENUM: SimilarityType (line 385)
   ğŸ·ï¸  #derive(Debug, Clone, PartialEq)

ğŸ”¢ ENUM: NodeFilter (line 394)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: EdgeFilter (line 414)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: PatternLogic (line 468)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: StructuralPattern (line 477)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: QueryOperation (line 539)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: CountTarget (line 561)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: AggregateTarget (line 577)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: AggregationType (line 584)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: AnalyticsOperation (line 597)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: CentralityType (line 608)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: CommunityAlgorithm (line 617)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: SortDirection (line 631)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: QueryResult (line 650)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: AggregationValue (line 683)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: AnalyticsResult (line 700)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: EntityType (line 763)
   ğŸ·ï¸  #derive(Debug, Clone, PartialEq)

ğŸ”¢ ENUM: PlanOperation (line 777)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: QueryEngine (line 78)
   â””â”€â”€ âš™ï¸  new() (line 80)
       ğŸ’¬ Create a new query engine with default configuration
   â””â”€â”€ âš™ï¸  with_config() (line 86)
       ğŸ’¬ Create a query engine with custom configuration
   â””â”€â”€ âš™ï¸  find_nodes_by_attribute() (line 98)
       ğŸ’¬ Find all nodes matching a simple attribute filter PERFORMANCE: O(n) where n = number of nodes, but can be optimized with indices
   â””â”€â”€ âš™ï¸  find_edges_by_attribute() (line 114)
       ğŸ’¬ Find all edges matching a simple attribute filter
   â””â”€â”€ âš™ï¸  find_nodes_by_attributes() (line 124)
       ğŸ’¬ Find nodes matching multiple attribute criteria (AND logic)
   â””â”€â”€ âš™ï¸  find_edges_by_attributes() (line 136)
       ğŸ’¬ Find edges matching multiple attribute criteria (AND logic)
   â””â”€â”€ âš™ï¸  execute_query() (line 150)
       ğŸ’¬ Execute a complex query with multiple steps and logic
   â””â”€â”€ âš™ï¸  find_nodes_by_pattern() (line 166)
       ğŸ’¬ Find nodes matching a complex pattern For example: "nodes with attribute X > 5 AND connected to nodes with attribute Y = 'foo'"
   â””â”€â”€ âš™ï¸  find_structural_patterns() (line 179)
       ğŸ’¬ Find structural patterns in the graph For example: "triangles where all nodes have attribute 'type' = 'person'"
   â””â”€â”€ âš™ï¸  aggregate_node_attribute() (line 193)
       ğŸ’¬ Compute aggregate statistics for a node attribute
   â””â”€â”€ âš™ï¸  aggregate_edge_attribute() (line 207)
       ğŸ’¬ Compute aggregate statistics for an edge attribute
   â””â”€â”€ âš™ï¸  group_nodes_by_attribute() (line 217)
       ğŸ’¬ Group nodes by attribute value and compute aggregates for each group
   â””â”€â”€ âš™ï¸  update_statistics() (line 238)
       ğŸ’¬ Update statistics about attribute distributions This is used for query optimization
   â””â”€â”€ âš™ï¸  clear_cache() (line 246)
       ğŸ’¬ Clear the query cache (useful after large data changes)
   â””â”€â”€ âš™ï¸  cache_statistics() (line 251)
       ğŸ’¬ Get cache statistics
   â””â”€â”€ âš™ï¸  optimize_query_plan() (line 256)
       ğŸ’¬ Optimize a query plan before execution
   â””â”€â”€ âš™ï¸  count_nodes_matching() (line 270)
       ğŸ’¬ Count entities matching a filter (more efficient than finding all matches)
   â””â”€â”€ âš™ï¸  any_nodes_match() (line 279)
       ğŸ’¬ Check if any entities match a filter (even more efficient than counting)
   â””â”€â”€ âš™ï¸  get_unique_attribute_values() (line 288)
       ğŸ’¬ Get unique values for an attribute across all entities

ğŸ”§ IMPL: Default for QueryConfig (line 325)
   â””â”€â”€ âš™ï¸  default() (line 326)

ğŸ”§ IMPL: AttributeFilter (line 371)
   â””â”€â”€ âš™ï¸  matches() (line 373)
       ğŸ’¬ Check if a value matches this filter
   â””â”€â”€ âš™ï¸  estimated_selectivity() (line 378)
       ğŸ’¬ Estimate the selectivity of this filter (0.0 = very selective, 1.0 = not selective)

ğŸ”§ IMPL: Default for QueryEngine (line 784)
   â””â”€â”€ âš™ï¸  default() (line 785)

============================================================
FILE: core/history.rs
============================================================

ğŸ—ï¸  STRUCT: HistoryForest (line 49)
   ğŸ·ï¸  #derive(Debug)

ğŸ—ï¸  STRUCT: Commit (line 319)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: Delta (line 371)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: CommitDiff (line 415)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: AttributeChange (line 427)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: HistoryStatistics (line 443)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: ViewSummary (line 853)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: EntityType (line 436)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: HistoryForest (line 94)
   â””â”€â”€ âš™ï¸  new() (line 96)
       ğŸ’¬ Create a new empty history system
   â””â”€â”€ âš™ï¸  create_commit() (line 116)
       ğŸ’¬ Create a new commit from a set of changes ALGORITHM: 1. Create Delta from the changes 2. Compute content hash of delta for deduplication 3. Check if we already have this exact delta (hash collision -> reuse) 4. Create Commit with metadata (parent, message, author, timestamp) 5. Update parent-child relationships 6. Store everything and return new state ID
   â””â”€â”€ âš™ï¸  create_merge_commit() (line 136)
       ğŸ’¬ Create a merge commit (commit with multiple parents)
   â””â”€â”€ âš™ï¸  create_branch() (line 153)
       ğŸ’¬ Create a new branch pointing to a specific commit
   â””â”€â”€ âš™ï¸  delete_branch() (line 161)
       ğŸ’¬ Delete a branch (but not the commits it pointed to)
   â””â”€â”€ âš™ï¸  update_branch_head() (line 169)
       ğŸ’¬ Update a branch to point to a different commit (e.g., after new commit)
   â””â”€â”€ âš™ï¸  list_branches() (line 176)
       ğŸ’¬ List all branches with their head commits
   â””â”€â”€ âš™ï¸  get_branch_head() (line 181)
       ğŸ’¬ Get the head commit of a branch
   â””â”€â”€ âš™ï¸  get_commit() (line 191)
       ğŸ’¬ Get a specific commit by ID
   â””â”€â”€ âš™ï¸  get_commit_history() (line 196)
       ğŸ’¬ Get all commits in chronological order
   â””â”€â”€ âš™ï¸  get_branch_history() (line 201)
       ğŸ’¬ Get the commit history for a specific branch (following parent chain)
   â””â”€â”€ âš™ï¸  get_children() (line 209)
       ğŸ’¬ Get all children of a commit
   â””â”€â”€ âš™ï¸  get_parents() (line 214)
       ğŸ’¬ Get the parent(s) of a commit
   â””â”€â”€ âš™ï¸  is_ancestor() (line 219)
       ğŸ’¬ Check if one commit is an ancestor of another
   â””â”€â”€ âš™ï¸  find_common_ancestor() (line 224)
       ğŸ’¬ Find the lowest common ancestor of two commits (useful for merging)
   â””â”€â”€ âš™ï¸  diff_commits() (line 234)
       ğŸ’¬ Compute the changes between two commits
   â””â”€â”€ âš™ï¸  get_commit_delta() (line 243)
       ğŸ’¬ Get the delta (direct changes) introduced by a specific commit
   â””â”€â”€ âš™ï¸  reconstruct_state_at() (line 254)
       ğŸ’¬ Reconstruct the complete graph state at a specific commit This is expensive but necessary for time-travel functionality
   â””â”€â”€ âš™ï¸  get_delta_sequence() (line 263)
       ğŸ’¬ Get the sequence of deltas needed to go from one commit to another
   â””â”€â”€ âš™ï¸  find_reachable_commits() (line 273)
       ğŸ’¬ Find all commits reachable from branches and tags
   â””â”€â”€ âš™ï¸  garbage_collect() (line 281)
       ğŸ’¬ Remove unreachable commits and their deltas
   â””â”€â”€ âš™ï¸  statistics() (line 296)
       ğŸ’¬ Get statistics about the history system
   â””â”€â”€ âš™ï¸  list_all_commits() (line 301)
       ğŸ’¬ List all commit IDs in the system
   â””â”€â”€ âš™ï¸  has_commit() (line 306)
       ğŸ’¬ Check if a commit exists

ğŸ”§ IMPL: Commit (line 342)
   â””â”€â”€ âš™ï¸  new() (line 344)
       ğŸ’¬ Create a new commit
   â””â”€â”€ âš™ï¸  is_root() (line 357)
       ğŸ’¬ Check if this is a root commit (no parents)
   â””â”€â”€ âš™ï¸  is_merge() (line 362)
       ğŸ’¬ Check if this is a merge commit (multiple parents)

ğŸ”§ IMPL: Delta (line 394)
   â””â”€â”€ âš™ï¸  from_changes() (line 396)
       ğŸ’¬ Create a delta from a change set
   â””â”€â”€ âš™ï¸  is_empty() (line 402)
       ğŸ’¬ Check if this delta is empty (no changes)
   â””â”€â”€ âš™ï¸  summary() (line 407)
       ğŸ’¬ Get a summary of what changed

ğŸ”§ IMPL: Default for HistoryForest (line 453)
   â””â”€â”€ âš™ï¸  default() (line 454)

ğŸ”§ IMPL: ViewSummary (line 864)
   â””â”€â”€ âš™ï¸  description() (line 866)
       ğŸ’¬ Get a human-readable description of this view
   â””â”€â”€ âš™ï¸  age_seconds() (line 877)
       ğŸ’¬ Get the age of this state in seconds

============================================================
FILE: core/state.rs
============================================================

ğŸ—ï¸  STRUCT: StateObject (line 23)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: StateMetadata (line 34)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: GraphSnapshot (line 228)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: StateDiff (line 428)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: AttributeChange (line 481)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: SnapshotStatistics (line 497)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: DiffSummary (line 507)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: EntityType (line 490)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: StateObject (line 49)
   â””â”€â”€ âš™ï¸  new() (line 51)
       ğŸ’¬ Create a new state object
   â””â”€â”€ âš™ï¸  new_root() (line 75)
       ğŸ’¬ Create a root state (no parent)
   â””â”€â”€ âš™ï¸  parent() (line 80)
       ğŸ’¬ Get the parent state ID
   â””â”€â”€ âš™ï¸  delta() (line 85)
       ğŸ’¬ Get the delta object
   â””â”€â”€ âš™ï¸  metadata() (line 90)
       ğŸ’¬ Get the metadata
   â””â”€â”€ âš™ï¸  is_root() (line 95)
       ğŸ’¬ Check if this is a root state (no parent)
   â””â”€â”€ âš™ï¸  content_hash() (line 100)
       ğŸ’¬ Get the content hash
   â””â”€â”€ âš™ï¸  timestamp() (line 105)
       ğŸ’¬ Get the timestamp
   â””â”€â”€ âš™ï¸  author() (line 110)
       ğŸ’¬ Get the author
   â””â”€â”€ âš™ï¸  label() (line 115)
       ğŸ’¬ Get the label
   â””â”€â”€ âš™ï¸  message() (line 120)
       ğŸ’¬ Get the commit message
   â””â”€â”€ âš™ï¸  tags() (line 125)
       ğŸ’¬ Get tags
   â””â”€â”€ âš™ï¸  add_tag() (line 130)
       ğŸ’¬ Add a tag to this state's metadata
   â””â”€â”€ âš™ï¸  remove_tag() (line 138)
       ğŸ’¬ Remove a tag from this state's metadata
   â””â”€â”€ âš™ï¸  has_tag() (line 145)
       ğŸ’¬ Check if this state has a specific tag
   â””â”€â”€ âš™ï¸  set_label() (line 150)
       ğŸ’¬ Update the label
   â””â”€â”€ âš™ï¸  set_message() (line 157)
       ğŸ’¬ Update the message
   â””â”€â”€ âš™ï¸  delta_size() (line 164)
       ğŸ’¬ Get the size of this state's delta in terms of change count
   â””â”€â”€ âš™ï¸  is_empty_delta() (line 169)
       ğŸ’¬ Check if this state represents an empty delta

ğŸ”§ IMPL: StateMetadata (line 174)
   â””â”€â”€ âš™ï¸  new() (line 176)
       ğŸ’¬ Create new metadata
   â””â”€â”€ âš™ï¸  with_message() (line 188)
       ğŸ’¬ Create metadata with a message
   â””â”€â”€ âš™ï¸  timestamp_string() (line 200)
       ğŸ’¬ Get a human-readable timestamp
   â””â”€â”€ âš™ï¸  short_hash() (line 207)
       ğŸ’¬ Get a short hash representation

ğŸ”§ IMPL: GraphSnapshot (line 249)
   â””â”€â”€ âš™ï¸  empty() (line 251)
       ğŸ’¬ Create an empty snapshot for the given state
   â””â”€â”€ âš™ï¸  apply_delta() (line 274)
       ğŸ’¬ Apply a delta to this snapshot to create a new snapshot ALGORITHM: 1. Start with a copy of this snapshot 2. Apply node additions/removals from delta 3. Apply edge additions/removals from delta 4. Apply attribute changes from delta 5. Update state_id to target state 6. Return the new snapshot PERFORMANCE: O(changes in delta + size of current snapshot for cloning)
   â””â”€â”€ âš™ï¸  reconstruct_from_deltas() (line 314)
       ğŸ’¬ Create a snapshot by applying a sequence of deltas ALGORITHM: 1. Start with base snapshot (or empty) 2. Apply each delta in sequence 3. Return final snapshot USAGE: This is the main reconstruction function used by HistoryForest
   â””â”€â”€ âš™ï¸  diff_with() (line 338)
       ğŸ’¬ Compare this snapshot with another to produce a diff ALGORITHM: 1. Compare active nodes (added/removed) 2. Compare edges (added/removed) 3. Compare all attributes (changed values) 4. Return structured diff
   â””â”€â”€ âš™ï¸  statistics() (line 363)
       ğŸ’¬ Get basic statistics about this snapshot
   â””â”€â”€ âš™ï¸  estimate_memory_usage() (line 378)
       ğŸ’¬ Estimate memory usage of this snapshot in bytes
   â””â”€â”€ âš™ï¸  contains_node() (line 385)
       ğŸ’¬ Check if a node exists in this snapshot
   â””â”€â”€ âš™ï¸  contains_edge() (line 391)
       ğŸ’¬ Check if an edge exists in this snapshot
   â””â”€â”€ âš™ï¸  get_neighbors() (line 397)
       ğŸ’¬ Get all neighbors of a node in this snapshot

ğŸ”§ IMPL: StateDiff (line 438)
   â””â”€â”€ âš™ï¸  empty() (line 440)
       ğŸ’¬ Create an empty diff between two states
   â””â”€â”€ âš™ï¸  is_empty() (line 455)
       ğŸ’¬ Check if this diff represents any changes
   â””â”€â”€ âš™ï¸  summary() (line 466)
       ğŸ’¬ Get a summary of the changes in this diff

âš™ï¸  FUNCTION: merge_snapshots() (line 526)
   ğŸ“ Merge two snapshots (for branch merging) ALGORITHM: 1. Union of active nodes and edges 2. Merge attributes (conflict resolution needed) 3. Create new snapshot with merged state

âš™ï¸  FUNCTION: validate_snapshot() (line 543)
   ğŸ“ Validate that a snapshot is internally consistent CHECKS: 1. All edges reference active nodes 2. All attribute maps reference active entities 3. No duplicate IDs

âš™ï¸  FUNCTION: test_state_object_creation() (line 565)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_state_tags() (line 580)
   ğŸ·ï¸  #test

============================================================
FILE: core/space.rs
============================================================

ğŸ—ï¸  STRUCT: GraphSpace (line 63)
   ğŸ·ï¸  #derive(Debug)

ğŸ”§ IMPL: GraphSpace (line 104)
   â””â”€â”€ âš™ï¸  new() (line 106)
       ğŸ’¬ Create a new empty graph space
   â””â”€â”€ âš™ï¸  activate_node() (line 123)
       ğŸ’¬ Add a node to the active set (called by Graph.add_node())
   â””â”€â”€ âš™ï¸  deactivate_node() (line 129)
       ğŸ’¬ Remove a node from the active set (called by Graph.remove_node())
   â””â”€â”€ âš™ï¸  activate_edge() (line 137)
       ğŸ’¬ Add an edge to the active set (called by Graph.add_edge())
   â””â”€â”€ âš™ï¸  deactivate_edge() (line 143)
       ğŸ’¬ Remove an edge from the active set (called by Graph.remove_edge())
   â””â”€â”€ âš™ï¸  set_node_attr_index() (line 157)
       ğŸ’¬ Update the current attribute index for a node (called by Graph after Pool storage)
   â””â”€â”€ âš™ï¸  set_edge_attr_index() (line 165)
       ğŸ’¬ Update the current attribute index for an edge (called by Graph after Pool storage)
   â””â”€â”€ âš™ï¸  get_node_attr_index() (line 173)
       ğŸ’¬ Get current attribute index for a node (used by Graph for change tracking)
   â””â”€â”€ âš™ï¸  get_edge_attr_index() (line 181)
       ğŸ’¬ Get current attribute index for an edge (used by Graph for change tracking)
   â””â”€â”€ âš™ï¸  node_count() (line 194)
       ğŸ’¬ Get the number of active nodes
   â””â”€â”€ âš™ï¸  edge_count() (line 199)
       ğŸ’¬ Get the number of active edges
   â””â”€â”€ âš™ï¸  contains_node() (line 204)
       ğŸ’¬ Check if a node is currently active
   â””â”€â”€ âš™ï¸  contains_edge() (line 209)
       ğŸ’¬ Check if an edge is currently active
   â””â”€â”€ âš™ï¸  get_active_nodes() (line 214)
       ğŸ’¬ Get all active node IDs (for iteration)
   â””â”€â”€ âš™ï¸  get_active_edges() (line 219)
       ğŸ’¬ Get all active edge IDs (for iteration)
   â””â”€â”€ âš™ï¸  node_ids() (line 229)
       ğŸ’¬ Get all active node IDs as a vector
   â””â”€â”€ âš™ï¸  edge_ids() (line 235)
       ğŸ’¬ Get all active edge IDs as a vector
   â””â”€â”€ âš™ï¸  has_uncommitted_changes() (line 249)
       ğŸ’¬ Check if there are uncommitted changes
   â””â”€â”€ âš™ï¸  uncommitted_change_count() (line 255)
       ğŸ’¬ Get the number of uncommitted changes
   â””â”€â”€ âš™ï¸  change_summary() (line 261)
       ğŸ’¬ Get summary of uncommitted changes
   â””â”€â”€ âš™ï¸  get_base_state() (line 267)
       ğŸ’¬ Get the base state this workspace is built on
   â””â”€â”€ âš™ï¸  create_change_delta() (line 274)
       ğŸ’¬ Create a delta object representing current changes USAGE: Called when committing changes to history
   â””â”€â”€ âš™ï¸  reset_hard() (line 285)
       ğŸ’¬ Clear all uncommitted changes (reset to base state) WARNING: This loses all work since the last commit

============================================================
FILE: core/change_tracker.rs
============================================================

ğŸ—ï¸  STRUCT: ChangeTracker (line 45)
   ğŸ·ï¸  #derive(Debug)

ğŸ—ï¸  STRUCT: ChangeSummary (line 354)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: MergeConflict (line 408)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: ChangeStatistics (line 433)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: ChangeSet (line 446)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: ReverseOperation (line 379)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”¢ ENUM: ConflictType (line 417)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: ChangeTracker (line 53)
   â””â”€â”€ âš™ï¸  new() (line 55)
       ğŸ’¬ Create a new change tracker with default strategy (IndexDeltas)
   â””â”€â”€ âš™ï¸  with_strategy() (line 60)
       ğŸ’¬ Create a new change tracker with specific strategy
   â””â”€â”€ âš™ï¸  with_custom_strategy() (line 67)
       ğŸ’¬ Create a change tracker with a custom strategy instance
   â””â”€â”€ âš™ï¸  record_node_addition() (line 82)
       ğŸ’¬ Record that a new node was added
   â””â”€â”€ âš™ï¸  record_node_removal() (line 87)
       ğŸ’¬ Record that a node was removed
   â””â”€â”€ âš™ï¸  record_edge_addition() (line 92)
       ğŸ’¬ Record that a new edge was added
   â””â”€â”€ âš™ï¸  record_edge_removal() (line 97)
       ğŸ’¬ Record that an edge was removed
   â””â”€â”€ âš™ï¸  record_node_attr_changes() (line 103)
       ğŸ’¬ Record node attribute changes (index-based, efficient bulk recording) This is the main API - all attribute changes are recorded as indices
   â””â”€â”€ âš™ï¸  record_node_attr_change() (line 117)
       ğŸ’¬ Record single node attribute change (convenience wrapper)
   â””â”€â”€ âš™ï¸  record_edge_attr_changes() (line 129)
       ğŸ’¬ Record edge attribute changes (index-based, efficient bulk recording) This is the main API - all attribute changes are recorded as indices
   â””â”€â”€ âš™ï¸  record_edge_attr_change() (line 143)
       ğŸ’¬ Record single edge attribute change (convenience wrapper)
   â””â”€â”€ âš™ï¸  record_node_additions() (line 162)
       ğŸ’¬ Record multiple node additions efficiently
   â””â”€â”€ âš™ï¸  has_changes() (line 181)
       ğŸ’¬ Check if there are any uncommitted changes
   â””â”€â”€ âš™ï¸  change_count() (line 186)
       ğŸ’¬ Get the total number of changes recorded
   â””â”€â”€ âš™ï¸  get_modified_nodes() (line 193)
       ğŸ’¬ Get all nodes that have been modified (added, removed, or attrs changed)
   â””â”€â”€ âš™ï¸  get_modified_edges() (line 201)
       ğŸ’¬ Get all edges that have been modified
   â””â”€â”€ âš™ï¸  is_node_modified() (line 206)
       ğŸ’¬ Check if a specific node has been modified
   â””â”€â”€ âš™ï¸  is_edge_modified() (line 213)
       ğŸ’¬ Check if a specific edge has been modified
   â””â”€â”€ âš™ï¸  create_delta() (line 228)
       ğŸ’¬ Create a delta object representing all current changes This is used when committing to history
   â””â”€â”€ âš™ï¸  create_change_set() (line 233)
       ğŸ’¬ Create a change set that can be passed to HistoryForest
   â””â”€â”€ âš™ï¸  clear() (line 248)
       ğŸ’¬ Clear all recorded changes (rollback to last commit state)
   â””â”€â”€ âš™ï¸  strategy_name() (line 257)
       ğŸ’¬ Get the name of the current strategy
   â””â”€â”€ âš™ï¸  storage_characteristics() (line 262)
       ğŸ’¬ Get the storage characteristics of the current strategy
   â””â”€â”€ âš™ï¸  change_summary() (line 267)
       ğŸ’¬ Get a summary of what has changed (compatibility method)
   â””â”€â”€ âš™ï¸  generate_reverse_operations() (line 284)
       ğŸ’¬ Generate the reverse operations needed to undo all changes This is useful for implementing rollback functionality
   â””â”€â”€ âš™ï¸  merge() (line 299)
       ğŸ’¬ Merge changes from another change tracker This is complex because changes might conflict
   â””â”€â”€ âš™ï¸  would_conflict_with() (line 308)
       ğŸ’¬ Check if merging with another change tracker would cause conflicts
   â””â”€â”€ âš™ï¸  optimize() (line 320)
       ğŸ’¬ Optimize the change log by removing redundant entries For example, if a node attribute is changed multiple times, we only need to track the final change
   â””â”€â”€ âš™ï¸  memory_usage() (line 328)
       ğŸ’¬ Estimate the memory usage of the change tracker
   â””â”€â”€ âš™ï¸  statistics() (line 338)
       ğŸ’¬ Get statistics about the changes
   â””â”€â”€ âš™ï¸  time_since_first_change() (line 343)
       ğŸ’¬ Get the time elapsed since the first change

ğŸ”§ IMPL: ChangeSummary (line 365)
   â””â”€â”€ âš™ï¸  is_empty() (line 367)
       ğŸ’¬ Check if any changes have been made
   â””â”€â”€ âš™ï¸  description() (line 372)
       ğŸ’¬ Get a human-readable description of the changes

ğŸ”§ IMPL: ReverseOperation (line 399)
   â””â”€â”€ âš™ï¸  execute() (line 401)
       ğŸ’¬ Execute this reverse operation on a graph pool

ğŸ”§ IMPL: ChangeSet (line 462)
   â””â”€â”€ âš™ï¸  is_empty() (line 464)
       ğŸ’¬ Check if this change set is empty
   â””â”€â”€ âš™ï¸  change_count() (line 469)
       ğŸ’¬ Get the total number of changes in this set

ğŸ”§ IMPL: Default for ChangeTracker (line 474)
   â””â”€â”€ âš™ï¸  default() (line 475)

============================================================
FILE: core/pool.rs
============================================================

ğŸ—ï¸  STRUCT: GraphPool (line 59)
   ğŸ·ï¸  #derive(Debug)

ğŸ—ï¸  STRUCT: AttributeColumn (line 339)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: PoolStatistics (line 400)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: GraphPool (line 95)
   â””â”€â”€ âš™ï¸  new() (line 97)
       ğŸ’¬ Create new empty graph store
   â””â”€â”€ âš™ï¸  commit_baseline() (line 109)
       ğŸ’¬ Commit changes (no-op for append-only storage) In append-only storage, committing just means the current indices become the new baseline
   â””â”€â”€ âš™ï¸  get_node_attr_by_index() (line 118)
       ğŸ’¬ Get attribute value by index (for Space to resolve indices)
   â””â”€â”€ âš™ï¸  get_edge_attr_by_index() (line 129)
       ğŸ’¬ Get edge attribute value by index (for Space to resolve indices)
   â””â”€â”€ âš™ï¸  add_node() (line 146)
       ğŸ’¬ Create a new node and return its ID DESIGN: Pool creates the node, Space tracks it as active
   â””â”€â”€ âš™ï¸  add_edge() (line 154)
       ğŸ’¬ Create a new edge between two nodes DESIGN: Pool creates and stores the edge, Space tracks it as active
   â””â”€â”€ âš™ï¸  get_edge_endpoints() (line 162)
       ğŸ’¬ Get the endpoints of an edge from storage
   â””â”€â”€ âš™ï¸  set_node_attr() (line 174)
       ğŸ’¬ Set single node attribute value (appends to column and returns index) DESIGN: Space will manage the node->index mapping, Pool just stores values
   â””â”€â”€ âš™ï¸  set_node_attrs() (line 184)
       ğŸ’¬ Set multiple attributes on single node (appends to columns and returns indices)
   â””â”€â”€ âš™ï¸  set_nodes_attr() (line 197)
       ğŸ’¬ Set same attribute for multiple nodes (appends to column and returns indices)
   â””â”€â”€ âš™ï¸  set_edge_attr() (line 207)
       ğŸ’¬ Set single edge attribute value (appends to column and returns index)
   â””â”€â”€ âš™ï¸  get_node_attr_column() (line 236)
       ğŸ’¬ Get full attribute column for nodes (internal use only) INTERNAL: This exposes the full column - Graph coordinator handles filtering PERFORMANCE: Direct access to columnar data for maximum efficiency RETURNS: Reference to the entire attribute vector
   â””â”€â”€ âš™ï¸  get_edge_attr_column() (line 244)
       ğŸ’¬ Get full attribute column for edges (internal use only) INTERNAL: This exposes the full column - Graph coordinator handles filtering
   â””â”€â”€ âš™ï¸  get_node_attrs_at_indices() (line 253)
       ğŸ’¬ Get attribute values for specific indices (internal bulk operation) INTERNAL: Used by Graph when it has already determined which indices to access PERFORMANCE: More efficient than individual lookups for known valid indices
   â””â”€â”€ âš™ï¸  get_edge_attrs_at_indices() (line 272)
       ğŸ’¬ Get attribute values for specific edge indices (internal)
   â””â”€â”€ âš™ï¸  set_nodes_attrs() (line 281)
       ğŸ’¬ Set multiple attributes on multiple nodes (bulk operation) Returns the new indices for change tracking
   â””â”€â”€ âš™ï¸  set_edges_attrs() (line 302)
       ğŸ’¬ Set multiple attributes on multiple edges (bulk operation) Returns the new indices for change tracking
   â””â”€â”€ âš™ï¸  statistics() (line 326)
       ğŸ’¬ Get basic statistics about the graph
   â””â”€â”€ âš™ï¸  attribute_names() (line 332)
       ğŸ’¬ List all attribute names currently in use

ğŸ”§ IMPL: AttributeColumn (line 351)
   â””â”€â”€ âš™ï¸  new() (line 353)
       ğŸ’¬ Create new empty attribute column
   â””â”€â”€ âš™ï¸  append_value() (line 362)
       ğŸ’¬ Append a new value and return its index
   â””â”€â”€ âš™ï¸  get_value() (line 371)
       ğŸ’¬ Get value at specific index
   â””â”€â”€ âš™ï¸  increment_ref() (line 376)
       ğŸ’¬ Increment reference count for an index
   â””â”€â”€ âš™ï¸  decrement_ref() (line 381)
       ğŸ’¬ Decrement reference count for an index
   â””â”€â”€ âš™ï¸  get_unreferenced_indices() (line 388)
       ğŸ’¬ Get all indices with zero references (for garbage collection)

ğŸ”§ IMPL: Default for GraphPool (line 408)
   â””â”€â”€ âš™ï¸  default() (line 409)

============================================================
FILE: core/delta.rs
============================================================

ğŸ—ï¸  STRUCT: ColumnIndexDelta (line 39)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: ColumnDelta (line 107)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: DeltaObject (line 187)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: ColumnIndexDelta (line 48)
   â””â”€â”€ âš™ï¸  new() (line 50)
       ğŸ’¬ Create a new empty index delta
   â””â”€â”€ âš™ï¸  add_index_change() (line 59)
       ğŸ’¬ Add an index change at the specified entity index
   â””â”€â”€ âš™ï¸  get_change() (line 75)
       ğŸ’¬ Get the change at a specific entity index
   â””â”€â”€ âš™ï¸  has_change() (line 82)
       ğŸ’¬ Check if this delta has changes at the given entity index
   â””â”€â”€ âš™ï¸  len() (line 87)
       ğŸ’¬ Get the number of changes in this delta
   â””â”€â”€ âš™ï¸  is_empty() (line 92)
       ğŸ’¬ Check if this delta is empty

ğŸ”§ IMPL: Hash for ColumnIndexDelta (line 97)
   â””â”€â”€ âš™ï¸  hash() (line 98)

ğŸ”§ IMPL: ColumnDelta (line 114)
   â””â”€â”€ âš™ï¸  new() (line 116)
       ğŸ’¬ Create a new empty column delta
   â””â”€â”€ âš™ï¸  with_capacity() (line 124)
       ğŸ’¬ Create a column delta with initial capacity
   â””â”€â”€ âš™ï¸  add_change() (line 132)
       ğŸ’¬ Add a change at the specified index
   â””â”€â”€ âš™ï¸  get() (line 147)
       ğŸ’¬ Get the value at a specific index, if it exists
   â””â”€â”€ âš™ï¸  has_change() (line 154)
       ğŸ’¬ Check if this delta has changes at the given index
   â””â”€â”€ âš™ï¸  len() (line 159)
       ğŸ’¬ Get the number of changes in this delta
   â””â”€â”€ âš™ï¸  is_empty() (line 164)
       ğŸ’¬ Check if this delta is empty
   â””â”€â”€ âš™ï¸  merge() (line 169)
       ğŸ’¬ Merge another column delta into this one

ğŸ”§ IMPL: Hash for ColumnDelta (line 176)
   â””â”€â”€ âš™ï¸  hash() (line 177)

ğŸ”§ IMPL: DeltaObject (line 200)
   â””â”€â”€ âš™ï¸  new() (line 202)
       ğŸ’¬ Create a new delta object
   â””â”€â”€ âš™ï¸  new_with_indices() (line 251)
       ğŸ’¬ Create a new index-based delta object (placeholder for future full implementation) Currently adapts to existing value-based structure
   â””â”€â”€ âš™ï¸  empty() (line 274)
       ğŸ’¬ Create an empty delta object
   â””â”€â”€ âš™ï¸  is_empty() (line 284)
       ğŸ’¬ Check if this delta is empty (no changes)
   â””â”€â”€ âš™ï¸  change_count() (line 292)
       ğŸ’¬ Get the total number of changes in this delta

ğŸ”§ IMPL: Hash for DeltaObject (line 300)
   â””â”€â”€ âš™ï¸  hash() (line 301)

ğŸ”§ IMPL: PartialEq for DeltaObject (line 306)
   â””â”€â”€ âš™ï¸  eq() (line 307)

ğŸ”§ IMPL: Eq for DeltaObject (line 312)

âš™ï¸  FUNCTION: test_column_delta_basic_operations() (line 319)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_column_delta_maintains_order() (line 334)
   ğŸ·ï¸  #test

============================================================
FILE: core/ref_manager.rs
============================================================

ğŸ—ï¸  STRUCT: Branch (line 48)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: RefManager (line 140)
   ğŸ·ï¸  #derive(Debug)

ğŸ—ï¸  STRUCT: BranchInfo (line 548)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: TagInfo (line 584)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: RefStatistics (line 591)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: Branch (line 70)
   â””â”€â”€ âš™ï¸  new() (line 72)
       ğŸ’¬ Create a new branch pointing to a specific state
   â””â”€â”€ âš™ï¸  with_description() (line 85)
       ğŸ’¬ Create a branch with a description
   â””â”€â”€ âš™ï¸  update_head() (line 105)
       ğŸ’¬ Update the head of this branch to a new state USAGE: Called when new commits are made on this branch
   â””â”€â”€ âš™ï¸  set_description() (line 111)
       ğŸ’¬ Set or update the description
   â””â”€â”€ âš™ï¸  is_older_than_days() (line 117)
       ğŸ’¬ Check if this branch is older than a certain number of days

ğŸ”§ IMPL: RefManager (line 167)
   â””â”€â”€ âš™ï¸  new() (line 169)
       ğŸ’¬ Create a new reference manager with a default branch
   â””â”€â”€ âš™ï¸  with_default_branch() (line 192)
       ğŸ’¬ Create a new reference manager with a custom default branch name
   â””â”€â”€ âš™ï¸  create_branch() (line 208)
       ğŸ’¬ Create a new branch pointing to a specific state ALGORITHM: 1. Check that branch name doesn't already exist 2. Validate that the target state exists (optional check) 3. Create Branch object with metadata 4. Add to branches map
   â””â”€â”€ âš™ï¸  checkout_branch() (line 240)
       ğŸ’¬ Switch to a different branch (checkout) ALGORITHM: 1. Verify the target branch exists 2. Update current_branch pointer 3. Return the state ID that should be loaded
   â””â”€â”€ âš™ï¸  delete_branch() (line 261)
       ğŸ’¬ Delete a branch RESTRICTIONS: - Cannot delete the default branch - Cannot delete the currently checked out branch - Branch must exist
   â””â”€â”€ âš™ï¸  list_branches() (line 289)
       ğŸ’¬ List all branches with their metadata
   â””â”€â”€ âš™ï¸  get_current_branch() (line 306)
       ğŸ’¬ Get the currently checked out branch
   â””â”€â”€ âš™ï¸  get_branch() (line 318)
       ğŸ’¬ Get a specific branch by name
   â””â”€â”€ âš™ï¸  update_current_branch_head() (line 332)
       ğŸ’¬ Update the head of the current branch USAGE: Called after making a new commit
   â””â”€â”€ âš™ï¸  update_branch_head() (line 349)
       ğŸ’¬ Update the head of a specific branch
   â””â”€â”€ âš™ï¸  create_tag() (line 371)
       ğŸ’¬ Create a new tag pointing to a specific state IMMUTABILITY: Tags cannot be moved once created
   â””â”€â”€ âš™ï¸  delete_tag() (line 385)
       ğŸ’¬ Delete a tag
   â””â”€â”€ âš™ï¸  list_tags() (line 399)
       ğŸ’¬ List all tags
   â””â”€â”€ âš™ï¸  get_tag() (line 411)
       ğŸ’¬ Get the state ID for a specific tag
   â””â”€â”€ âš™ï¸  get_referenced_states() (line 423)
       ğŸ’¬ Get all state IDs referenced by branches and tags USAGE: For garbage collection - these states should not be deleted
   â””â”€â”€ âš™ï¸  prune_invalid_branches() (line 448)
       ğŸ’¬ Clean up branches that point to non-existent states USAGE: After garbage collection in the history system RETURNS: Number of branches that were removed
   â””â”€â”€ âš™ï¸  prune_invalid_tags() (line 470)
       ğŸ’¬ Clean up tags that point to non-existent states RETURNS: Number of tags that were removed
   â””â”€â”€ âš™ï¸  statistics() (line 490)
       ğŸ’¬ Get basic information about the reference manager
   â””â”€â”€ âš™ï¸  list_branch_names() (line 506)
       ğŸ’¬ Get list of all branch names (for error messages)
   â””â”€â”€ âš™ï¸  current_branch_name() (line 512)
       ğŸ’¬ Get the current branch name
   â””â”€â”€ âš™ï¸  default_branch_name() (line 518)
       ğŸ’¬ Get the default branch name
   â””â”€â”€ âš™ï¸  has_branch() (line 524)
       ğŸ’¬ Check if a branch exists
   â””â”€â”€ âš™ï¸  has_tag() (line 530)
       ğŸ’¬ Check if a tag exists

ğŸ”§ IMPL: Default for RefManager (line 536)
   â””â”€â”€ âš™ï¸  default() (line 537)

ğŸ”§ IMPL: BranchInfo (line 558)
   â””â”€â”€ âš™ï¸  display_name() (line 560)
       ğŸ’¬ Get a human-readable description of this branch
   â””â”€â”€ âš™ï¸  age_days() (line 574)
       ğŸ’¬ Get the age of this branch in days

âš™ï¸  FUNCTION: test_ref_manager_creation() (line 607)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_branch_creation_and_deletion() (line 621)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_branch_checkout() (line 649)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_tag_operations() (line 668)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_reference_cleanup() (line 692)
   ğŸ·ï¸  #test

âš™ï¸  FUNCTION: test_error_handling() (line 712)
   ğŸ·ï¸  #test

============================================================
FILE: api/graph.rs
============================================================

ğŸ—ï¸  STRUCT: Graph (line 46)
   ğŸ·ï¸  #derive(Debug)

ğŸ—ï¸  STRUCT: GraphStatistics (line 590)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: BranchInfo (line 602)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ—ï¸  STRUCT: CommitInfo (line 611)
   ğŸ·ï¸  #derive(Debug, Clone)

ğŸ”§ IMPL: Graph (line 96)
   â””â”€â”€ âš™ï¸  new() (line 98)
       ğŸ’¬ Create a new empty graph with default settings
   â””â”€â”€ âš™ï¸  with_config() (line 105)
       ğŸ’¬ Create a graph with custom configuration
   â””â”€â”€ âš™ï¸  load_from_path() (line 110)
       ğŸ’¬ Load an existing graph from storage
   â””â”€â”€ âš™ï¸  add_node() (line 129)
       ğŸ’¬ Add a new node to the graph ALGORITHM: 1. Pool creates and stores the node 2. Space tracks it as active 3. Return the node ID to caller PERFORMANCE: O(1) amortized
   â””â”€â”€ âš™ï¸  add_nodes() (line 138)
       ğŸ’¬ Add multiple nodes efficiently More efficient than calling add_node() in a loop
   â””â”€â”€ âš™ï¸  add_edge() (line 150)
       ğŸ’¬ Add an edge between two existing nodes ALGORITHM: 1. Validate nodes exist in active set 2. Pool creates and stores the edge 3. Space tracks it as active 4. Return edge ID
   â””â”€â”€ âš™ï¸  add_edges() (line 162)
       ğŸ’¬ Add multiple edges efficiently More efficient than calling add_edge() in a loop
   â””â”€â”€ âš™ï¸  remove_node() (line 171)
       ğŸ’¬ Remove a node and all its incident edges ALGORITHM: 1. Ask space to remove the node (it handles incident edges)
   â””â”€â”€ âš™ï¸  remove_edge() (line 177)
       ğŸ’¬ Remove an edge
   â””â”€â”€ âš™ï¸  set_node_attr() (line 193)
       ğŸ’¬ Set an attribute value on a node ALGORITHM: 1. Pool sets value and returns baseline (integrated change tracking) 2. Space records the change for commit delta
   â””â”€â”€ âš™ï¸  set_node_attrs() (line 218)
       ğŸ’¬ Set node attributes in bulk (handles multiple nodes and multiple attributes efficiently)
   â””â”€â”€ âš™ï¸  set_edge_attr() (line 244)
       ğŸ’¬ Set an attribute value on an edge ALGORITHM: 1. Pool sets value and returns baseline (integrated change tracking) 2. Space records the change for commit delta
   â””â”€â”€ âš™ï¸  set_edge_attrs() (line 264)
       ğŸ’¬ Set edge attributes in bulk (handles multiple edges and multiple attributes efficiently)
   â””â”€â”€ âš™ï¸  get_node_attr() (line 288)
       ğŸ’¬ Get an attribute value from a node ALGORITHM: 1. Ask pool to get the current value 2. Return the value
   â””â”€â”€ âš™ï¸  get_edge_attr() (line 298)
       ğŸ’¬ Get an attribute value from an edge ALGORITHM: 1. Ask pool to get the current value 2. Return the value
   â””â”€â”€ âš™ï¸  get_node_attrs() (line 307)
       ğŸ’¬ Get all attributes for a node efficiently ALGORITHM: 1. Ask pool to get the node attributes 2. Return the attributes
   â””â”€â”€ âš™ï¸  get_edge_attrs() (line 316)
       ğŸ’¬ Get all attributes for an edge efficiently ALGORITHM: 1. Ask pool to get the edge attributes 2. Return the attributes
   â””â”€â”€ âš™ï¸  get_nodes_attrs() (line 351)
       ğŸ’¬ Get attribute values for specific nodes (secure and efficient) ALGORITHM: 1. Filter requested nodes to only active ones 2. Get full attribute column from pool (efficient) 3. Extract values at active indices only 4. Return results aligned with requested nodes SECURITY: Only returns data for active nodes that were explicitly requested PERFORMANCE: Uses efficient column access internally
   â””â”€â”€ âš™ï¸  get_edges_attrs() (line 378)
       ğŸ’¬ Get attribute values for specific edges (secure and efficient)
   â””â”€â”€ âš™ï¸  contains_node() (line 394)
       ğŸ’¬ Check if a node exists in the graph
   â””â”€â”€ âš™ï¸  contains_edge() (line 400)
       ğŸ’¬ Check if an edge exists in the graph
   â””â”€â”€ âš™ï¸  node_ids() (line 406)
       ğŸ’¬ Get all node IDs currently in the graph
   â””â”€â”€ âš™ï¸  edge_ids() (line 412)
       ğŸ’¬ Get all edge IDs currently in the graph
   â””â”€â”€ âš™ï¸  edge_endpoints() (line 418)
       ğŸ’¬ Get the endpoints of an edge
   â””â”€â”€ âš™ï¸  neighbors() (line 424)
       ğŸ’¬ Get all neighbors of a node
   â””â”€â”€ âš™ï¸  degree() (line 430)
       ğŸ’¬ Get the degree (number of incident edges) of a node
   â””â”€â”€ âš™ï¸  statistics() (line 436)
       ğŸ’¬ Get basic statistics about the current graph
   â””â”€â”€ âš™ï¸  has_uncommitted_changes() (line 448)
       ğŸ’¬ Check if there are uncommitted changes
   â””â”€â”€ âš™ï¸  commit() (line 460)
       ğŸ’¬ Commit current changes to history ALGORITHM: 1. Create a snapshot of current changes (ask space) 2. pool the snapshot in history system with metadata 3. Update current commit pointer 4. Clear change tracker 5. Return new commit ID
   â””â”€â”€ âš™ï¸  reset_hard() (line 473)
       ğŸ’¬ Reset all uncommitted changes
   â””â”€â”€ âš™ï¸  create_branch() (line 482)
       ğŸ’¬ Create a new branch from current state
   â””â”€â”€ âš™ï¸  checkout_branch() (line 489)
       ğŸ’¬ Switch to a different branch
   â””â”€â”€ âš™ï¸  list_branches() (line 502)
       ğŸ’¬ List all branches
   â””â”€â”€ âš™ï¸  commit_history() (line 507)
       ğŸ’¬ Get the commit history
   â””â”€â”€ âš™ï¸  find_nodes() (line 518)
       ğŸ’¬ Find nodes matching attribute criteria
   â””â”€â”€ âš™ï¸  find_edges() (line 523)
       ğŸ’¬ Find edges matching attribute criteria
   â””â”€â”€ âš™ï¸  query() (line 528)
       ğŸ’¬ Run a complex query with multiple criteria
   â””â”€â”€ âš™ï¸  create_view() (line 533)
       ğŸ’¬ Create a read-only view of the graph for analysis
   â””â”€â”€ âš™ï¸  view_at_commit() (line 544)
       ğŸ’¬ Create a read-only view of the graph at a specific commit
   â””â”€â”€ âš™ï¸  diff_commits() (line 549)
       ğŸ’¬ Compare two commits and show differences
   â””â”€â”€ âš™ï¸  optimize() (line 559)
       ğŸ’¬ Optimize internal data structures for better performance
   â””â”€â”€ âš™ï¸  gc_history() (line 568)
       ğŸ’¬ Garbage collect unreferenced historical states
   â””â”€â”€ âš™ï¸  save_to_path() (line 576)
       ğŸ’¬ Save graph to persistent storage

ğŸ”§ IMPL: Default for Graph (line 620)
   â””â”€â”€ âš™ï¸  default() (line 621)

============================================================
SUMMARY: Analyzed 15 files
============================================================