#!/usr/bin/env python3
"""
Generate Python type stub files (.pyi) for the Groggy Rust extension module.

This script introspects the compiled _groggy module and generates comprehensive
type stubs to enable autocomplete and type checking in IDEs and Jupyter notebooks.
"""

import inspect
import importlib
from typing import get_type_hints, List
from pathlib import Path


def generate_stub_for_module(module_name: str, output_path: Path):
    """Generate a .pyi stub file for a compiled extension module."""
    
    # Import the module
    module = importlib.import_module(module_name)
    
    lines = []
    lines.append("# Type stubs for " + module_name)
    lines.append("# Auto-generated by scripts/generate_stubs.py")
    lines.append("# DO NOT EDIT MANUALLY - regenerate with: python scripts/generate_stubs.py")
    lines.append("")
    lines.append("from typing import Any, List, Dict, Optional, Tuple, Union, Iterator")
    lines.append("")
    
    # Get all members
    members = inspect.getmembers(module)
    
    # Separate into functions and classes
    functions = []
    classes = []
    
    for name, obj in members:
        if name.startswith('_'):
            continue  # Skip private members
        
        if inspect.isclass(obj):
            classes.append((name, obj))
        elif inspect.isfunction(obj) or inspect.isbuiltin(obj):
            functions.append((name, obj))
    
    # Generate function stubs
    if functions:
        lines.append("# Module-level functions")
        lines.append("")
        for name, func in sorted(functions):
            doc = inspect.getdoc(func)
            if doc:
                lines.append(f"def {name}(*args, **kwargs) -> Any:")
                lines.append(f'    """')
                for doc_line in doc.split('\n'):
                    lines.append(f"    {doc_line}")
                lines.append(f'    """')
                lines.append("    ...")
            else:
                lines.append(f"def {name}(*args, **kwargs) -> Any: ...")
            lines.append("")
    
    # Generate class stubs
    if classes:
        lines.append("# Classes")
        lines.append("")
        for class_name, cls in sorted(classes):
            lines.extend(generate_class_stub(class_name, cls))
            lines.append("")
    
    # Write to file
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text('\n'.join(lines))
    print(f"✅ Generated stub file: {output_path}")
    print(f"   - {len(functions)} module-level functions")
    print(f"   - {len(classes)} classes")


def generate_class_stub(class_name: str, cls) -> List[str]:
    """Generate stub for a single class."""
    lines = []
    
    # Class definition
    doc = inspect.getdoc(cls)
    lines.append(f"class {class_name}:")
    if doc:
        lines.append(f'    """')
        for doc_line in doc.split('\n'):
            lines.append(f"    {doc_line}")
        lines.append(f'    """')
    
    # Get all methods (including method_descriptor from PyO3)
    methods = []
    for name, method in inspect.getmembers(cls):
        if name.startswith('_') and name not in ['__init__', '__len__', '__getitem__', 
                                                   '__setitem__', '__iter__', '__next__',
                                                   '__str__', '__repr__', '__eq__', '__hash__']:
            continue  # Skip private methods except special ones
        
        # Check if it's callable (covers method, function, builtin, method_descriptor)
        if callable(method):
            methods.append((name, method))
    
    if not methods:
        lines.append("    pass")
        return lines
    
    # Generate method stubs
    for method_name, method in sorted(methods):
        method_doc = inspect.getdoc(method)
        
        # Handle special methods
        if method_name == '__init__':
            lines.append(f"    def __init__(self, *args, **kwargs) -> None:")
        elif method_name == '__len__':
            lines.append(f"    def __len__(self) -> int:")
        elif method_name == '__iter__':
            lines.append(f"    def __iter__(self) -> Iterator:")
        elif method_name == '__next__':
            lines.append(f"    def __next__(self) -> Any:")
        elif method_name == '__getitem__':
            lines.append(f"    def __getitem__(self, key: Any) -> Any:")
        elif method_name == '__setitem__':
            lines.append(f"    def __setitem__(self, key: Any, value: Any) -> None:")
        elif method_name == '__str__':
            lines.append(f"    def __str__(self) -> str:")
        elif method_name == '__repr__':
            lines.append(f"    def __repr__(self) -> str:")
        elif method_name == '__eq__':
            lines.append(f"    def __eq__(self, other: Any) -> bool:")
        elif method_name == '__hash__':
            lines.append(f"    def __hash__(self) -> int:")
        else:
            lines.append(f"    def {method_name}(self, *args, **kwargs) -> Any:")
        
        # Add docstring
        if method_doc:
            lines.append(f'        """')
            for doc_line in method_doc.split('\n'):
                lines.append(f"        {doc_line}")
            lines.append(f'        """')
        
        lines.append("        ...")
        lines.append("")
    
    return lines


def main():
    """Generate stubs for groggy._groggy module."""
    
    print("🔨 Generating Python type stubs for Groggy...")
    print("")
    
    # Generate stub for _groggy module
    module_name = "groggy._groggy"
    output_path = Path("python-groggy/python/groggy/_groggy.pyi")
    
    try:
        generate_stub_for_module(module_name, output_path)
        print("")
        print("✨ Success! Type stubs generated.")
        print("📚 Test in Jupyter: import groggy; g = groggy.Graph(); g.<TAB>")
        print("")
        print("📝 To regenerate stubs after changes:")
        print("   1. maturin develop --release")
        print("   2. python scripts/generate_stubs.py")
        
    except Exception as e:
        print(f"❌ Error generating stubs: {e}")
        import traceback
        traceback.print_exc()
        return 1
    
    return 0


if __name__ == "__main__":
    exit(main())
