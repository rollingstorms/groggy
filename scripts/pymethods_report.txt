\npython-groggy/src/ffi/display.rs:21 #[pymethods]
impl PyDisplayConfig {
    fn new(


\npython-groggy/src/ffi/display.rs:157 #[pyfunction]
pub fn py_format_array(data: &PyDict, config: Option<&PyDisplayConfig>) -> PyResult<String> {


#[pyfunction]
pub fn py_format_matrix(data: &PyDict, config: Option<&PyDisplayConfig>) -> PyResult<String> {


#[pyfunction]
pub fn py_format_table(data: &PyDict, config: Option<&PyDisplayConfig>) -> PyResult<String> {

\npython-groggy/src/ffi/display.rs:168 #[pyfunction]
pub fn py_format_matrix(data: &PyDict, config: Option<&PyDisplayConfig>) -> PyResult<String> {


#[pyfunction]
pub fn py_format_table(data: &PyDict, config: Option<&PyDisplayConfig>) -> PyResult<String> {


#[pyfunction]
pub fn py_format_data_structure(
\npython-groggy/src/ffi/display.rs:179 #[pyfunction]
pub fn py_format_table(data: &PyDict, config: Option<&PyDisplayConfig>) -> PyResult<String> {


#[pyfunction]
pub fn py_format_data_structure(


#[pyfunction]
pub fn py_detect_display_type(data: &PyDict) -> PyResult<String> {
\npython-groggy/src/ffi/display.rs:190 #[pyfunction]
pub fn py_format_data_structure(


#[pyfunction]
pub fn py_detect_display_type(data: &PyDict) -> PyResult<String> {

pub fn register_display_functions(_py: Python, m: &PyModule) -> PyResult<()> {

\npython-groggy/src/ffi/display.rs:205 #[pyfunction]
pub fn py_detect_display_type(data: &PyDict) -> PyResult<String> {

pub fn register_display_functions(_py: Python, m: &PyModule) -> PyResult<()> {



\npython-groggy/src/ffi/types.rs:33 #[pymethods]
impl PyAttrValue {
    fn py_new(value: &PyAny) -> PyResult<Self> {


\npython-groggy/src/ffi/types.rs:284 #[pymethods]
impl PyResultHandle {
    fn nodes(&self) -> Vec<NodeId> {

    fn edges(&self) -> Vec<EdgeId> {

    fn result_type(&self) -> String {

    fn __repr__(&self) -> String {

pub struct PyAttributeCollection {
\npython-groggy/src/ffi/types.rs:319 #[pymethods]
impl PyAttributeCollection {
    fn len(&self) -> usize {

    fn compute_stats(&self, py: Python) -> PyResult<PyObject> {




\npython-groggy/src/ffi/core/traversal.rs:18 #[pymethods]
impl PyAggregationResult {
    fn value(&self) -> f64 {

    fn operation(&self) -> String {

    fn attribute(&self) -> String {

    fn count(&self) -> usize {

    fn __repr__(&self) -> String {

impl PyAggregationResult {
\npython-groggy/src/ffi/core/traversal.rs:67 #[pymethods]
impl PyGroupedAggregationResult {
    fn groups(&self) -> PyObject {

    fn operation(&self) -> String {

    fn attribute(&self) -> String {

    fn __repr__(&self) -> String {

impl PyGroupedAggregationResult {
    pub fn new(groups: PyObject, operation: String, attribute: String) -> Self {
\npython-groggy/src/ffi/core/accessors.rs:62 #[pymethods]
impl NodesIterator {
    fn __iter__(slf: PyRef<Self>) -> PyRef<Self> {

    fn __next__(&mut self, py: Python) -> PyResult<Option<PyObject>> {


pub struct PyNodesAccessor {

#[pymethods]
impl PyNodesAccessor {
\npython-groggy/src/ffi/core/accessors.rs:90 #[pymethods]
impl PyNodesAccessor {
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {


\npython-groggy/src/ffi/core/accessors.rs:580 #[pymethods]
impl EdgesIterator {
    fn __iter__(slf: PyRef<Self>) -> PyRef<Self> {

    fn __next__(&mut self, py: Python) -> PyResult<Option<PyObject>> {


pub struct PyEdgesAccessor {

#[pymethods]
impl PyEdgesAccessor {
\npython-groggy/src/ffi/core/accessors.rs:608 #[pymethods]
impl PyEdgesAccessor {
    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {


\npython-groggy/src/ffi/core/query.rs:18 #[pymethods]
impl PyAttributeFilter {
    fn equals(value: &PyAny) -> PyResult<Self> {

    fn greater_than(value: &PyAny) -> PyResult<Self> {

    fn less_than(value: &PyAny) -> PyResult<Self> {

    fn not_equals(value: &PyAny) -> PyResult<Self> {
\npython-groggy/src/ffi/core/query.rs:76 #[pymethods]
impl PyNodeFilter {
    fn has_attribute(name: AttrName) -> Self {

    fn attribute_equals(name: AttrName, value: &PyAny) -> PyResult<Self> {

    fn attribute_filter(name: AttrName, filter: &PyAttributeFilter) -> Self {

\npython-groggy/src/ffi/core/query.rs:137 #[pymethods]
impl PyEdgeFilter {
    fn has_attribute(name: AttrName) -> Self {

    fn attribute_equals(name: AttrName, value: &PyAny) -> PyResult<Self> {

    fn attribute_filter(name: AttrName, filter: &PyAttributeFilter) -> Self {

\npython-groggy/src/ffi/core/query.rs:285 #[pymethods]
impl PyAggregationResult {
    fn value(&self) -> f64 {

    fn __repr__(&self) -> String {

pub struct PyGroupedAggregationResult {

#[pymethods]
impl PyGroupedAggregationResult {
    fn value(&self) -> PyObject {

    fn __repr__(&self) -> String {
\npython-groggy/src/ffi/core/query.rs:303 #[pymethods]
impl PyGroupedAggregationResult {
    fn value(&self) -> PyObject {

    fn __repr__(&self) -> String {
\npython-groggy/src/ffi/core/matrix.rs:25 #[pymethods]
impl PyGraphMatrix {
    pub fn new(py: Python, arrays: Vec<Py<PyGraphArray>>) -> PyResult<Self> {



    fn zeros(
\npython-groggy/src/ffi/core/query_parser.rs:17 #[pymethods]
impl PyQueryParser {
    pub fn new() -> Self {

    pub fn parse_node_query(&mut self, query: &str) -> PyResult<PyNodeFilter> {

    pub fn parse_edge_query(&mut self, query: &str) -> PyResult<PyEdgeFilter> {

    pub fn parse_node_query_debug(&mut self, query: &str) -> PyResult<String> {
\npython-groggy/src/ffi/core/query_parser.rs:111 #[pyfunction]
pub fn parse_node_query(query: &str) -> PyResult<PyNodeFilter> {

#[pyfunction]
pub fn parse_edge_query(query: &str) -> PyResult<PyEdgeFilter> {

#[pyfunction]
pub fn validate_node_query(query: &str) -> bool {

#[pyfunction]
pub fn validate_edge_query(query: &str) -> bool {

\npython-groggy/src/ffi/core/query_parser.rs:120 #[pyfunction]
pub fn parse_edge_query(query: &str) -> PyResult<PyEdgeFilter> {

#[pyfunction]
pub fn validate_node_query(query: &str) -> bool {

#[pyfunction]
pub fn validate_edge_query(query: &str) -> bool {

#[pyfunction]
pub fn get_node_query_error(query: &str) -> Option<String> {
\npython-groggy/src/ffi/core/query_parser.rs:129 #[pyfunction]
pub fn validate_node_query(query: &str) -> bool {

#[pyfunction]
pub fn validate_edge_query(query: &str) -> bool {

#[pyfunction]
pub fn get_node_query_error(query: &str) -> Option<String> {

#[pyfunction]  
pub fn get_edge_query_error(query: &str) -> Option<String> {
\npython-groggy/src/ffi/core/query_parser.rs:136 #[pyfunction]
pub fn validate_edge_query(query: &str) -> bool {

#[pyfunction]
pub fn get_node_query_error(query: &str) -> Option<String> {

#[pyfunction]  
pub fn get_edge_query_error(query: &str) -> Option<String> {


\npython-groggy/src/ffi/core/query_parser.rs:143 #[pyfunction]
pub fn get_node_query_error(query: &str) -> Option<String> {

#[pyfunction]  
pub fn get_edge_query_error(query: &str) -> Option<String> {


    fn test_python_query_parser() {
\npython-groggy/src/ffi/core/query_parser.rs:153 #[pyfunction]
pub fn get_edge_query_error(query: &str) -> Option<String> {


    fn test_python_query_parser() {
\npython-groggy/src/ffi/core/subgraph_old_complex.rs:170 #[pymethods]
impl PySubgraph {
    fn nodes(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyNodesAccessor>> {

    fn edges(self_: PyRef<Self>, py: Python) -> PyResult<Py<PyEdgesAccessor>> {
\npython-groggy/src/ffi/core/history.rs:17 #[pymethods]
impl PyCommit {
    fn id(&self) -> StateId {

    fn parents(&self) -> Vec<StateId> {

    fn message(&self) -> String {

    fn author(&self) -> String {

    fn timestamp(&self) -> u64 {

    fn is_root(&self) -> bool {

\npython-groggy/src/ffi/core/history.rs:67 #[pymethods]
impl PyBranchInfo {
    fn name(&self) -> String {

    fn head(&self) -> StateId {

    fn is_default(&self) -> bool {

    fn is_current(&self) -> bool {

    fn __repr__(&self) -> String {

\npython-groggy/src/ffi/core/history.rs:104 #[pymethods]
impl PyHistoryStatistics {
    fn total_commits(&self) -> usize {

    fn total_branches(&self) -> usize {

    fn total_tags(&self) -> usize {

    fn storage_efficiency(&self) -> f64 {

    fn oldest_commit_age(&self) -> u64 {

    fn newest_commit_age(&self) -> u64 {
\npython-groggy/src/ffi/core/history.rs:153 #[pymethods]
impl PyHistoricalView {
    fn state_id(&self) -> StateId {

    /// access to the graph to reconstruct the state.
    fn get_node_ids(&self) -> PyResult<Vec<NodeId>> {

    fn get_edge_ids(&self) -> PyResult<Vec<EdgeId>> {

    fn __repr__(&self) -> String {
\npython-groggy/src/ffi/core/views.rs:21 #[pymethods]
impl PyNodeView {
    fn __getitem__(&self, py: Python, key: &str) -> PyResult<PyAttrValue> {

    fn __setitem__(&mut self, py: Python, key: &str, value: PyAttrValue) -> PyResult<()> {

    fn id(&self) -> PyResult<NodeId> {

    fn __contains__(&self, py: Python, key: &str) -> PyResult<bool> {
\npython-groggy/src/ffi/core/views.rs:198 #[pymethods]
impl NodeViewIterator {
    fn __iter__(slf: PyRef<Self>) -> PyRef<Self> {

    fn __next__(&mut self, py: Python) -> PyResult<Option<PyObject>> {


impl Clone for PyNodeView {
    fn clone(&self) -> Self {

\npython-groggy/src/ffi/core/views.rs:234 #[pymethods]
impl PyEdgeView {
    fn __getitem__(&self, py: Python, key: &str) -> PyResult<PyAttrValue> {

    fn __setitem__(&mut self, py: Python, key: &str, value: PyAttrValue) -> PyResult<()> {

    fn id(&self) -> PyResult<EdgeId> {

\npython-groggy/src/ffi/core/views.rs:453 #[pymethods]
impl EdgeViewIterator {
    fn __iter__(slf: PyRef<Self>) -> PyRef<Self> {

    fn __next__(&mut self, py: Python) -> PyResult<Option<PyObject>> {


impl Clone for PyEdgeView {
    fn clone(&self) -> Self {
\npython-groggy/src/ffi/core/table.rs:36 #[pymethods]
impl TableIterator {
    fn __iter__(slf: PyRef<Self>) -> PyRef<Self> {

    fn __next__(&mut self, py: Python) -> PyResult<Option<PyObject>> {



\npython-groggy/src/ffi/core/table.rs:77 #[pymethods]
impl PyGraphTable {
    pub fn new(



    pub fn from_graph_nodes(
\npython-groggy/src/ffi/core/table.rs:1097 #[pymethods]
impl PyGroupBy {
    pub fn agg(&self, py: Python, operations: HashMap<String, String>) -> PyResult<PyObject> {
\npython-groggy/src/ffi/core/subgraph.rs:37 #[pymethods]
impl PySubgraph {
    fn nodes(&self, py: Python) -> PyResult<Py<PyNodesAccessor>> {
    fn edges(&self, py: Python) -> PyResult<Py<PyEdgesAccessor>> {
\npython-groggy/src/ffi/core/array.rs:19 #[pymethods]
impl PyGraphArray {
    fn new(values: Vec<PyObject>) -> PyResult<Self> {




    fn __len__(&self) -> usize {

    fn __getitem__(&self, py: Python, key: &PyAny) -> PyResult<PyObject> {
\npython-groggy/src/ffi/core/array.rs:919 #[pymethods]
impl PyStatsSummary {
    fn count(&self) -> usize {

    fn mean(&self) -> Option<f64> {

    fn std(&self) -> Option<f64> {

    fn min(&self, py: Python) -> PyResult<Option<PyObject>> {

    fn max(&self, py: Python) -> PyResult<Option<PyObject>> {
\npython-groggy/src/ffi/core/array.rs:979 #[pymethods]
impl GraphArrayIterator {
    fn __iter__(slf: PyRef<Self>) -> PyRef<Self> {

    fn __next__(&mut self, py: Python) -> PyResult<Option<PyObject>> {

impl PyGraphArray {
    pub fn from_graph_array(array: GraphArray) -> Self {

    pub fn from_py_objects(values: Vec<PyObject>) -> PyResult<Self> {

\npython-groggy/src/ffi/core/component.rs:24 #[pymethods]
impl PyComponentSubgraph {
    fn component_id(&self) -> usize {
    fn is_largest_component(&self) -> bool {
    fn component_size(&self) -> usize {
    fn total_components(&self) -> usize {
    fn node_count(&self) -> usize {
\npython-groggy/src/ffi/core/neighborhood.rs:18 #[pymethods]
impl PyNeighborhoodSubgraph {
    fn central_nodes(&self) -> Vec<NodeId> {

    fn hops(&self) -> usize {
    fn is_central_node(&self, node_id: NodeId) -> bool {


    fn node_count(&self) -> usize {

    fn edge_count(&self) -> usize {
\npython-groggy/src/ffi/core/neighborhood.rs:113 #[pymethods]
impl PyNeighborhoodResult {
    fn neighborhoods(&self) -> Vec<PyNeighborhoodSubgraph> {

    fn total_neighborhoods(&self) -> usize {

    fn largest_neighborhood_size(&self) -> usize {

    fn execution_time_ms(&self) -> f64 {

    fn __len__(&self) -> usize {

    fn __getitem__(&self, index: usize) -> PyResult<PyNeighborhoodSubgraph> {
\npython-groggy/src/ffi/core/neighborhood.rs:181 #[pymethods]
impl PyNeighborhoodResultIterator {
    fn __iter__(slf: PyRef<Self>) -> PyRef<Self> {

    fn __next__(mut slf: PyRefMut<Self>) -> Option<PyNeighborhoodSubgraph> {

pub struct PyNeighborhoodStats {

#[pymethods]
impl PyNeighborhoodStats {
    fn total_neighborhoods(&self) -> usize {
\npython-groggy/src/ffi/core/neighborhood.rs:207 #[pymethods]
impl PyNeighborhoodStats {
    fn total_neighborhoods(&self) -> usize {

    fn total_nodes_sampled(&self) -> usize {

    fn total_time_ms(&self) -> f64 {

    fn operation_counts(&self) -> std::collections::HashMap<String, usize> {

    fn avg_nodes_per_neighborhood(&self) -> f64 {

\npython-groggy/src/ffi/api/graph_version.rs:64 #[pymethods]
impl PyCommit {
    fn id(&self) -> StateId {

    fn parents(&self) -> Vec<StateId> {

    fn message(&self) -> String {

    fn author(&self) -> String {

    fn timestamp(&self) -> u64 {

    fn __repr__(&self) -> String {
\npython-groggy/src/ffi/api/graph_version.rs:113 #[pymethods]
impl PyBranchInfo {
    fn name(&self) -> String {

    fn head(&self) -> StateId {

    fn is_current(&self) -> bool {

    fn __repr__(&self) -> String {

pub struct PyHistoricalView {

\npython-groggy/src/ffi/api/graph_version.rs:144 #[pymethods]
impl PyHistoricalView {
    fn state_id(&self) -> StateId {

    fn __repr__(&self) -> String {

#[pymethods]
impl PyGraphVersion {
    fn commit(&self, py: Python, message: String, author: String) -> PyResult<StateId> {

    fn create_branch(&self, py: Python, branch_name: String) -> PyResult<()> {
\npython-groggy/src/ffi/api/graph_version.rs:156 #[pymethods]
impl PyGraphVersion {
    fn commit(&self, py: Python, message: String, author: String) -> PyResult<StateId> {

    fn create_branch(&self, py: Python, branch_name: String) -> PyResult<()> {

    fn checkout_branch(&self, py: Python, branch_name: String) -> PyResult<()> {
\npython-groggy/src/ffi/api/graph.rs:50 #[pymethods]
impl PyAggregationResult {
    fn value(&self) -> f64 {

    fn __repr__(&self) -> String {

fn adjacency_matrix_to_py_graph_matrix(

fn adjacency_matrix_to_py_object(
\npython-groggy/src/ffi/api/graph.rs:121 #[pymethods]
impl PyGraph {
    fn new(directed: bool, _config: Option<&PyDict>) -> PyResult<Self> {

    fn is_directed(&self) -> bool {

    fn is_undirected(&self) -> bool {


    fn add_node(&mut self, kwargs: Option<&PyDict>) -> PyResult<NodeId> {
\npython-groggy/src/ffi/api/graph_query.rs:22 #[pymethods]
impl PyGraphQuery {
    pub fn filter_nodes(&self, py: Python, filter: &PyAny) -> PyResult<PySubgraph> {
