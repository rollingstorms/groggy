 CODE STRUCTURE ANALYSIS
Directory: ../groggy/python
Generated: py_structure_simple.txt
============================================================

============================================================
FILE: groggy/analysis.py
============================================================

âš™ï¸  FUNCTION: show_changes(graph_or_entity, graph, branch_name) (line 20)
   ğŸ“ Analyze changes across saved states.

âš™ï¸  FUNCTION: _show_graph_changes(graph, branch_name) (line 50)
   ğŸ“ Show all changes across states in a branch.

âš™ï¸  FUNCTION: _show_entity_changes(entity_id, graph, branch_name) (line 98)
   ğŸ“ Show changes for a specific entity across states.

âš™ï¸  FUNCTION: _get_saved_states(graph) (line 192)
   ğŸ“ Get list of saved states from the graph storage.

âš™ï¸  FUNCTION: _analyze_state_diff(graph, prev_hash, curr_hash) (line 209)
   ğŸ“ Analyze differences between two states by loading and comparing them.

âš™ï¸  FUNCTION: _empty_diff() (line 279)
   ğŸ“ Return an empty diff structure.

âš™ï¸  FUNCTION: _compare_graph_states(prev_nodes, prev_edges, curr_nodes, curr_edges) (line 290)
   ğŸ“ Compare two graph states and return the differences.

âš™ï¸  FUNCTION: _print_changes(changes) (line 328)
   ğŸ“ Print formatted change summary.

âš™ï¸  FUNCTION: _print_entity_timeline(entity_id, timeline) (line 343)
   ğŸ“ Print formatted entity timeline.

âš™ï¸  FUNCTION: show_entity_changes(entity_id, graph, branch_name) (line 379)
   ğŸ“ Convenience function for entity-specific analysis.

âš™ï¸  FUNCTION: show_graph_changes(graph, branch_name) (line 383)
   ğŸ“ Convenience function for graph-wide analysis.

âš™ï¸  FUNCTION: track_attribute_changes(graph, attribute_name, branch_name) (line 387)
   ğŸ“ Track changes to a specific attribute across all entities over time

============================================================
FILE: groggy/__init__.py
============================================================

âš™ï¸  FUNCTION: get_available_backends() (line 31)
   ğŸ“ Get list of available backends.

âš™ï¸  FUNCTION: set_backend(backend) (line 38)
   ğŸ“ Set the backend to use for new Graph instances.

âš™ï¸  FUNCTION: get_current_backend() (line 45)
   ğŸ“ Get the currently selected backend.

============================================================
FILE: groggy/utils.py
============================================================

âš™ï¸  FUNCTION: create_random_graph(n_nodes, edge_probability, use_rust) (line 10)
   ğŸ“ Create a random graph efficiently using vectorized operations

âš™ï¸  FUNCTION: create_clustering_workflow(store, graph, algorithms) (line 25)
   ğŸ“ Create branches for different clustering algorithms

âš™ï¸  FUNCTION: create_subgraph_branch(store, subgraph, branch_name, description) (line 42)
   ğŸ“ Create a branch from a subgraph for isolated processing

============================================================
FILE: groggy/data_structures.py
============================================================

ğŸ“ CLASS: Node (line 13)
   ğŸ“ Graph node with attributes
   â””â”€â”€ ğŸ”§ get_attribute(self, key, default) (line 18)
   â””â”€â”€ ğŸ”§ set_attribute(self, key, value) (line 21)
   â””â”€â”€ ğŸ”§ get(self, key, default) (line 27)
   â””â”€â”€ ğŸ”§ __getitem__(self, key) (line 30)
   â””â”€â”€ ğŸ”§ __setitem__(self, key, value) (line 33)
   â””â”€â”€ ğŸ”§ __contains__(self, key) (line 36)
   â””â”€â”€ ğŸ”§ keys(self) (line 39)
   â””â”€â”€ ğŸ”§ values(self) (line 42)
   â””â”€â”€ ğŸ”§ items(self) (line 45)
   â””â”€â”€ ğŸ”§ __iter__(self) (line 48)

ğŸ“ CLASS: Edge (line 53)
   ğŸ“ Graph edge with attributes
   â””â”€â”€ ğŸ”§ id(self) (line 60)
   â””â”€â”€ ğŸ”§ get_attribute(self, key, default) (line 63)
   â””â”€â”€ ğŸ”§ set_attribute(self, key, value) (line 66)
   â””â”€â”€ ğŸ”§ get(self, key, default) (line 72)
   â””â”€â”€ ğŸ”§ __getitem__(self, key) (line 75)
   â””â”€â”€ ğŸ”§ __setitem__(self, key, value) (line 78)
   â””â”€â”€ ğŸ”§ __contains__(self, key) (line 81)
   â””â”€â”€ ğŸ”§ keys(self) (line 84)
   â””â”€â”€ ğŸ”§ values(self) (line 87)
   â””â”€â”€ ğŸ”§ items(self) (line 90)
   â””â”€â”€ ğŸ”§ __iter__(self) (line 93)

ğŸ“ CLASS: GraphDelta (line 97)
   ğŸ“ Tracks changes to a graph for efficient updates
   â””â”€â”€ ğŸ”§ __init__(self) (line 100)
   â””â”€â”€ ğŸ”§ clear(self) (line 108)
       ğŸ’¬ Clear all delta information
   â””â”€â”€ ğŸ”§ is_empty(self) (line 117)
       ğŸ’¬ Check if delta has any changes

============================================================
FILE: groggy/views.py
============================================================

ğŸ“ CLASS: LazyDict (line 8)
   ğŸ“ Zero-copy dictionary view that combines base dict with delta changes
   â””â”€â”€ ğŸ”§ __init__(self, base_dict, delta_added, delta_removed, delta_modified) (line 11)
   â””â”€â”€ ğŸ”§ __getitem__(self, key) (line 18)
   â””â”€â”€ ğŸ”§ get(self, key, default) (line 27)
   â””â”€â”€ ğŸ”§ __contains__(self, key) (line 33)
   â””â”€â”€ ğŸ”§ keys(self) (line 38)
   â””â”€â”€ ğŸ”§ values(self) (line 43)
   â””â”€â”€ ğŸ”§ items(self) (line 46)
   â””â”€â”€ ğŸ”§ __len__(self) (line 49)
   â””â”€â”€ ğŸ”§ __iter__(self) (line 52)
   â””â”€â”€ ğŸ”§ copy(self) (line 55)
       ğŸ’¬ Force materialization to regular dict

ğŸ“ CLASS: NodeView (line 60)
   ğŸ“ View of nodes - works with both dict and Rust backend
   â””â”€â”€ ğŸ”§ __init__(self, data) (line 63)
   â””â”€â”€ ğŸ”§ __len__(self) (line 73)
   â””â”€â”€ ğŸ”§ __contains__(self, node_id) (line 79)
   â””â”€â”€ ğŸ”§ __getitem__(self, node_id) (line 89)
   â””â”€â”€ ğŸ”§ keys(self) (line 97)
   â””â”€â”€ ğŸ”§ __iter__(self) (line 103)
   â””â”€â”€ ğŸ”§ values(self) (line 106)
   â””â”€â”€ ğŸ”§ items(self) (line 112)
   â””â”€â”€ ğŸ”§ items_iter(self) (line 118)
       ğŸ’¬ Iterator version of items() for memory efficiency

ğŸ“ CLASS: EdgeView (line 126)
   ğŸ“ View of edges - works with both dict and Rust backend
   â””â”€â”€ ğŸ”§ __init__(self, data) (line 129)
   â””â”€â”€ ğŸ”§ __len__(self) (line 139)
   â””â”€â”€ ğŸ”§ __contains__(self, edge_id) (line 145)
   â””â”€â”€ ğŸ”§ __getitem__(self, edge_id) (line 159)
   â””â”€â”€ ğŸ”§ keys(self) (line 171)
   â””â”€â”€ ğŸ”§ __iter__(self) (line 177)
   â””â”€â”€ ğŸ”§ values(self) (line 180)
   â””â”€â”€ ğŸ”§ items(self) (line 186)
   â””â”€â”€ ğŸ”§ items_iter(self) (line 192)
       ğŸ’¬ Iterator version of items() for memory efficiency

============================================================
FILE: groggy/graph/filtering.py
============================================================

ğŸ“ CLASS: QueryCompiler (line 19)
   ğŸ“ Compiles string-based queries into executable filter functions.
   â””â”€â”€ ğŸ”§ compile_node_query(cls, query_str) (line 42)
       ğŸ’¬ Compile a string query into a function for node filtering.
   â””â”€â”€ ğŸ”§ compile_edge_query(cls, query_str) (line 58)
       ğŸ’¬ Compile a string query into a function for edge filtering.
   â””â”€â”€ ğŸ”§ _evaluate_query(cls, query_str, context) (line 81)
       ğŸ’¬ Evaluate a query string against a context dictionary.
   â””â”€â”€ ğŸ”§ _preprocess_logical_operators(cls, query_str) (line 110)
       ğŸ’¬ Normalize logical operators.
   â””â”€â”€ ğŸ”§ _split_logical_expression(cls, query_str) (line 119)
       ğŸ’¬ Split expression by logical operators while preserving them.
   â””â”€â”€ ğŸ”§ _evaluate_logical_expression(cls, parts, context) (line 138)
       ğŸ’¬ Evaluate a logical expression with multiple parts.
   â””â”€â”€ ğŸ”§ _evaluate_simple_expression(cls, expr, context) (line 160)
       ğŸ’¬ Evaluate a simple comparison expression.
   â””â”€â”€ ğŸ”§ _parse_literal(cls, value_str) (line 208)
       ğŸ’¬ Parse a literal value from a string.

ğŸ“ CLASS: SubgraphCreator (line 240)
   ğŸ“ Creates subgraphs from filtering operations.
   â””â”€â”€ ğŸ”§ create_node_subgraph(source_graph, node_ids, filter_criteria) (line 244)
       ğŸ’¬ Create a subgraph containing only the specified nodes and edges between them.
   â””â”€â”€ ğŸ”§ create_edge_subgraph(source_graph, edge_ids, filter_criteria) (line 282)
       ğŸ’¬ Create a subgraph containing only the specified edges and their connected nodes.

âš™ï¸  FUNCTION: enhanced_filter_nodes(graph, filter_criteria, return_subgraph) (line 354)
   ğŸ“ Enhanced node filtering with optional subgraph creation.

âš™ï¸  FUNCTION: enhanced_filter_edges(graph, filter_criteria, return_subgraph) (line 409)
   ğŸ“ Enhanced edge filtering with optional subgraph creation.

============================================================
FILE: groggy/graph/batch.py
============================================================

ğŸ“ CLASS: BatchOperationContext (line 12)
   ğŸ“ Context manager for efficient batch operations
   â””â”€â”€ ğŸ”§ __init__(self, graph) (line 15)
   â””â”€â”€ ğŸ”§ __enter__(self) (line 20)
   â””â”€â”€ ğŸ”§ __exit__(self, exc_type, exc_val, exc_tb) (line 23)
   â””â”€â”€ ğŸ”§ add_node(self, node_id) (line 27)
       ğŸ’¬ Queue node for batch addition
   â””â”€â”€ ğŸ”§ add_edge(self, source, target) (line 39)
       ğŸ’¬ Queue edge for batch addition
   â””â”€â”€ ğŸ”§ set_node_attributes(self, node_attr_dict) (line 53)
       ğŸ’¬ Queue bulk node attribute updates
   â””â”€â”€ ğŸ”§ set_edge_attributes(self, edge_attr_dict) (line 78)
       ğŸ’¬ Queue bulk edge attribute updates

============================================================
FILE: groggy/graph/core.py
============================================================

ğŸ“ CLASS: Graph (line 26)
   ğŸ“ High-level Graph interface with automatic Rust/Python backend selection
   â””â”€â”€ ğŸ”§ __init__(self, nodes, edges, graph_attributes, backend, max_auto_states, directed) (line 29)
   â””â”€â”€ ğŸ”§ _init_rust_backend(self, nodes, edges, graph_attributes) (line 73)
       ğŸ’¬ Initialize Rust backend
   â””â”€â”€ ğŸ”§ _init_python_backend(self, nodes, edges, graph_attributes) (line 83)
       ğŸ’¬ Initialize Python backend (fallback)
   â””â”€â”€ ğŸ”§ _invalidate_cache(self) (line 99)
       ğŸ’¬ Invalidate the cache when graph structure changes
   â””â”€â”€ ğŸ”§ empty(cls, backend) (line 110)
       ğŸ’¬ Create an empty graph
   â””â”€â”€ ğŸ”§ from_node_list(cls, node_ids, node_attrs, backend) (line 115)
       ğŸ’¬ Create graph from vectorized node data (NumPy-style)
   â””â”€â”€ ğŸ”§ from_edge_list(cls, edges, node_attrs, edge_attrs, backend) (line 132)
       ğŸ’¬ Create graph from edge list (NetworkX-style)
   â””â”€â”€ ğŸ”§ nodes(self) (line 169)
       ğŸ’¬ Access nodes as a lazy dict-like interface
   â””â”€â”€ ğŸ”§ edges(self) (line 186)
       ğŸ’¬ Access edges as a lazy dict-like interface
   â””â”€â”€ ğŸ”§ states(self) (line 206)
       ğŸ’¬ Get all states with their hashes (lazy-loaded view into backend)
   â””â”€â”€ ğŸ”§ branches(self) (line 242)
       ğŸ’¬ Get current branches from backend (lazy-loaded view)
   â””â”€â”€ ğŸ”§ add_node(self, node_id) (line 254)
       ğŸ’¬ Add a node to the graph
   â””â”€â”€ ğŸ”§ add_edge(self, source, target) (line 283)
       ğŸ’¬ Add an edge to the graph
   â””â”€â”€ ğŸ”§ batch_operations(self) (line 329)
       ğŸ’¬ Context manager for efficient batch operations
   â””â”€â”€ ğŸ”§ node_count(self) (line 333)
       ğŸ’¬ Get the number of nodes
   â””â”€â”€ ğŸ”§ edge_count(self) (line 341)
       ğŸ’¬ Get the number of edges
   â””â”€â”€ ğŸ”§ get_node(self, node_id) (line 349)
       ğŸ’¬ Get a specific node by ID
   â””â”€â”€ ğŸ”§ get_edge(self, source, target) (line 361)
       ğŸ’¬ Get a specific edge by source and target node IDs
   â””â”€â”€ ğŸ”§ has_edge(self, source, target) (line 375)
       ğŸ’¬ Check if an edge exists between source and target nodes
   â””â”€â”€ ğŸ”§ has_node(self, node_id) (line 386)
       ğŸ’¬ Check if a node exists in the graph
   â””â”€â”€ ğŸ”§ is_directed(self) (line 395)
       ğŸ’¬ Check if the graph is directed
   â””â”€â”€ ğŸ”§ get_node_ids(self) (line 399)
       ğŸ’¬ Get all node IDs
   â””â”€â”€ ğŸ”§ node_id_to_index(self) (line 408)
       ğŸ’¬ Get node ID to internal index mapping for debugging (Python backend only)
   â””â”€â”€ ğŸ”§ get_neighbors(self, node_id, direction) (line 417)
       ğŸ’¬ Get neighbors of a node
   â””â”€â”€ ğŸ”§ get_outgoing_neighbors(self, node_id) (line 460)
       ğŸ’¬ Get outgoing neighbors of a node (for directed graphs)
   â””â”€â”€ ğŸ”§ get_incoming_neighbors(self, node_id) (line 475)
       ğŸ’¬ Get incoming neighbors of a node (for directed graphs)
   â””â”€â”€ ğŸ”§ get_all_neighbors(self, node_id) (line 490)
       ğŸ’¬ Get all neighbors of a node (both incoming and outgoing)
   â””â”€â”€ ğŸ”§ filter_nodes(self, filter_func, return_subgraph) (line 508)
       ğŸ’¬ Filter nodes by lambda function, attribute values, string query, or keyword arguments
   â””â”€â”€ ğŸ”§ filter_edges(self, filter_func, return_subgraph) (line 578)
       ğŸ’¬ Filter edges by lambda function, attribute values, string query, or keyword arguments
   â””â”€â”€ ğŸ”§ set_node_attribute(self, node_id, attribute, value) (line 647)
       ğŸ’¬ Set a single attribute on a node
   â””â”€â”€ ğŸ”§ set_edge_attribute(self, source, target, attribute, value) (line 668)
       ğŸ’¬ Set a single attribute on an edge
   â””â”€â”€ ğŸ”§ set_node_attributes(self, node_id, attributes) (line 692)
       ğŸ’¬ Set multiple attributes on a node
   â””â”€â”€ ğŸ”§ set_edge_attributes(self, source, target, attributes) (line 702)
       ğŸ’¬ Set multiple attributes on an edge
   â””â”€â”€ ğŸ”§ set_nodes_attributes_batch(self, node_attrs) (line 713)
       ğŸ’¬ Set attributes on multiple nodes efficiently
   â””â”€â”€ ğŸ”§ set_edges_attributes_batch(self, edge_attrs) (line 732)
       ğŸ’¬ Set attributes on multiple edges efficiently
   â””â”€â”€ ğŸ”§ get_node_attributes(self, node_id) (line 751)
       ğŸ’¬ Get all attributes of a node
   â””â”€â”€ ğŸ”§ get_edge_attributes(self, source, target) (line 766)
       ğŸ’¬ Get all attributes of an edge
   â””â”€â”€ ğŸ”§ get_nodes_attribute(self, node_ids, attr_name) (line 785)
       ğŸ’¬ Get a specific attribute for multiple nodes efficiently
   â””â”€â”€ ğŸ”§ get_nodes_attributes(self, node_ids) (line 808)
       ğŸ’¬ Get all attributes for multiple nodes efficiently
   â””â”€â”€ ğŸ”§ get_all_nodes_attribute(self, attr_name) (line 830)
       ğŸ’¬ Get a specific attribute for all nodes efficiently (useful for statistics)
   â””â”€â”€ ğŸ”§ get_edges_attribute(self, edge_endpoints, attr_name) (line 851)
       ğŸ’¬ Get a specific attribute for multiple edges efficiently
   â””â”€â”€ ğŸ”§ get_all_edges_attribute(self, attr_name) (line 874)
       ğŸ’¬ Get a specific attribute for all edges efficiently (useful for statistics)
   â””â”€â”€ ğŸ”§ get_edge_ids(self) (line 895)
       ğŸ’¬ Get all edge IDs in the graph
   â””â”€â”€ ğŸ”§ update_node(self, node_id, attributes) (line 909)
       ğŸ’¬ Update node attributes with a user-friendly interface
   â””â”€â”€ ğŸ”§ update_edge(self, source, target, attributes) (line 946)
       ğŸ’¬ Update edge attributes with a user-friendly interface
   â””â”€â”€ ğŸ”§ add_nodes(self, nodes_data) (line 986)
       ğŸ’¬ Add multiple nodes efficiently in a single operation
   â””â”€â”€ ğŸ”§ add_edges(self, edges_data) (line 1022)
       ğŸ’¬ Add multiple edges efficiently in a single operation
   â””â”€â”€ ğŸ”§ update_nodes(self, updates) (line 1068)
       ğŸ’¬ Update multiple nodes efficiently in a single operation
   â””â”€â”€ ğŸ”§ remove_node(self, node_id) (line 1113)
       ğŸ’¬ Remove a node from the graph
   â””â”€â”€ ğŸ”§ remove_edge(self, source, target) (line 1152)
       ğŸ’¬ Remove an edge from the graph
   â””â”€â”€ ğŸ”§ remove_nodes(self, node_ids) (line 1182)
       ğŸ’¬ Remove multiple nodes efficiently
   â””â”€â”€ ğŸ”§ remove_edges(self, edge_pairs) (line 1222)
       ğŸ’¬ Remove multiple edges efficiently
   â””â”€â”€ ğŸ”§ subgraph(self, node_ids, edge_ids, include_edges) (line 1254)
       ğŸ’¬ Create a single subgraph from specified nodes or edges
   â””â”€â”€ ğŸ”§ subgraphs(self, group_by) (line 1290)
       ğŸ’¬ Create multiple subgraphs grouped by attribute values
   â””â”€â”€ ğŸ”§ _filter_nodes_vectorized(self, filter_func) (line 1418)
       ğŸ’¬ Vectorized node filtering for better performance on large graphs.
   â””â”€â”€ ğŸ”§ _filter_edges_vectorized(self, filter_func) (line 1462)
       ğŸ’¬ Vectorized edge filtering for better performance on large graphs.
   â””â”€â”€ ğŸ”§ _filter_nodes_optimized(self, filter_func) (line 1506)
       ğŸ’¬ Highly optimized node filtering that detects filter patterns and applies
   â””â”€â”€ ğŸ”§ _filter_nodes_by_dict_vectorized(self, filter_dict) (line 1537)
       ğŸ’¬ Super-optimized filtering for dictionary-based filters.
   â””â”€â”€ ğŸ”§ _filter_edges_optimized(self, filter_func) (line 1619)
       ğŸ’¬ Highly optimized edge filtering that detects filter patterns and applies
   â””â”€â”€ ğŸ”§ _filter_edges_by_dict_vectorized(self, filter_dict) (line 1650)
       ğŸ’¬ Super-optimized filtering for dictionary-based edge filters.
   â””â”€â”€ ğŸ”§ _try_optimized_string_filter_nodes(self, query_str) (line 1732)
       ğŸ’¬ Try to optimize simple string queries using fast Rust backend operations.
   â””â”€â”€ ğŸ”§ _try_optimized_string_filter_edges(self, query_str) (line 1765)
       ğŸ’¬ Try to optimize simple string queries for edges using fast Rust backend operations.

============================================================
FILE: groggy/graph/subgraph.py
============================================================

ğŸ“ CLASS: Subgraph (line 11)
   ğŸ“ A Subgraph is a Graph with additional metadata about its origin.
   â””â”€â”€ ğŸ”§ __init__(self, parent_graph, filter_criteria, metadata) (line 21)
       ğŸ’¬ Initialize a Subgraph.
   â””â”€â”€ ğŸ”§ __repr__(self) (line 40)
       ğŸ’¬ String representation of the subgraph.
   â””â”€â”€ ğŸ”§ get_metadata(self) (line 47)
       ğŸ’¬ Get all metadata about this subgraph.

============================================================
FILE: groggy/graph/state.py
============================================================

ğŸ“ CLASS: StateMixin (line 8)
   ğŸ“ Mixin class providing state management functionality
   â””â”€â”€ ğŸ”§ save_state(self, message) (line 11)
       ğŸ’¬ Save the current graph state to storage
   â””â”€â”€ ğŸ”§ commit(self, message) (line 37)
       ğŸ’¬ Legacy alias for save_state
   â””â”€â”€ ğŸ”§ create_branch(self, branch_name, from_hash, switch) (line 41)
       ğŸ’¬ Create a new branch (delegated to Rust)
   â””â”€â”€ ğŸ”§ get_storage_stats(self) (line 51)
       ğŸ’¬ Get storage statistics (delegated to Rust)
   â””â”€â”€ ğŸ”§ load_state(self, state_hash) (line 58)
       ğŸ’¬ Load a previous state of the graph
   â””â”€â”€ ğŸ”§ get_state_info(self, state_hash) (line 87)
       ğŸ’¬ Get detailed information about a specific state or current state
   â””â”€â”€ ğŸ”§ switch_branch(self, branch_name) (line 115)
       ğŸ’¬ Switch to a different branch

============================================================
SUMMARY: Analyzed 10 files
============================================================