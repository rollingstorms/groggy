 CODE STRUCTURE ANALYSIS
Directory: ../groggy/python
Generated: py_structure_simple.txt
============================================================

============================================================
FILE: groggy/analysis.py
============================================================

⚙️  FUNCTION: show_changes(graph_or_entity, graph, branch_name) (line 20)
   📝 Analyze changes across saved states.

⚙️  FUNCTION: _show_graph_changes(graph, branch_name) (line 50)
   📝 Show all changes across states in a branch.

⚙️  FUNCTION: _show_entity_changes(entity_id, graph, branch_name) (line 98)
   📝 Show changes for a specific entity across states.

⚙️  FUNCTION: _get_saved_states(graph) (line 192)
   📝 Get list of saved states from the graph storage.

⚙️  FUNCTION: _analyze_state_diff(graph, prev_hash, curr_hash) (line 209)
   📝 Analyze differences between two states by loading and comparing them.

⚙️  FUNCTION: _empty_diff() (line 279)
   📝 Return an empty diff structure.

⚙️  FUNCTION: _compare_graph_states(prev_nodes, prev_edges, curr_nodes, curr_edges) (line 290)
   📝 Compare two graph states and return the differences.

⚙️  FUNCTION: _print_changes(changes) (line 328)
   📝 Print formatted change summary.

⚙️  FUNCTION: _print_entity_timeline(entity_id, timeline) (line 343)
   📝 Print formatted entity timeline.

⚙️  FUNCTION: show_entity_changes(entity_id, graph, branch_name) (line 379)
   📝 Convenience function for entity-specific analysis.

⚙️  FUNCTION: show_graph_changes(graph, branch_name) (line 383)
   📝 Convenience function for graph-wide analysis.

⚙️  FUNCTION: track_attribute_changes(graph, attribute_name, branch_name) (line 387)
   📝 Track changes to a specific attribute across all entities over time

============================================================
FILE: groggy/__init__.py
============================================================

⚙️  FUNCTION: get_available_backends() (line 31)
   📝 Get list of available backends.

⚙️  FUNCTION: set_backend(backend) (line 38)
   📝 Set the backend to use for new Graph instances.

⚙️  FUNCTION: get_current_backend() (line 45)
   📝 Get the currently selected backend.

============================================================
FILE: groggy/utils.py
============================================================

⚙️  FUNCTION: create_random_graph(n_nodes, edge_probability, use_rust) (line 10)
   📝 Create a random graph efficiently using vectorized operations

⚙️  FUNCTION: create_clustering_workflow(store, graph, algorithms) (line 25)
   📝 Create branches for different clustering algorithms

⚙️  FUNCTION: create_subgraph_branch(store, subgraph, branch_name, description) (line 42)
   📝 Create a branch from a subgraph for isolated processing

============================================================
FILE: groggy/data_structures.py
============================================================

📁 CLASS: Node (line 13)
   📝 Graph node with attributes
   └── 🔧 get_attribute(self, key, default) (line 18)
   └── 🔧 set_attribute(self, key, value) (line 21)
   └── 🔧 get(self, key, default) (line 27)
   └── 🔧 __getitem__(self, key) (line 30)
   └── 🔧 __setitem__(self, key, value) (line 33)
   └── 🔧 __contains__(self, key) (line 36)
   └── 🔧 keys(self) (line 39)
   └── 🔧 values(self) (line 42)
   └── 🔧 items(self) (line 45)
   └── 🔧 __iter__(self) (line 48)

📁 CLASS: Edge (line 53)
   📝 Graph edge with attributes
   └── 🔧 id(self) (line 60)
   └── 🔧 get_attribute(self, key, default) (line 63)
   └── 🔧 set_attribute(self, key, value) (line 66)
   └── 🔧 get(self, key, default) (line 72)
   └── 🔧 __getitem__(self, key) (line 75)
   └── 🔧 __setitem__(self, key, value) (line 78)
   └── 🔧 __contains__(self, key) (line 81)
   └── 🔧 keys(self) (line 84)
   └── 🔧 values(self) (line 87)
   └── 🔧 items(self) (line 90)
   └── 🔧 __iter__(self) (line 93)

📁 CLASS: GraphDelta (line 97)
   📝 Tracks changes to a graph for efficient updates
   └── 🔧 __init__(self) (line 100)
   └── 🔧 clear(self) (line 108)
       💬 Clear all delta information
   └── 🔧 is_empty(self) (line 117)
       💬 Check if delta has any changes

============================================================
FILE: groggy/views.py
============================================================

📁 CLASS: LazyDict (line 8)
   📝 Zero-copy dictionary view that combines base dict with delta changes
   └── 🔧 __init__(self, base_dict, delta_added, delta_removed, delta_modified) (line 11)
   └── 🔧 __getitem__(self, key) (line 18)
   └── 🔧 get(self, key, default) (line 27)
   └── 🔧 __contains__(self, key) (line 33)
   └── 🔧 keys(self) (line 38)
   └── 🔧 values(self) (line 43)
   └── 🔧 items(self) (line 46)
   └── 🔧 __len__(self) (line 49)
   └── 🔧 __iter__(self) (line 52)
   └── 🔧 copy(self) (line 55)
       💬 Force materialization to regular dict

📁 CLASS: NodeView (line 60)
   📝 View of nodes - works with both dict and Rust backend
   └── 🔧 __init__(self, data) (line 63)
   └── 🔧 __len__(self) (line 73)
   └── 🔧 __contains__(self, node_id) (line 79)
   └── 🔧 __getitem__(self, node_id) (line 89)
   └── 🔧 keys(self) (line 97)
   └── 🔧 __iter__(self) (line 103)
   └── 🔧 values(self) (line 106)
   └── 🔧 items(self) (line 112)
   └── 🔧 items_iter(self) (line 118)
       💬 Iterator version of items() for memory efficiency

📁 CLASS: EdgeView (line 126)
   📝 View of edges - works with both dict and Rust backend
   └── 🔧 __init__(self, data) (line 129)
   └── 🔧 __len__(self) (line 139)
   └── 🔧 __contains__(self, edge_id) (line 145)
   └── 🔧 __getitem__(self, edge_id) (line 159)
   └── 🔧 keys(self) (line 171)
   └── 🔧 __iter__(self) (line 177)
   └── 🔧 values(self) (line 180)
   └── 🔧 items(self) (line 186)
   └── 🔧 items_iter(self) (line 192)
       💬 Iterator version of items() for memory efficiency

============================================================
FILE: groggy/graph/filtering.py
============================================================

📁 CLASS: QueryCompiler (line 19)
   📝 Compiles string-based queries into executable filter functions.
   └── 🔧 compile_node_query(cls, query_str) (line 42)
       💬 Compile a string query into a function for node filtering.
   └── 🔧 compile_edge_query(cls, query_str) (line 58)
       💬 Compile a string query into a function for edge filtering.
   └── 🔧 _evaluate_query(cls, query_str, context) (line 81)
       💬 Evaluate a query string against a context dictionary.
   └── 🔧 _preprocess_logical_operators(cls, query_str) (line 110)
       💬 Normalize logical operators.
   └── 🔧 _split_logical_expression(cls, query_str) (line 119)
       💬 Split expression by logical operators while preserving them.
   └── 🔧 _evaluate_logical_expression(cls, parts, context) (line 138)
       💬 Evaluate a logical expression with multiple parts.
   └── 🔧 _evaluate_simple_expression(cls, expr, context) (line 160)
       💬 Evaluate a simple comparison expression.
   └── 🔧 _parse_literal(cls, value_str) (line 208)
       💬 Parse a literal value from a string.

📁 CLASS: SubgraphCreator (line 240)
   📝 Creates subgraphs from filtering operations.
   └── 🔧 create_node_subgraph(source_graph, node_ids, filter_criteria) (line 244)
       💬 Create a subgraph containing only the specified nodes and edges between them.
   └── 🔧 create_edge_subgraph(source_graph, edge_ids, filter_criteria) (line 282)
       💬 Create a subgraph containing only the specified edges and their connected nodes.

⚙️  FUNCTION: enhanced_filter_nodes(graph, filter_criteria, return_subgraph) (line 354)
   📝 Enhanced node filtering with optional subgraph creation.

⚙️  FUNCTION: enhanced_filter_edges(graph, filter_criteria, return_subgraph) (line 409)
   📝 Enhanced edge filtering with optional subgraph creation.

============================================================
FILE: groggy/graph/batch.py
============================================================

📁 CLASS: BatchOperationContext (line 12)
   📝 Context manager for efficient batch operations
   └── 🔧 __init__(self, graph) (line 15)
   └── 🔧 __enter__(self) (line 20)
   └── 🔧 __exit__(self, exc_type, exc_val, exc_tb) (line 23)
   └── 🔧 add_node(self, node_id) (line 27)
       💬 Queue node for batch addition
   └── 🔧 add_edge(self, source, target) (line 39)
       💬 Queue edge for batch addition
   └── 🔧 set_node_attributes(self, node_attr_dict) (line 53)
       💬 Queue bulk node attribute updates
   └── 🔧 set_edge_attributes(self, edge_attr_dict) (line 78)
       💬 Queue bulk edge attribute updates

============================================================
FILE: groggy/graph/core.py
============================================================

📁 CLASS: Graph (line 26)
   📝 High-level Graph interface with automatic Rust/Python backend selection
   └── 🔧 __init__(self, nodes, edges, graph_attributes, backend, max_auto_states, directed) (line 29)
   └── 🔧 _init_rust_backend(self, nodes, edges, graph_attributes) (line 73)
       💬 Initialize Rust backend
   └── 🔧 _init_python_backend(self, nodes, edges, graph_attributes) (line 83)
       💬 Initialize Python backend (fallback)
   └── 🔧 _invalidate_cache(self) (line 99)
       💬 Invalidate the cache when graph structure changes
   └── 🔧 empty(cls, backend) (line 110)
       💬 Create an empty graph
   └── 🔧 from_node_list(cls, node_ids, node_attrs, backend) (line 115)
       💬 Create graph from vectorized node data (NumPy-style)
   └── 🔧 from_edge_list(cls, edges, node_attrs, edge_attrs, backend) (line 132)
       💬 Create graph from edge list (NetworkX-style)
   └── 🔧 nodes(self) (line 169)
       💬 Access nodes as a lazy dict-like interface
   └── 🔧 edges(self) (line 186)
       💬 Access edges as a lazy dict-like interface
   └── 🔧 states(self) (line 206)
       💬 Get all states with their hashes (lazy-loaded view into backend)
   └── 🔧 branches(self) (line 242)
       💬 Get current branches from backend (lazy-loaded view)
   └── 🔧 add_node(self, node_id) (line 254)
       💬 Add a node to the graph
   └── 🔧 add_edge(self, source, target) (line 283)
       💬 Add an edge to the graph
   └── 🔧 batch_operations(self) (line 329)
       💬 Context manager for efficient batch operations
   └── 🔧 node_count(self) (line 333)
       💬 Get the number of nodes
   └── 🔧 edge_count(self) (line 341)
       💬 Get the number of edges
   └── 🔧 get_node(self, node_id) (line 349)
       💬 Get a specific node by ID
   └── 🔧 get_edge(self, source, target) (line 361)
       💬 Get a specific edge by source and target node IDs
   └── 🔧 has_edge(self, source, target) (line 375)
       💬 Check if an edge exists between source and target nodes
   └── 🔧 has_node(self, node_id) (line 386)
       💬 Check if a node exists in the graph
   └── 🔧 is_directed(self) (line 395)
       💬 Check if the graph is directed
   └── 🔧 get_node_ids(self) (line 399)
       💬 Get all node IDs
   └── 🔧 node_id_to_index(self) (line 408)
       💬 Get node ID to internal index mapping for debugging (Python backend only)
   └── 🔧 get_neighbors(self, node_id, direction) (line 417)
       💬 Get neighbors of a node
   └── 🔧 get_outgoing_neighbors(self, node_id) (line 460)
       💬 Get outgoing neighbors of a node (for directed graphs)
   └── 🔧 get_incoming_neighbors(self, node_id) (line 475)
       💬 Get incoming neighbors of a node (for directed graphs)
   └── 🔧 get_all_neighbors(self, node_id) (line 490)
       💬 Get all neighbors of a node (both incoming and outgoing)
   └── 🔧 filter_nodes(self, filter_func, return_subgraph) (line 508)
       💬 Filter nodes by lambda function, attribute values, string query, or keyword arguments
   └── 🔧 filter_edges(self, filter_func, return_subgraph) (line 578)
       💬 Filter edges by lambda function, attribute values, string query, or keyword arguments
   └── 🔧 set_node_attribute(self, node_id, attribute, value) (line 647)
       💬 Set a single attribute on a node
   └── 🔧 set_edge_attribute(self, source, target, attribute, value) (line 668)
       💬 Set a single attribute on an edge
   └── 🔧 set_node_attributes(self, node_id, attributes) (line 692)
       💬 Set multiple attributes on a node
   └── 🔧 set_edge_attributes(self, source, target, attributes) (line 702)
       💬 Set multiple attributes on an edge
   └── 🔧 set_nodes_attributes_batch(self, node_attrs) (line 713)
       💬 Set attributes on multiple nodes efficiently
   └── 🔧 set_edges_attributes_batch(self, edge_attrs) (line 732)
       💬 Set attributes on multiple edges efficiently
   └── 🔧 get_node_attributes(self, node_id) (line 751)
       💬 Get all attributes of a node
   └── 🔧 get_edge_attributes(self, source, target) (line 766)
       💬 Get all attributes of an edge
   └── 🔧 get_nodes_attribute(self, node_ids, attr_name) (line 785)
       💬 Get a specific attribute for multiple nodes efficiently
   └── 🔧 get_nodes_attributes(self, node_ids) (line 808)
       💬 Get all attributes for multiple nodes efficiently
   └── 🔧 get_all_nodes_attribute(self, attr_name) (line 830)
       💬 Get a specific attribute for all nodes efficiently (useful for statistics)
   └── 🔧 get_edges_attribute(self, edge_endpoints, attr_name) (line 851)
       💬 Get a specific attribute for multiple edges efficiently
   └── 🔧 get_all_edges_attribute(self, attr_name) (line 874)
       💬 Get a specific attribute for all edges efficiently (useful for statistics)
   └── 🔧 get_edge_ids(self) (line 895)
       💬 Get all edge IDs in the graph
   └── 🔧 update_node(self, node_id, attributes) (line 909)
       💬 Update node attributes with a user-friendly interface
   └── 🔧 update_edge(self, source, target, attributes) (line 946)
       💬 Update edge attributes with a user-friendly interface
   └── 🔧 add_nodes(self, nodes_data) (line 986)
       💬 Add multiple nodes efficiently in a single operation
   └── 🔧 add_edges(self, edges_data) (line 1022)
       💬 Add multiple edges efficiently in a single operation
   └── 🔧 update_nodes(self, updates) (line 1068)
       💬 Update multiple nodes efficiently in a single operation
   └── 🔧 remove_node(self, node_id) (line 1113)
       💬 Remove a node from the graph
   └── 🔧 remove_edge(self, source, target) (line 1152)
       💬 Remove an edge from the graph
   └── 🔧 remove_nodes(self, node_ids) (line 1182)
       💬 Remove multiple nodes efficiently
   └── 🔧 remove_edges(self, edge_pairs) (line 1222)
       💬 Remove multiple edges efficiently
   └── 🔧 subgraph(self, node_ids, edge_ids, include_edges) (line 1254)
       💬 Create a single subgraph from specified nodes or edges
   └── 🔧 subgraphs(self, group_by) (line 1290)
       💬 Create multiple subgraphs grouped by attribute values
   └── 🔧 _filter_nodes_vectorized(self, filter_func) (line 1418)
       💬 Vectorized node filtering for better performance on large graphs.
   └── 🔧 _filter_edges_vectorized(self, filter_func) (line 1462)
       💬 Vectorized edge filtering for better performance on large graphs.
   └── 🔧 _filter_nodes_optimized(self, filter_func) (line 1506)
       💬 Highly optimized node filtering that detects filter patterns and applies
   └── 🔧 _filter_nodes_by_dict_vectorized(self, filter_dict) (line 1537)
       💬 Super-optimized filtering for dictionary-based filters.
   └── 🔧 _filter_edges_optimized(self, filter_func) (line 1619)
       💬 Highly optimized edge filtering that detects filter patterns and applies
   └── 🔧 _filter_edges_by_dict_vectorized(self, filter_dict) (line 1650)
       💬 Super-optimized filtering for dictionary-based edge filters.
   └── 🔧 _try_optimized_string_filter_nodes(self, query_str) (line 1732)
       💬 Try to optimize simple string queries using fast Rust backend operations.
   └── 🔧 _try_optimized_string_filter_edges(self, query_str) (line 1765)
       💬 Try to optimize simple string queries for edges using fast Rust backend operations.

============================================================
FILE: groggy/graph/subgraph.py
============================================================

📁 CLASS: Subgraph (line 11)
   📝 A Subgraph is a Graph with additional metadata about its origin.
   └── 🔧 __init__(self, parent_graph, filter_criteria, metadata) (line 21)
       💬 Initialize a Subgraph.
   └── 🔧 __repr__(self) (line 40)
       💬 String representation of the subgraph.
   └── 🔧 get_metadata(self) (line 47)
       💬 Get all metadata about this subgraph.

============================================================
FILE: groggy/graph/state.py
============================================================

📁 CLASS: StateMixin (line 8)
   📝 Mixin class providing state management functionality
   └── 🔧 save_state(self, message) (line 11)
       💬 Save the current graph state to storage
   └── 🔧 commit(self, message) (line 37)
       💬 Legacy alias for save_state
   └── 🔧 create_branch(self, branch_name, from_hash, switch) (line 41)
       💬 Create a new branch (delegated to Rust)
   └── 🔧 get_storage_stats(self) (line 51)
       💬 Get storage statistics (delegated to Rust)
   └── 🔧 load_state(self, state_hash) (line 58)
       💬 Load a previous state of the graph
   └── 🔧 get_state_info(self, state_hash) (line 87)
       💬 Get detailed information about a specific state or current state
   └── 🔧 switch_branch(self, branch_name) (line 115)
       💬 Switch to a different branch

============================================================
SUMMARY: Analyzed 10 files
============================================================