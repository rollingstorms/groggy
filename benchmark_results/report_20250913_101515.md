# NumArray Performance Report

**Timestamp**: Sat Sep 13 10:15:43 EDT 2025
**Git Commit**: 59d271b80750eadd96a2b5d960a185b8ff2fc973
**Git Branch**: develop

## Benchmark Results

```
[1;33mRunning benchmarks in quick mode...[0m
warning: unused import: `task::JoinHandle`
  --> src/core/streaming/websocket_server.rs:15:21
   |
15 | use tokio::{select, task::JoinHandle};
   |                     ^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `accept_async`
  --> src/core/streaming/websocket_server.rs:16:25
   |
16 | use tokio_tungstenite::{accept_async, tungstenite::Message};
   |                         ^^^^^^^^^^^^

warning: unused import: `AttrValue`
 --> src/subgraphs/composer.rs:8:30
  |
8 | use crate::types::{AttrName, AttrValue, NodeId};
  |                              ^^^^^^^^^

warning: unused import: `AttrName`
   --> src/subgraphs/composer.rs:316:39
    |
316 |         use crate::types::{AttrValue, AttrName};
    |                                       ^^^^^^^^

warning: unused import: `AttrName`
   --> src/subgraphs/composer.rs:441:39
    |
441 |         use crate::types::{AttrValue, AttrName};
    |                                       ^^^^^^^^

warning: unused import: `SocketAddr`
    --> src/storage/table/base.rs:2133:41
     |
2133 |             use std::net::{TcpListener, SocketAddr};
     |                                         ^^^^^^^^^^

warning: unused import: `LazyArrayIterator`
 --> src/storage/array/benchmark.rs:6:54
  |
6 | use crate::storage::array::{ArrayOps, ArrayIterator, LazyArrayIterator};
  |                                                      ^^^^^^^^^^^^^^^^^

warning: unused import: `std::time::Instant`
 --> src/storage/array/memory_profiler.rs:6:5
  |
6 | use std::time::Instant;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `GraphError`
 --> src/storage/array/query.rs:5:34
  |
5 | use crate::errors::{GraphResult, GraphError};
  |                                  ^^^^^^^^^^

warning: unused import: `base::*`
  --> src/storage/array/mod.rs:31:9
   |
31 | pub use base::*;
   |         ^^^^^^^

warning: unnecessary parentheses around `if` condition
   --> src/storage/pool.rs:789:16
    |
789 |             if (*edge_source == node_id || *edge_target == node_id) {
    |                ^                                                  ^
    |
    = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
    |
789 -             if (*edge_source == node_id || *edge_target == node_id) {
789 +             if *edge_source == node_id || *edge_target == node_id {
    |

warning: ambiguous glob re-exports
  --> src/storage/mod.rs:21:9
   |
21 | pub use table::*;        // Table system
   |         ^^^^^^^^ the name `traits` in the type namespace is first re-exported here
22 | pub use array::*;        // Array system
   |         -------- but the name `traits` in the type namespace is also re-exported here
   |
   = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: ambiguous glob re-exports
  --> src/storage/mod.rs:21:9
   |
21 | pub use table::*;        // Table system
   |         ^^^^^^^^ the name `base` in the type namespace is first re-exported here
22 | pub use array::*;        // Array system
   |         -------- but the name `base` in the type namespace is also re-exported here

warning: ambiguous glob re-exports
  --> src/state/mod.rs:18:9
   |
18 | pub use state::*;
   |         ^^^^^^^^ the name `AttributeChange` in the type namespace is first re-exported here
19 | pub use history::*;
   |         ---------- but the name `AttributeChange` in the type namespace is also re-exported here

warning: ambiguous glob re-exports
  --> src/state/mod.rs:18:9
   |
18 | pub use state::*;
   |         ^^^^^^^^ the name `EntityType` in the type namespace is first re-exported here
19 | pub use history::*;
   |         ---------- but the name `EntityType` in the type namespace is also re-exported here

warning: unused imports: `ComposerPreview`, `EdgeAggregation`, and `NodeAggregation`
  --> src/traits/subgraph_operations.rs:10:48
   |
10 | use crate::subgraphs::composer::{MetaNodePlan, NodeAggregation, EdgeAggregation, EdgeStrategy, ComposerPreview};
   |                                                ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^                ^^^^^^^^^^^^^^^

warning: unused import: `EdgeConfig`
    --> src/api/graph.rs:2631:60
     |
2631 |         use crate::storage::table::{BaseTable, EdgesTable, EdgeConfig};
     |                                                            ^^^^^^^^^^

warning: variable does not need to be mutable
   --> src/core/streaming/websocket_server.rs:145:49
    |
145 |     async fn handle_connection_with_port(&self, mut stream: TcpStream, addr: SocketAddr, server_port: u16) -> StreamingResult<()> {
    |                                                 ----^^^^^^
    |                                                 |
    |                                                 help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `update`
   --> src/core/streaming/websocket_server.rs:736:42
    |
736 |     pub async fn broadcast_update(&self, update: DataUpdate) -> StreamingResult<()> {
    |                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_update`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused import: `ArrayOps`
 --> src/storage/table/graph_table.rs:7:40
  |
7 | use crate::storage::array::{BaseArray, ArrayOps};
  |                                        ^^^^^^^^

warning: unused import: `AsyncWriteExt`
   --> src/core/streaming/websocket_server.rs:146:39
    |
146 |         use tokio::io::{AsyncReadExt, AsyncWriteExt};
    |                                       ^^^^^^^^^^^^^

warning: unused import: `AsyncReadExt`
   --> src/core/streaming/websocket_server.rs:146:25
    |
146 |         use tokio::io::{AsyncReadExt, AsyncWriteExt};
    |                         ^^^^^^^^^^^^

warning: unused import: `ArrayOps`
 --> src/storage/table/base.rs:4:40
  |
4 | use crate::storage::array::{BaseArray, ArrayOps};
  |                                        ^^^^^^^^

warning: unused import: `std::io::Write`
    --> src/storage/table/base.rs:1020:13
     |
1020 |         use std::io::Write;
     |             ^^^^^^^^^^^^^^

warning: unused import: `ArrayOps`
 --> src/storage/table/nodes.rs:5:40
  |
5 | use crate::storage::array::{BaseArray, ArrayOps};
  |                                        ^^^^^^^^

warning: unused import: `ArrayOps`
 --> src/storage/table/edges.rs:5:40
  |
5 | use crate::storage::array::{BaseArray, ArrayOps};
  |                                        ^^^^^^^^

warning: unused variable: `i`
   --> src/core/display/html.rs:267:14
    |
267 |         for (i, &ch) in chars.iter().rev().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `common_agg_patterns`
   --> src/subgraphs/hierarchical.rs:308:13
    |
308 |         let common_agg_patterns = vec![
    |             ^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_common_agg_patterns`

warning: unused variable: `graph`
   --> src/storage/matrix.rs:136:9
    |
136 |         graph: std::rc::Rc<crate::api::graph::Graph>,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_graph`

warning: unused variable: `attrs`
   --> src/storage/matrix.rs:137:9
    |
137 |         attrs: &[&str],
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_attrs`

warning: unused variable: `entities`
   --> src/storage/matrix.rs:138:9
    |
138 |         entities: &[NodeId],
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_entities`

warning: unused variable: `zero_value`
   --> src/storage/matrix.rs:148:13
    |
148 |         let zero_value = match dtype {
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_zero_value`

warning: unused variable: `column_name`
   --> src/storage/matrix.rs:732:17
    |
732 |             let column_name = format!("col_{}", col_idx);
    |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_column_name`

warning: unused variable: `column_name`
   --> src/storage/matrix.rs:834:17
    |
834 |             let column_name = format!("col_{}", col_idx);
    |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_column_name`

warning: unused variable: `dtype`
   --> src/storage/table/base.rs:248:17
    |
248 |             let dtype = values.iter()
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_dtype`

warning: unused variable: `dtype`
   --> src/storage/table/base.rs:292:13
    |
292 |         let dtype = values.iter()
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_dtype`

warning: unused variable: `predicate`
   --> src/storage/table/edges.rs:169:13
    |
169 |         let predicate = format!("source IN [{}]", source_strings.join(", "));
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_predicate`

warning: unused variable: `merged_policy`
   --> src/storage/table/graph_table.rs:374:17
    |
374 |         let mut merged_policy = tables[0].policy.clone();
    |                 ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_merged_policy`

warning: variable does not need to be mutable
   --> src/storage/table/graph_table.rs:374:13
    |
374 |         let mut merged_policy = tables[0].policy.clone();
    |             ----^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `merged_policy`
   --> src/storage/table/graph_table.rs:528:13
    |
528 |         let merged_policy = tables[0].policy.clone();
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_merged_policy`

warning: unused variable: `node_id`
   --> src/storage/table/graph_table.rs:655:18
    |
655 |             for &node_id in &node_ids {
    |                  ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_node_id`

warning: unused variable: `domain`
   --> src/storage/table/graph_table.rs:652:39
    |
652 |     fn add_domain_metadata(&mut self, domain: &str) -> GraphResult<()> {
    |                                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_domain`

warning: unused variable: `graph_ref`
   --> src/storage/array/iterator.rs:183:21
    |
183 |         if let Some(graph_ref) = &self.graph_ref {
    |                     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_graph_ref`

warning: unused variable: `graph_ref`
   --> src/storage/array/iterator.rs:280:21
    |
280 |         if let Some(graph_ref) = &self.graph_ref {
    |                     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_graph_ref`

warning: variable does not need to be mutable
   --> src/storage/array/lazy_iterator.rs:317:9
    |
317 |         mut elements: Vec<T>, 
    |         ----^^^^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `evaluator`
   --> src/storage/array/lazy_iterator.rs:373:17
    |
373 |             let evaluator = crate::storage::array::BatchQueryEvaluator::new(query);
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_evaluator`

warning: variable does not need to be mutable
   --> src/storage/array/lazy_iterator.rs:449:21
    |
449 |     pub fn collapse(mut self, aggs: HashMap<String, String>) -> LazyArrayIterator<()> {
    |                     ----^^^^
    |                     |
    |                     help: remove this `mut`

warning: unused variable: `array`
   --> src/storage/array/benchmark.rs:223:13
    |
223 |         let array = TestArray::new(data.to_vec());
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_array`

warning: unused variable: `agg_functions`
  --> src/traits/meta_operations.rs:86:28
   |
86 |     fn re_aggregate(&self, agg_functions: HashMap<AttrName, String>) -> GraphResult<()> {
   |                            ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_agg_functions`

warning: unused variable: `node_id`
   --> src/api/graph.rs:242:25
    |
242 |                     let node_id = node_id as crate::types::NodeId;
    |                         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_node_id`

warning: field `actual_port` is never read
  --> src/core/streaming/websocket_server.rs:39:5
   |
25 | pub struct StreamingServer {
   |            --------------- field in this struct
...
39 |     actual_port: Option<u16>,
   |     ^^^^^^^^^^^
   |
   = note: `StreamingServer` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: methods `handle_connection` and `generate_interactive_html` are never used
   --> src/core/streaming/websocket_server.rs:201:14
    |
42  | impl StreamingServer {
    | -------------------- methods in this implementation
...
201 |     async fn handle_connection(&self, stream: TcpStream, addr: SocketAddr) -> StreamingResult<()> {
    |              ^^^^^^^^^^^^^^^^^
...
385 |     async fn generate_interactive_html(&self) -> StreamingResult<String> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: method `convert_to_agg_functions` is never used
   --> src/subgraphs/composer.rs:580:8
    |
302 | impl MetaNodePlan {
    | ----------------- method in this implementation
...
580 |     fn convert_to_agg_functions(&self) -> HashMap<AttrName, String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^

warning: field `streaming_server` is never read
  --> src/storage/table/base.rs:25:5
   |
15 | pub struct BaseTable {
   |            --------- field in this struct
...
25 |     streaming_server: Option<StreamingServer>,
   |     ^^^^^^^^^^^^^^^^
   |
   = note: `BaseTable` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `name` is never read
   --> src/storage/array/specialized.rs:100:5
    |
94  | pub struct EdgesArray {
    |            ---------- field in this struct
...
100 |     name: Option<String>,
    |     ^^^^

warning: field `name` is never read
   --> src/storage/array/specialized.rs:164:5
    |
158 | pub struct MetaNodeArray {
    |            ------------- field in this struct
...
164 |     name: Option<String>,
    |     ^^^^

warning: `groggy` (lib) generated 56 warnings (run `cargo fix --lib -p groggy` to apply 17 suggestions)
    Finished `release` profile [optimized] target(s) in 0.20s
     Running `target/release/numarray_benchmark_runner --quick`
🚀 NumArray Performance Benchmark Runner
==========================================
Running quick benchmark...

🚀 Starting NumArray Performance Benchmark Suite
Sizes: [1000, 10000], Iterations: 20

📊 Testing array size: 1000
  ✓ Statistical operations benchmarked
  ✓ Element-wise operations benchmarked
  ✓ Allocation operations benchmarked
  ✓ Iterator operations benchmarked

📊 Testing array size: 10000
  ✓ Statistical operations benchmarked
  ✓ Element-wise operations benchmarked
  ✓ Allocation operations benchmarked
  ✓ Iterator operations benchmarked

🔍 Running baseline comparisons...

✅ Benchmark suite completed!

================================================================================
📊 NUMARRAY PERFORMANCE BENCHMARK RESULTS
================================================================================
Configuration:
  • Array sizes: [1000, 10000]
  • Iterations per test: 20
  • Memory measurement: true

------------------------------------------------------------
🔧 Operation: ELEMENT_ACCESS
------------------------------------------------------------
  Size:     1000 | Time:    18.00ns | Throughput:  55555555556 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    18.00ns | Throughput: 555555555556 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: CREATION_FROM_VEC
------------------------------------------------------------
  Size:     1000 | Time:   177.00ns | Throughput:   5649717514 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:     1.46µs | Throughput:   6858710562 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: COLLECT_TO_VEC
------------------------------------------------------------
  Size:     1000 | Time:    20.00ns | Throughput:  50000000000 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:   114.00ns | Throughput:  87719298246 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: MEAN
------------------------------------------------------------
  Size:     1000 | Time:    25.00ns | Throughput:  40000000000 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    16.00ns | Throughput: 625000000000 elem/sec | Memory: 80008 bytes
  🚀 1.02x faster than naive implementation

------------------------------------------------------------
🔧 Operation: STD_DEV
------------------------------------------------------------
  Size:     1000 | Time:    25.00ns | Throughput:  40000000000 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    22.00ns | Throughput: 454545454545 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: MAX
------------------------------------------------------------
  Size:     1000 | Time:    20.00ns | Throughput:  50000000000 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    16.00ns | Throughput: 625000000000 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: MAP
------------------------------------------------------------
  Size:     1000 | Time:    12.00ns | Throughput:  83333333333 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    25.00ns | Throughput: 400000000000 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: SUM
------------------------------------------------------------
  Size:     1000 | Time:    25.00ns | Throughput:  40000000000 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    16.00ns | Throughput: 625000000000 elem/sec | Memory: 80008 bytes
  🚀 infx faster than naive implementation

------------------------------------------------------------
🔧 Operation: MIN
------------------------------------------------------------
  Size:     1000 | Time:    25.00ns | Throughput:  40000000000 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    18.00ns | Throughput: 555555555556 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: CLONE
------------------------------------------------------------
  Size:     1000 | Time:    27.00ns | Throughput:  37037037037 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    31.00ns | Throughput: 322580645161 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: FILTER
------------------------------------------------------------
  Size:     1000 | Time:     1.24µs | Throughput:    809716599 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    12.17µs | Throughput:    821962847 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: ITERATION
------------------------------------------------------------
  Size:     1000 | Time:    18.00ns | Throughput:  55555555556 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:    22.00ns | Throughput: 454545454545 elem/sec | Memory: 80008 bytes

------------------------------------------------------------
🔧 Operation: MEDIAN
------------------------------------------------------------
  Size:     1000 | Time:    16.39µs | Throughput:     61023982 elem/sec | Memory: 8008 bytes
  Size:    10000 | Time:   113.77µs | Throughput:     87895088 elem/sec | Memory: 80008 bytes

================================================================================
🎯 PERFORMANCE ANALYSIS
================================================================================
⚠️  Slowest operation: median (113.77µs for 10K elements)
⚡ Fastest operation: mean (16.00ns for 10K elements)

💡 RECOMMENDATIONS:
  • element_access shows good scaling characteristics
  • collect_to_vec shows good scaling characteristics
  • mean shows good scaling characteristics
  • std_dev shows good scaling characteristics
  • max shows good scaling characteristics
  • map shows good scaling characteristics
  • sum shows good scaling characteristics
  • min shows good scaling characteristics
  • clone shows good scaling characteristics
  • iteration shows good scaling characteristics
  • median shows good scaling characteristics
================================================================================

✅ Benchmark completed successfully!
```

## Memory Analysis

```
[1;33mRunning memory analysis...[0m
warning: unused import: `NumArray`
 --> test_memory_analysis.rs:1:53
  |
1 | use groggy::storage::array::{quick_memory_analysis, NumArray};
  |                                                     ^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: 1 warning emitted

🧠 Memory Analysis Results:

--- Array Size: 100 ---
🔍 Profiling memory usage for NumArray operations (size: 100)

======================================================================
🧠 NUMARRAY MEMORY USAGE ANALYSIS
======================================================================
Array size: 100 elements (800 bytes)

----------------------------------------------------------------------
Operation             Peak Memory  Overhead%  Allocations Efficiency
----------------------------------------------------------------------
array_creation                0 B    -100.0%            0      1.000
sum_calculation               0 B    -100.0%            0      1.000
mean_calculation              0 B    -100.0%            0      1.000
std_dev_calculation           0 B    -100.0%            0      1.000
median_calculation            0 B    -100.0%            0      1.000
array_cloning                 0 B    -100.0%            0      1.000
array_iteration               0 B    -100.0%            0      1.000

🎯 OPTIMIZATION OPPORTUNITIES:
  ✅ Memory usage patterns look efficient!
======================================================================

--- Array Size: 1000 ---
🔍 Profiling memory usage for NumArray operations (size: 1000)

======================================================================
🧠 NUMARRAY MEMORY USAGE ANALYSIS
======================================================================
Array size: 1000 elements (8000 bytes)

----------------------------------------------------------------------
Operation             Peak Memory  Overhead%  Allocations Efficiency
----------------------------------------------------------------------
array_creation                0 B    -100.0%            0      1.000
sum_calculation               0 B    -100.0%            0      1.000
mean_calculation              0 B    -100.0%            0      1.000
std_dev_calculation           0 B    -100.0%            0      1.000
median_calculation            0 B    -100.0%            0      1.000
array_cloning                 0 B    -100.0%            0      1.000
array_iteration               0 B    -100.0%            0      1.000

🎯 OPTIMIZATION OPPORTUNITIES:
  ✅ Memory usage patterns look efficient!
======================================================================

--- Array Size: 10000 ---
🔍 Profiling memory usage for NumArray operations (size: 10000)

======================================================================
🧠 NUMARRAY MEMORY USAGE ANALYSIS
======================================================================
Array size: 10000 elements (80000 bytes)

----------------------------------------------------------------------
Operation             Peak Memory  Overhead%  Allocations Efficiency
----------------------------------------------------------------------
array_creation                0 B    -100.0%            0      1.000
sum_calculation               0 B    -100.0%            0      1.000
mean_calculation              0 B    -100.0%            0      1.000
std_dev_calculation           0 B    -100.0%            0      1.000
median_calculation            0 B    -100.0%            0      1.000
array_cloning                 0 B    -100.0%            0      1.000
array_iteration               0 B    -100.0%            0      1.000

🎯 OPTIMIZATION OPPORTUNITIES:
  ✅ Memory usage patterns look efficient!
======================================================================
```

## Performance Summary

- Report generated successfully
- Full benchmark suite completed
- Memory analysis completed
- Results stored in: benchmark_results/benchmark_20250913_101515.json

