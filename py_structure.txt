CODE STRUCTURE ANALYSIS
Directory: ../groggy/python
Generated: py_structure.txt
============================================================

============================================================
FILE: groggy/analysis.py
============================================================

âš™ï¸  FUNCTION: show_changes(graph_or_entity, graph, branch_name) (line 20)
   ğŸ“ Calls: â”Œâ”€ ValueError, _show_entity_changes, _show_graph_changes
          â”‚  hasattr, isinstance
          â””â”€
   ğŸ“ Analyze changes across saved states.

âš™ï¸  FUNCTION: _show_graph_changes(graph, branch_name) (line 50)
   ğŸ“ Calls: â”Œâ”€ _analyze_state_diff, _get_saved_states, _print_changes
          â”‚  branches.keys, enumerate, graph.switch_branch, hasattr
          â”‚  len, list, metadata.get, print, state_info.get
          â””â”€
   ğŸ“ Show all changes across states in a branch.

âš™ï¸  FUNCTION: _show_entity_changes(entity_id, graph, branch_name) (line 98)
   ğŸ“ Calls: â”Œâ”€ _get_saved_states, _print_entity_timeline, branches.keys
          â”‚  dict, entity_timeline.append, enumerate, graph.load_state
          â”‚  graph.switch_branch, hasattr, list, print, str
          â””â”€
   ğŸ“ Show changes for a specific entity across states.

âš™ï¸  FUNCTION: _get_saved_states(graph) (line 192)
   ğŸ“ Calls: â”Œâ”€ *.isoformat, datetime.now, enumerate, hasattr
          â”‚  states.append
          â””â”€
   ğŸ“ Get list of saved states from the graph storage.

âš™ï¸  FUNCTION: _analyze_state_diff(graph, prev_hash, curr_hash) (line 209)
   ğŸ“ Calls: â”Œâ”€ _compare_graph_states, _empty_diff, dict
          â”‚  graph.load_state, hasattr, print
          â””â”€
   ğŸ“ Analyze differences between two states by loading and comparing them.

âš™ï¸  FUNCTION: _empty_diff() (line 279)
   ğŸ“ Return an empty diff structure.

âš™ï¸  FUNCTION: _compare_graph_states(prev_nodes, prev_edges, curr_nodes, curr_edges) (line 290)
   ğŸ“ Calls: â”Œâ”€ curr_edges.keys, curr_nodes.keys, edges_modified.append
          â”‚  list, nodes_modified.append, prev_edges.keys
          â”‚  prev_nodes.keys, set, sorted
          â””â”€
   ğŸ“ Compare two graph states and return the differences.

âš™ï¸  FUNCTION: _print_changes(changes) (line 328)
   ğŸ“ Calls: â”Œâ”€ *.title, change_type.replace, changes.items
          â”‚  changes.values, isinstance, len, print, sum
          â””â”€
   ğŸ“ Print formatted change summary.

âš™ï¸  FUNCTION: _print_entity_timeline(entity_id, timeline) (line 343)
   ğŸ“ Calls: *.get, enumerate, print
   ğŸ“ Print formatted entity timeline.

âš™ï¸  FUNCTION: show_entity_changes(entity_id, graph, branch_name) (line 379)
   ğŸ“ Calls: show_changes
   ğŸ“ Convenience function for entity-specific analysis.

âš™ï¸  FUNCTION: show_graph_changes(graph, branch_name) (line 383)
   ğŸ“ Calls: show_changes
   ğŸ“ Convenience function for graph-wide analysis.

âš™ï¸  FUNCTION: track_attribute_changes(graph, attribute_name, branch_name) (line 387)
   ğŸ“ Calls: â”Œâ”€ *.append, _get_saved_states, attribute_timeline.items
          â”‚  entities_with_attr.items, enumerate, graph.load_state
          â”‚  graph.switch_branch, hasattr, len, print, set, str
          â””â”€
   ğŸ“ Track changes to a specific attribute across all entities over time

============================================================
FILE: groggy/__init__.py
============================================================

âš™ï¸  FUNCTION: get_available_backends() (line 31)
   ğŸ“ Calls: backends.append
   ğŸ“ Get list of available backends.

âš™ï¸  FUNCTION: set_backend(backend) (line 38)
   ğŸ“ Calls: ValueError, get_available_backends
   ğŸ“ Set the backend to use for new Graph instances.

âš™ï¸  FUNCTION: get_current_backend() (line 45)
   ğŸ“ Get the currently selected backend.

============================================================
FILE: groggy/utils.py
============================================================

âš™ï¸  FUNCTION: create_random_graph(n_nodes, edge_probability, use_rust) (line 10)
   ğŸ“ Calls: Graph.from_edge_list, edges.append, random.random, range
   ğŸ“ Create a random graph efficiently using vectorized operations

âš™ï¸  FUNCTION: create_clustering_workflow(store, graph, algorithms) (line 25)
   ğŸ“ Calls: branches.append, store.create_branch
   ğŸ“ Create branches for different clustering algorithms

âš™ï¸  FUNCTION: create_subgraph_branch(store, subgraph, branch_name, description) (line 42)
   ğŸ“ Calls: store.create_branch
   ğŸ“ Create a branch from a subgraph for isolated processing

============================================================
FILE: groggy/data_structures.py
============================================================

ğŸ“ CLASS: Node (line 13)
   ğŸ“ Graph node with attributes
   â””â”€â”€ ğŸ”§ get_attribute(self, key, default) (line 18)
       ğŸ“ Calls: *.get
   â””â”€â”€ ğŸ”§ set_attribute(self, key, value) (line 21)
       ğŸ“ Calls: *.copy, Node
   â””â”€â”€ ğŸ”§ get(self, key, default) (line 27)
       ğŸ“ Calls: *.get
   â””â”€â”€ ğŸ”§ __getitem__(self, key) (line 30)
   â””â”€â”€ ğŸ”§ __setitem__(self, key, value) (line 33)
   â””â”€â”€ ğŸ”§ __contains__(self, key) (line 36)
   â””â”€â”€ ğŸ”§ keys(self) (line 39)
       ğŸ“ Calls: *.keys
   â””â”€â”€ ğŸ”§ values(self) (line 42)
       ğŸ“ Calls: *.values
   â””â”€â”€ ğŸ”§ items(self) (line 45)
       ğŸ“ Calls: *.items
   â””â”€â”€ ğŸ”§ __iter__(self) (line 48)
       ğŸ“ Calls: iter

ğŸ“ CLASS: Edge (line 53)
   ğŸ“ Graph edge with attributes
   â””â”€â”€ ğŸ”§ id(self) (line 60)
   â””â”€â”€ ğŸ”§ get_attribute(self, key, default) (line 63)
       ğŸ“ Calls: *.get
   â””â”€â”€ ğŸ”§ set_attribute(self, key, value) (line 66)
       ğŸ“ Calls: *.copy, Edge
   â””â”€â”€ ğŸ”§ get(self, key, default) (line 72)
       ğŸ“ Calls: *.get
   â””â”€â”€ ğŸ”§ __getitem__(self, key) (line 75)
   â””â”€â”€ ğŸ”§ __setitem__(self, key, value) (line 78)
   â””â”€â”€ ğŸ”§ __contains__(self, key) (line 81)
   â””â”€â”€ ğŸ”§ keys(self) (line 84)
       ğŸ“ Calls: *.keys
   â””â”€â”€ ğŸ”§ values(self) (line 87)
       ğŸ“ Calls: *.values
   â””â”€â”€ ğŸ”§ items(self) (line 90)
       ğŸ“ Calls: *.items
   â””â”€â”€ ğŸ”§ __iter__(self) (line 93)
       ğŸ“ Calls: iter

ğŸ“ CLASS: GraphDelta (line 97)
   ğŸ“ Tracks changes to a graph for efficient updates
   â””â”€â”€ ğŸ”§ __init__(self) (line 100)
       ğŸ“ Calls: set
   â””â”€â”€ ğŸ”§ clear(self) (line 108)
       ğŸ“ Calls: *.clear
       ğŸ’¬ Clear all delta information
   â””â”€â”€ ğŸ”§ is_empty(self) (line 117)
       ğŸ’¬ Check if delta has any changes

============================================================
FILE: groggy/views.py
============================================================

ğŸ“ CLASS: LazyDict (line 8)
   ğŸ“ Zero-copy dictionary view that combines base dict with delta changes
   â””â”€â”€ ğŸ”§ __init__(self, base_dict, delta_added, delta_removed, delta_modified) (line 11)
       ğŸ“ Calls: set
   â””â”€â”€ ğŸ”§ __getitem__(self, key) (line 18)
       ğŸ“ Calls: KeyError
   â””â”€â”€ ğŸ”§ get(self, key, default) (line 27)
   â””â”€â”€ ğŸ”§ __contains__(self, key) (line 33)
   â””â”€â”€ ğŸ”§ keys(self) (line 38)
       ğŸ“ Calls: *.keys, set
   â””â”€â”€ ğŸ”§ values(self) (line 43)
       ğŸ“ Calls: self.keys
   â””â”€â”€ ğŸ”§ items(self) (line 46)
       ğŸ“ Calls: self.keys
   â””â”€â”€ ğŸ”§ __len__(self) (line 49)
       ğŸ“ Calls: len, self.keys
   â””â”€â”€ ğŸ”§ __iter__(self) (line 52)
       ğŸ“ Calls: iter, self.keys
   â””â”€â”€ ğŸ”§ copy(self) (line 55)
       ğŸ“ Calls: self.keys
       ğŸ’¬ Force materialization to regular dict

ğŸ“ CLASS: NodeView (line 60)
   ğŸ“ View of nodes - works with both dict and Rust backend
   â””â”€â”€ ğŸ”§ __init__(self, data) (line 63)
       ğŸ“ Calls: isinstance
   â””â”€â”€ ğŸ”§ __len__(self) (line 73)
       ğŸ“ Calls: *.node_count, len
   â””â”€â”€ ğŸ”§ __contains__(self, node_id) (line 79)
       ğŸ“ Calls: *.get_node_attributes
   â””â”€â”€ ğŸ”§ __getitem__(self, node_id) (line 89)
       ğŸ“ Calls: *.get_node_attributes, Node
   â””â”€â”€ ğŸ”§ keys(self) (line 97)
       ğŸ“ Calls: *.get_node_ids, *.keys
   â””â”€â”€ ğŸ”§ __iter__(self) (line 103)
       ğŸ“ Calls: iter, self.keys
   â””â”€â”€ ğŸ”§ values(self) (line 106)
       ğŸ“ Calls: *.values, self.keys
   â””â”€â”€ ğŸ”§ items(self) (line 112)
       ğŸ“ Calls: *.items, list, self.keys
   â””â”€â”€ ğŸ”§ items_iter(self) (line 118)
       ğŸ“ Calls: *.items, iter, self.keys
       ğŸ’¬ Iterator version of items() for memory efficiency

ğŸ“ CLASS: EdgeView (line 126)
   ğŸ“ View of edges - works with both dict and Rust backend
   â””â”€â”€ ğŸ”§ __init__(self, data) (line 129)
       ğŸ“ Calls: isinstance
   â””â”€â”€ ğŸ”§ __len__(self) (line 139)
       ğŸ“ Calls: *.edge_count, len
   â””â”€â”€ ğŸ”§ __contains__(self, edge_id) (line 145)
       ğŸ“ Calls: *.get_edge_attributes, edge_id.split, len
   â””â”€â”€ ğŸ”§ __getitem__(self, edge_id) (line 159)
       ğŸ“ Calls: â”Œâ”€ *.get_edge_attributes, Edge, KeyError, edge_id.split
              â”‚  len
              â””â”€
   â””â”€â”€ ğŸ”§ keys(self) (line 171)
       ğŸ“ Calls: *.get_edge_ids, *.keys
   â””â”€â”€ ğŸ”§ __iter__(self) (line 177)
       ğŸ“ Calls: iter, self.keys
   â””â”€â”€ ğŸ”§ values(self) (line 180)
       ğŸ“ Calls: *.values, self.keys
   â””â”€â”€ ğŸ”§ items(self) (line 186)
       ğŸ“ Calls: *.items, list, self.keys
   â””â”€â”€ ğŸ”§ items_iter(self) (line 192)
       ğŸ“ Calls: *.items, iter, self.keys
       ğŸ’¬ Iterator version of items() for memory efficiency

============================================================
FILE: groggy/graph/filtering.py
============================================================

ğŸ“ CLASS: QueryCompiler (line 19)
   ğŸ“ Compiles string-based queries into executable filter functions.
   â””â”€â”€ ğŸ”§ compile_node_query(cls, query_str) (line 42)
       ğŸ“ Calls: cls._evaluate_query
       ğŸ’¬ Compile a string query into a function for node filtering.
   â””â”€â”€ ğŸ”§ compile_edge_query(cls, query_str) (line 58)
       ğŸ“ Calls: â”Œâ”€ attributes.copy, cls._evaluate_query
              â”‚  extended_attrs.update
              â””â”€
       ğŸ’¬ Compile a string query into a function for edge filtering.
   â””â”€â”€ ğŸ”§ _evaluate_query(cls, query_str, context) (line 81)
       ğŸ“ Calls: â”Œâ”€ ValueError, cls._evaluate_logical_expression
              â”‚  cls._evaluate_simple_expression
              â”‚  cls._preprocess_logical_operators
              â”‚  cls._split_logical_expression, len
              â””â”€
       ğŸ’¬ Evaluate a query string against a context dictionary.
   â””â”€â”€ ğŸ”§ _preprocess_logical_operators(cls, query_str) (line 110)
       ğŸ“ Calls: re.sub
       ğŸ’¬ Normalize logical operators.
   â””â”€â”€ ğŸ”§ _split_logical_expression(cls, query_str) (line 119)
       ğŸ“ Calls: â”Œâ”€ part.strip, parts.append, query_str.split
              â”‚  query_str.strip
              â””â”€
       ğŸ’¬ Split expression by logical operators while preserving them.
   â””â”€â”€ ğŸ”§ _evaluate_logical_expression(cls, parts, context) (line 138)
       ğŸ“ Calls: cls._evaluate_simple_expression, len
       ğŸ’¬ Evaluate a logical expression with multiple parts.
   â””â”€â”€ ğŸ”§ _evaluate_simple_expression(cls, expr, context) (line 160)
       ğŸ“ Calls: â”Œâ”€ *.items, *.strip, ValueError, cls._parse_literal
              â”‚  expr.split, expr.strip, float, int, isinstance, len
              â”‚  op_func
              â””â”€
       ğŸ’¬ Evaluate a simple comparison expression.
   â””â”€â”€ ğŸ”§ _parse_literal(cls, value_str) (line 208)
       ğŸ“ Calls: â”Œâ”€ float, int, value_str.endswith, value_str.lower
              â”‚  value_str.startswith, value_str.strip
              â””â”€
       ğŸ’¬ Parse a literal value from a string.

ğŸ“ CLASS: SubgraphCreator (line 240)
   ğŸ“ Creates subgraphs from filtering operations.
   â””â”€â”€ ğŸ”§ create_node_subgraph(source_graph, node_ids, filter_criteria) (line 244)
       ğŸ“ Calls: â”Œâ”€ Subgraph, source_graph.get_node, str
              â”‚  subgraph.add_edge, subgraph.add_node
              â””â”€
       ğŸ’¬ Create a subgraph containing only the specified nodes and edges between them.
   â””â”€â”€ ğŸ”§ create_edge_subgraph(source_graph, edge_ids, filter_criteria) (line 282)
       ğŸ“ Calls: â”Œâ”€ *.keys, Subgraph, ValueError, actual_edge_ids.append
              â”‚  connected_nodes.add, isinstance, list, set
              â”‚  source_graph.get_node, str, subgraph.add_edge
              â”‚  subgraph.add_node
              â””â”€
       ğŸ’¬ Create a subgraph containing only the specified edges and their connected nodes.

âš™ï¸  FUNCTION: enhanced_filter_nodes(graph, filter_criteria, return_subgraph) (line 354)
   ğŸ“ Calls: â”Œâ”€ QueryCompiler.compile_node_query
          â”‚  SubgraphCreator.create_node_subgraph, ValueError
          â”‚  callable, effective_nodes.items, filter_criteria.items
          â”‚  filter_func, graph._get_effective_data, graph.get_node
          â”‚  isinstance, result.append
          â””â”€
   ğŸ“ Enhanced node filtering with optional subgraph creation.

âš™ï¸  FUNCTION: enhanced_filter_edges(graph, filter_criteria, return_subgraph) (line 409)
   ğŸ“ Calls: â”Œâ”€ QueryCompiler.compile_edge_query
          â”‚  SubgraphCreator.create_edge_subgraph, ValueError
          â”‚  callable, effective_edges.items, filter_criteria.items
          â”‚  filter_func, graph._get_effective_data, isinstance
          â”‚  result.append
          â””â”€
   ğŸ“ Enhanced edge filtering with optional subgraph creation.

============================================================
FILE: groggy/graph/batch.py
============================================================

ğŸ“ CLASS: BatchOperationContext (line 12)
   ğŸ“ Context manager for efficient batch operations
   â””â”€â”€ ğŸ”§ __init__(self, graph) (line 15)
   â””â”€â”€ ğŸ”§ __enter__(self) (line 20)
   â””â”€â”€ ğŸ”§ __exit__(self, exc_type, exc_val, exc_tb) (line 23)
       ğŸ“ Calls: *._apply_batch_operations
   â””â”€â”€ ğŸ”§ add_node(self, node_id) (line 27)
       ğŸ“ Calls: Node, uuid.uuid4
       ğŸ’¬ Queue node for batch addition
   â””â”€â”€ ğŸ”§ add_edge(self, source, target) (line 39)
       ğŸ“ Calls: Edge, Node
       ğŸ’¬ Queue edge for batch addition
   â””â”€â”€ ğŸ”§ set_node_attributes(self, node_attr_dict) (line 53)
       ğŸ“ Calls: â”Œâ”€ *.copy, Node, current_attrs.update, new_attrs.update
              â”‚  node_attr_dict.items, str
              â””â”€
       ğŸ’¬ Queue bulk node attribute updates
   â””â”€â”€ ğŸ”§ set_edge_attributes(self, edge_attr_dict) (line 78)
       ğŸ“ Calls: â”Œâ”€ *.copy, Edge, current_attrs.update
              â”‚  edge_attr_dict.items, new_attrs.update, str
              â””â”€
       ğŸ’¬ Queue bulk edge attribute updates

============================================================
FILE: groggy/graph/core.py
============================================================

ğŸ“ CLASS: Graph (line 26)
   ğŸ“ High-level Graph interface with automatic Rust/Python backend selection
   â””â”€â”€ ğŸ”§ __init__(self, nodes, edges, graph_attributes, backend, max_auto_states, directed) (line 29)
       ğŸ“ Calls: â”Œâ”€ _core.FastGraph, _core.GraphStore, deque
              â”‚  get_current_backend, self._init_python_backend
              â”‚  self._init_rust_backend
              â””â”€
   â””â”€â”€ ğŸ”§ _init_rust_backend(self, nodes, edges, graph_attributes) (line 73)
       ğŸ“ Calls: *.add_edges, *.add_nodes, edges.values, nodes.items
       ğŸ’¬ Initialize Rust backend
   â””â”€â”€ ğŸ”§ _init_python_backend(self, nodes, edges, graph_attributes) (line 83)
       ğŸ“ Calls: dict
       ğŸ’¬ Initialize Python backend (fallback)
   â””â”€â”€ ğŸ”§ _invalidate_cache(self) (line 99)
       ğŸ“ Calls: *.clear
       ğŸ’¬ Invalidate the cache when graph structure changes
   â””â”€â”€ ğŸ”§ empty(cls, backend) (line 110)
       ğŸ“ Calls: cls
       ğŸ’¬ Create an empty graph
   â””â”€â”€ ğŸ”§ from_node_list(cls, node_ids, node_attrs, backend) (line 115)
       ğŸ“ Calls: Node, cls, enumerate, len, node_attrs.items
       ğŸ’¬ Create graph from vectorized node data (NumPy-style)
   â””â”€â”€ ğŸ”§ from_edge_list(cls, edges, node_attrs, edge_attrs, backend) (line 132)
       ğŸ“ Calls: â”Œâ”€ Edge, Node, cls, edge_attrs.items, enumerate, len
              â”‚  node_attrs.items, node_set.add, set, sorted
              â””â”€
       ğŸ’¬ Create graph from edge list (NetworkX-style)
   â””â”€â”€ ğŸ”§ nodes(self) (line 169)
       ğŸ“ Calls: â”Œâ”€ *.get_node_attributes, *.get_node_ids, Node
              â”‚  NodeView, self._get_effective_data
              â””â”€
       ğŸ’¬ Access nodes as a lazy dict-like interface
   â””â”€â”€ ğŸ”§ edges(self) (line 186)
       ğŸ“ Calls: â”Œâ”€ *.get_edge_attributes, *.get_edge_ids, Edge
              â”‚  EdgeView, edge_id.split, self._get_effective_data
              â””â”€
       ğŸ’¬ Access edges as a lazy dict-like interface
   â””â”€â”€ ğŸ”§ states(self) (line 206)
       ğŸ“ Calls: â”Œâ”€ *.get_current_hash, *.get_stats, *.list_branches
              â”‚  all_state_hashes.append, getattr, len, list, set
              â”‚  stats.get
              â””â”€
       ğŸ’¬ Get all states with their hashes (lazy-loaded view into backend)
   â””â”€â”€ ğŸ”§ branches(self) (line 242)
       ğŸ“ Calls: *.list_branches, getattr
       ğŸ’¬ Get current branches from backend (lazy-loaded view)
   â””â”€â”€ ğŸ”§ add_node(self, node_id) (line 254)
       ğŸ“ Calls: â”Œâ”€ *.add_node, Node, self._init_delta
              â”‚  self._invalidate_cache
              â”‚  self._update_cache_for_node_add, str, uuid.uuid4
              â””â”€
       ğŸ’¬ Add a node to the graph
   â””â”€â”€ ğŸ”§ add_edge(self, source, target) (line 283)
       ğŸ“ Calls: â”Œâ”€ *.add_edge, Edge, Node, self._get_effective_data
              â”‚  self._init_delta, self._invalidate_cache
              â”‚  self._update_cache_for_edge_add, self.add_node, str
              â””â”€
       ğŸ’¬ Add an edge to the graph
   â””â”€â”€ ğŸ”§ batch_operations(self) (line 329)
       ğŸ“ Calls: BatchOperationContext
       ğŸ’¬ Context manager for efficient batch operations
   â””â”€â”€ ğŸ”§ node_count(self) (line 333)
       ğŸ“ Calls: *.node_count, len, self._get_effective_data
       ğŸ’¬ Get the number of nodes
   â””â”€â”€ ğŸ”§ edge_count(self) (line 341)
       ğŸ“ Calls: *.edge_count, len, self._get_effective_data
       ğŸ’¬ Get the number of edges
   â””â”€â”€ ğŸ”§ get_node(self, node_id) (line 349)
       ğŸ“ Calls: â”Œâ”€ *.get_node_attributes, Node, effective_nodes.get
              â”‚  self._get_effective_data, str
              â””â”€
       ğŸ’¬ Get a specific node by ID
   â””â”€â”€ ğŸ”§ get_edge(self, source, target) (line 361)
       ğŸ“ Calls: â”Œâ”€ *.get_edge_attributes, Edge, effective_edges.get
              â”‚  self._get_effective_data, str
              â””â”€
       ğŸ’¬ Get a specific edge by source and target node IDs
   â””â”€â”€ ğŸ”§ has_edge(self, source, target) (line 375)
       ğŸ“ Calls: *.has_edge, self._get_effective_data, str
       ğŸ’¬ Check if an edge exists between source and target nodes
   â””â”€â”€ ğŸ”§ has_node(self, node_id) (line 386)
       ğŸ“ Calls: *.has_node, self._get_effective_data, str
       ğŸ’¬ Check if a node exists in the graph
   â””â”€â”€ ğŸ”§ is_directed(self) (line 395)
       ğŸ’¬ Check if the graph is directed
   â””â”€â”€ ğŸ”§ get_node_ids(self) (line 399)
       ğŸ“ Calls: â”Œâ”€ *.get_node_ids, effective_nodes.keys, list
              â”‚  self._get_effective_data
              â””â”€
       ğŸ’¬ Get all node IDs
   â””â”€â”€ ğŸ”§ node_id_to_index(self) (line 408)
       ğŸ“ Calls: â”Œâ”€ effective_nodes.keys, enumerate
              â”‚  self._get_effective_data
              â””â”€
       ğŸ’¬ Get node ID to internal index mapping for debugging (Python backend only)
   â””â”€â”€ ğŸ”§ get_neighbors(self, node_id, direction) (line 417)
       ğŸ“ Calls: â”Œâ”€ *.get_all_neighbors, *.get_incoming_neighbors
              â”‚  *.get_neighbors, *.get_outgoing_neighbors
              â”‚  effective_edges.values, list, neighbors.add
              â”‚  self._get_effective_data, set, str
              â””â”€
       ğŸ’¬ Get neighbors of a node
   â””â”€â”€ ğŸ”§ get_outgoing_neighbors(self, node_id) (line 460)
       ğŸ“ Calls: â”Œâ”€ *.get_outgoing_neighbors, effective_edges.values
              â”‚  list, neighbors.add, self._get_effective_data, set
              â”‚  str
              â””â”€
       ğŸ’¬ Get outgoing neighbors of a node (for directed graphs)
   â””â”€â”€ ğŸ”§ get_incoming_neighbors(self, node_id) (line 475)
       ğŸ“ Calls: â”Œâ”€ *.get_incoming_neighbors, effective_edges.values
              â”‚  list, neighbors.add, self._get_effective_data, set
              â”‚  str
              â””â”€
       ğŸ’¬ Get incoming neighbors of a node (for directed graphs)
   â””â”€â”€ ğŸ”§ get_all_neighbors(self, node_id) (line 490)
       ğŸ“ Calls: â”Œâ”€ *.get_all_neighbors, effective_edges.values, list
              â”‚  neighbors.add, self._get_effective_data, set, str
              â””â”€
       ğŸ’¬ Get all neighbors of a node (both incoming and outgoing)
   â””â”€â”€ ğŸ”§ filter_nodes(self, filter_func, return_subgraph) (line 508)
       ğŸ“ Calls: â”Œâ”€ QueryCompiler.compile_node_query, ValueError
              â”‚  isinstance, list, self._create_subgraph_from_nodes
              â”‚  self._filter_nodes_by_dict_vectorized
              â”‚  self._filter_nodes_vectorized
              â”‚  self._try_optimized_string_filter_nodes
              â”‚  self.get_node_ids
              â””â”€
       ğŸ’¬ Filter nodes by lambda function, attribute values, string query, or keyword arguments
   â””â”€â”€ ğŸ”§ filter_edges(self, filter_func, return_subgraph) (line 578)
       ğŸ“ Calls: â”Œâ”€ *.keys, QueryCompiler.compile_edge_query, ValueError
              â”‚  isinstance, list, self._create_subgraph_from_edges
              â”‚  self._filter_edges_by_dict_vectorized
              â”‚  self._filter_edges_vectorized
              â”‚  self._try_optimized_string_filter_edges
              â””â”€
       ğŸ’¬ Filter edges by lambda function, attribute values, string query, or keyword arguments
   â””â”€â”€ ğŸ”§ set_node_attribute(self, node_id, attribute, value) (line 647)
       ğŸ“ Calls: â”Œâ”€ *.set_node_attribute, KeyError, hasattr
              â”‚  self._invalidate_cache, str
              â””â”€
       ğŸ’¬ Set a single attribute on a node
   â””â”€â”€ ğŸ”§ set_edge_attribute(self, source, target, attribute, value) (line 668)
       ğŸ“ Calls: â”Œâ”€ *.set_edge_attribute, KeyError, hasattr
              â”‚  self._invalidate_cache, str
              â””â”€
       ğŸ’¬ Set a single attribute on an edge
   â””â”€â”€ ğŸ”§ set_node_attributes(self, node_id, attributes) (line 692)
       ğŸ“ Calls: attributes.items, self.set_node_attribute
       ğŸ’¬ Set multiple attributes on a node
   â””â”€â”€ ğŸ”§ set_edge_attributes(self, source, target, attributes) (line 702)
       ğŸ“ Calls: attributes.items, self.set_edge_attribute
       ğŸ’¬ Set multiple attributes on an edge
   â””â”€â”€ ğŸ”§ set_nodes_attributes_batch(self, node_attrs) (line 713)
       ğŸ“ Calls: â”Œâ”€ *.set_nodes_attributes_batch, node_attrs.items
              â”‚  self._invalidate_cache, self.set_node_attributes, str
              â””â”€
       ğŸ’¬ Set attributes on multiple nodes efficiently
   â””â”€â”€ ğŸ”§ set_edges_attributes_batch(self, edge_attrs) (line 732)
       ğŸ“ Calls: â”Œâ”€ *.set_edges_attributes_batch, edge_attrs.items
              â”‚  self._invalidate_cache, self.set_edge_attributes, str
              â””â”€
       ğŸ’¬ Set attributes on multiple edges efficiently
   â””â”€â”€ ğŸ”§ get_node_attributes(self, node_id) (line 751)
       ğŸ“ Calls: KeyError, dict, self.get_node
       ğŸ’¬ Get all attributes of a node
   â””â”€â”€ ğŸ”§ get_edge_attributes(self, source, target) (line 766)
       ğŸ“ Calls: KeyError, dict, self.get_edge, str
       ğŸ’¬ Get all attributes of an edge
   â””â”€â”€ ğŸ”§ get_nodes_attribute(self, node_ids, attr_name) (line 785)
       ğŸ“ Calls: *.get_nodes_attribute, self.get_node, str
       ğŸ’¬ Get a specific attribute for multiple nodes efficiently
   â””â”€â”€ ğŸ”§ get_nodes_attributes(self, node_ids) (line 808)
       ğŸ“ Calls: *.get_nodes_attributes, dict, self.get_node, str
       ğŸ’¬ Get all attributes for multiple nodes efficiently
   â””â”€â”€ ğŸ”§ get_all_nodes_attribute(self, attr_name) (line 830)
       ğŸ“ Calls: â”Œâ”€ *.get_all_nodes_attribute, effective_nodes.items
              â”‚  self._get_effective_data
              â””â”€
       ğŸ’¬ Get a specific attribute for all nodes efficiently (useful for statistics)
   â””â”€â”€ ğŸ”§ get_edges_attribute(self, edge_endpoints, attr_name) (line 851)
       ğŸ“ Calls: *.get_edges_attribute, self.get_edge, str
       ğŸ’¬ Get a specific attribute for multiple edges efficiently
   â””â”€â”€ ğŸ”§ get_all_edges_attribute(self, attr_name) (line 874)
       ğŸ“ Calls: â”Œâ”€ *.get_all_edges_attribute, effective_edges.items
              â”‚  self._get_effective_data
              â””â”€
       ğŸ’¬ Get a specific attribute for all edges efficiently (useful for statistics)
   â””â”€â”€ ğŸ”§ get_edge_ids(self) (line 895)
       ğŸ“ Calls: â”Œâ”€ *.get_edge_ids, effective_edges.keys, list
              â”‚  self._get_effective_data
              â””â”€
       ğŸ’¬ Get all edge IDs in the graph
   â””â”€â”€ ğŸ”§ to_dataframe(self, attr_names, node_ids, library) (line 909)
       ğŸ“ Calls: â”Œâ”€ ImportError, NotImplementedError, ValueError
              â”‚  pd.DataFrame, pl.DataFrame
              â”‚  self.get_dataframe_data_fast
              â””â”€
       ğŸ’¬ Convert graph node data to DataFrame format for efficient analysis
   â””â”€â”€ ğŸ”§ get_dataframe_data_fast(self, attr_names, node_ids) (line 947)
       ğŸ“ Calls: *.get_dataframe_data, NotImplementedError, str
       ğŸ’¬ Ultra-fast DataFrame data retrieval using vectorized Rust backend
   â””â”€â”€ ğŸ”§ get_bulk_node_attribute_vectors(self, attr_names, node_ids) (line 971)
       ğŸ“ Calls: â”Œâ”€ *.get_bulk_node_attribute_vectors
              â”‚  NotImplementedError, str
              â””â”€
       ğŸ’¬ Ultra-fast vectorized bulk attribute retrieval using columnar store optimization
   â””â”€â”€ ğŸ”§ get_single_attribute_vectorized(self, attr_name, node_ids) (line 995)
       ğŸ“ Calls: â”Œâ”€ *.get_single_attribute_vectorized
              â”‚  NotImplementedError, str
              â””â”€
       ğŸ’¬ Ultra-fast single attribute column retrieval using vectorized columnar operations
   â””â”€â”€ ğŸ”§ export_node_dataframe_optimized(self, attr_names, node_ids) (line 1019)
       ğŸ“ Calls: â”Œâ”€ *.export_node_dataframe_optimized
              â”‚  NotImplementedError, str
              â””â”€
       ğŸ’¬ Ultra-fast DataFrame-style bulk data export optimized for pandas/polars
   â””â”€â”€ ğŸ”§ add_nodes_chunked(self, nodes_data, chunk_size) (line 1045)
       ğŸ“ Calls: â”Œâ”€ *.add_nodes_chunked, node_data.items
              â”‚  rust_nodes.append, self._invalidate_cache
              â”‚  self.add_nodes, str
              â””â”€
       ğŸ’¬ High-performance chunked node creation for very large datasets
   â””â”€â”€ ğŸ”§ set_node_attributes_chunked(self, updates, chunk_size) (line 1072)
       ğŸ“ Calls: â”Œâ”€ *.set_node_attributes_chunked, *.update, len, list
              â”‚  range, self._get_effective_data, self._init_delta
              â”‚  self._invalidate_cache, str, updates.items
              â””â”€
       ğŸ’¬ High-performance chunked attribute updates for large datasets
   â””â”€â”€ ğŸ”§ get_attribute_column(self, attr_name, node_ids) (line 1110)
       ğŸ“ Calls: â”Œâ”€ *.get_single_attribute_vectorized
              â”‚  effective_nodes.items, result_ids.append
              â”‚  result_values.append, self._get_effective_data, str
              â””â”€
       ğŸ’¬ Ultra-fast single attribute column retrieval
   â””â”€â”€ ğŸ”§ filter_nodes_multi_criteria(self, exact_matches, numeric_comparisons, string_comparisons) (line 1143)
       ğŸ“ Calls: â”Œâ”€ *.filter_nodes_multi_criteria, abs
              â”‚  effective_nodes.items, effective_nodes.keys
              â”‚  exact_matches.items, float, list, matching.add
              â”‚  node_val.endswith, node_val.startswith
              â”‚  self._get_effective_data, set, str
              â””â”€
       ğŸ’¬ Advanced multi-criteria node filtering with high performance
   â””â”€â”€ ğŸ”§ update_node(self, node_id, attributes) (line 1251)
       ğŸ“ Calls: â”Œâ”€ *.set_node_attribute, *.update, Node
              â”‚  combined_attrs.items, combined_attrs.update
              â”‚  self._init_delta, self._invalidate_cache
              â”‚  self._update_cache_for_node_add, str
              â””â”€
       ğŸ’¬ Update node attributes with a user-friendly interface
   â””â”€â”€ ğŸ”§ update_edge(self, source, target, attributes) (line 1288)
       ğŸ“ Calls: â”Œâ”€ *.set_edge_attributes, *.update, Edge
              â”‚  combined_attrs.update, self._init_delta
              â”‚  self._invalidate_cache
              â”‚  self._update_cache_for_edge_add, str
              â””â”€
       ğŸ’¬ Update edge attributes with a user-friendly interface
   â””â”€â”€ ğŸ”§ add_nodes(self, nodes_data) (line 1328)
       ğŸ“ Calls: â”Œâ”€ *.add_nodes, Node, node_data.items
              â”‚  rust_nodes.append, self._init_delta
              â”‚  self._invalidate_cache
              â”‚  self._update_cache_for_node_add, str
              â””â”€
       ğŸ’¬ Add multiple nodes efficiently in a single operation
   â””â”€â”€ ğŸ”§ add_edges(self, edges_data) (line 1364)
       ğŸ“ Calls: â”Œâ”€ *.add_edges, Edge, Node, edge_data.items
              â”‚  rust_edges.append, self._get_effective_data
              â”‚  self._init_delta, self._invalidate_cache
              â”‚  self._update_cache_for_edge_add, str
              â””â”€
       ğŸ’¬ Add multiple edges efficiently in a single operation
   â””â”€â”€ ğŸ”§ update_nodes(self, updates) (line 1410)
       ğŸ“ Calls: â”Œâ”€ *.set_nodes_attributes_batch, Node
              â”‚  self._get_effective_data, self._init_delta
              â”‚  self._invalidate_cache
              â”‚  self._update_cache_for_node_add, str, updates.items
              â””â”€
       ğŸ’¬ Update multiple nodes efficiently in a single operation
   â””â”€â”€ ğŸ”§ remove_node(self, node_id) (line 1455)
       ğŸ“ Calls: â”Œâ”€ *.add, *.remove_node, edges_to_remove.append
              â”‚  effective_edges.items, self._get_effective_data
              â”‚  self._init_delta, self._invalidate_cache, str
              â””â”€
       ğŸ’¬ Remove a node from the graph
   â””â”€â”€ ğŸ”§ remove_edge(self, source, target) (line 1494)
       ğŸ“ Calls: â”Œâ”€ *.add, *.remove_edge, self._get_effective_data
              â”‚  self._init_delta, self._invalidate_cache, str
              â””â”€
       ğŸ’¬ Remove an edge from the graph
   â””â”€â”€ ğŸ”§ remove_nodes(self, node_ids) (line 1524)
       ğŸ“ Calls: â”Œâ”€ *.add, *.remove_nodes, edges_to_remove.append
              â”‚  effective_edges.items, self._get_effective_data
              â”‚  self._init_delta, self._invalidate_cache, str
              â””â”€
       ğŸ’¬ Remove multiple nodes efficiently
   â””â”€â”€ ğŸ”§ remove_edges(self, edge_pairs) (line 1564)
       ğŸ“ Calls: â”Œâ”€ *.add, *.remove_edges, self._get_effective_data
              â”‚  self._init_delta, self._invalidate_cache, str
              â””â”€
       ğŸ’¬ Remove multiple edges efficiently
   â””â”€â”€ ğŸ”§ subgraph(self, node_ids, edge_ids, include_edges) (line 1596)
       ğŸ“ Calls: â”Œâ”€ ValueError, self._create_subgraph_from_edges
              â”‚  self._create_subgraph_from_nodes, str
              â””â”€
       ğŸ’¬ Create a single subgraph from specified nodes or edges
   â””â”€â”€ ğŸ”§ subgraphs(self, group_by) (line 1632)
       ğŸ“ Calls: â”Œâ”€ *.join, ValueError, filter_criteria.update
              â”‚  filters.items, group_by.items, groups.items
              â”‚  isinstance, iter, len, matching_nodes.append, next
              â”‚  self._create_subgraph_from_nodes, self.filter_nodes
              â”‚  self.get_node, set, str, unique_values.add
              â””â”€
       ğŸ’¬ Create multiple subgraphs grouped by attribute values
   â””â”€â”€ ğŸ”§ _filter_nodes_vectorized(self, filter_func) (line 1760)
       ğŸ“ Calls: â”Œâ”€ *.get_node_ids, *.get_nodes_attributes
              â”‚  all_attributes.get, effective_nodes.items
              â”‚  filter_func, filtered_node_ids.append
              â”‚  self._get_effective_data
              â””â”€
       ğŸ’¬ Vectorized node filtering for better performance on large graphs.
   â””â”€â”€ ğŸ”§ _filter_edges_vectorized(self, filter_func) (line 1801)
       ğŸ“ Calls: â”Œâ”€ *.get_edge_ids, *.get_edges_attributes
              â”‚  all_attributes.get, edge_endpoints.append
              â”‚  edge_id.split, effective_edges.items, enumerate
              â”‚  filter_func, filtered_edge_ids.append, len
              â”‚  self._get_effective_data
              â””â”€
       ğŸ’¬ Vectorized edge filtering for better performance on large graphs.
   â””â”€â”€ ğŸ”§ _filter_nodes_optimized(self, filter_func) (line 1851)
       ğŸ“ Calls: â”Œâ”€ QueryCompiler.compile_node_query, ValueError
              â”‚  callable, isinstance, list
              â”‚  self._filter_nodes_by_dict_vectorized
              â”‚  self._filter_nodes_vectorized, self.get_node_ids
              â”‚  type
              â””â”€
       ğŸ’¬ Highly optimized node filtering that detects filter patterns and applies
   â””â”€â”€ ğŸ”§ _filter_nodes_by_dict_vectorized(self, filter_dict) (line 1882)
       ğŸ“ Calls: â”Œâ”€ *.filter_nodes_by_attributes
              â”‚  *.filter_nodes_multi_criteria, *.get, all
              â”‚  effective_nodes.items, filter_dict.items
              â”‚  filter_dict.values, filtered_ids.append, float
              â”‚  isinstance, len, list, numeric_comparisons.append
              â”‚  self._get_effective_data, self.get_node_ids, str
              â”‚  string_comparisons.append
              â””â”€
       ğŸ’¬ Super-optimized filtering for dictionary-based filters.
   â””â”€â”€ ğŸ”§ _filter_edges_optimized(self, filter_func) (line 1964)
       ğŸ“ Calls: â”Œâ”€ *.keys, QueryCompiler.compile_edge_query, ValueError
              â”‚  callable, isinstance, list
              â”‚  self._filter_edges_by_dict_vectorized
              â”‚  self._filter_edges_vectorized, type
              â””â”€
       ğŸ’¬ Highly optimized edge filtering that detects filter patterns and applies
   â””â”€â”€ ğŸ”§ _filter_edges_by_dict_vectorized(self, filter_dict) (line 1995)
       ğŸ“ Calls: â”Œâ”€ *.filter_edges_by_attributes
              â”‚  *.filter_edges_multi_criteria, *.get, *.keys, all
              â”‚  effective_edges.items, filter_dict.items
              â”‚  filter_dict.values, filtered_ids.append, float
              â”‚  isinstance, len, list, numeric_comparisons.append
              â”‚  self._get_effective_data, str
              â”‚  string_comparisons.append
              â””â”€
       ğŸ’¬ Super-optimized filtering for dictionary-based edge filters.
   â””â”€â”€ ğŸ”§ _try_optimized_string_filter_nodes(self, query_str) (line 2077)
       ğŸ“ Calls: â”Œâ”€ *.filter_nodes_by_numeric_comparison
              â”‚  *.filter_nodes_by_string_comparison, float
              â”‚  match.groups, re.match
              â””â”€
       ğŸ’¬ Try to optimize simple string queries using fast Rust backend operations.
   â””â”€â”€ ğŸ”§ _try_optimized_string_filter_edges(self, query_str) (line 2110)
       ğŸ“ Calls: â”Œâ”€ *.filter_edges_by_numeric_comparison
              â”‚  *.filter_edges_by_string_comparison, float
              â”‚  match.groups, re.match
              â””â”€
       ğŸ’¬ Try to optimize simple string queries for edges using fast Rust backend operations.

============================================================
FILE: groggy/graph/subgraph.py
============================================================

ğŸ“ CLASS: Subgraph (line 11)
   ğŸ“ A Subgraph is a Graph with additional metadata about its origin.
   â””â”€â”€ ğŸ”§ __init__(self, parent_graph, filter_criteria, metadata) (line 21)
       ğŸ“ Calls: *.__init__, super
       ğŸ’¬ Initialize a Subgraph.
   â””â”€â”€ ğŸ”§ __repr__(self) (line 40)
       ğŸ“ Calls: *.__repr__, super
       ğŸ’¬ String representation of the subgraph.
   â””â”€â”€ ğŸ”§ get_metadata(self) (line 47)
       ğŸ’¬ Get all metadata about this subgraph.

============================================================
FILE: groggy/graph/state.py
============================================================

ğŸ“ CLASS: StateMixin (line 8)
   ğŸ“ Mixin class providing state management functionality
   â””â”€â”€ ğŸ”§ save_state(self, message) (line 11)
       ğŸ“ Calls: â”Œâ”€ *.append, *.list_branches, *.store_current_graph
              â”‚  NotImplementedError, hasattr, len
              â””â”€
       ğŸ’¬ Save the current graph state to storage
   â””â”€â”€ ğŸ”§ commit(self, message) (line 37)
       ğŸ“ Calls: self.save_state
       ğŸ’¬ Legacy alias for save_state
   â””â”€â”€ ğŸ”§ create_branch(self, branch_name, from_hash, switch) (line 41)
       ğŸ“ Calls: â”Œâ”€ *.create_branch, NotImplementedError
              â”‚  self.switch_branch
              â””â”€
       ğŸ’¬ Create a new branch (delegated to Rust)
   â””â”€â”€ ğŸ”§ get_storage_stats(self) (line 51)
       ğŸ“ Calls: *.get_stats
       ğŸ’¬ Get storage statistics (delegated to Rust)
   â””â”€â”€ ğŸ”§ load_state(self, state_hash) (line 58)
       ğŸ“ Calls: â”Œâ”€ *.get_current_hash, *.get_graph_from_state
              â”‚  NotImplementedError, print, self._invalidate_cache
              â””â”€
       ğŸ’¬ Load a previous state of the graph
   â””â”€â”€ ğŸ”§ get_state_info(self, state_hash) (line 87)
       ğŸ“ Calls: â”Œâ”€ *.get_current_hash, *.items, NotImplementedError
              â”‚  branches_for_state.append, hasattr
              â””â”€
       ğŸ’¬ Get detailed information about a specific state or current state
   â””â”€â”€ ğŸ”§ switch_branch(self, branch_name) (line 115)
       ğŸ“ Calls: â”Œâ”€ NotImplementedError, branches.keys, list, print
              â”‚  self.load_state
              â””â”€
       ğŸ’¬ Switch to a different branch

============================================================
SUMMARY: Analyzed 10 files
============================================================